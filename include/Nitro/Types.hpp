// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
#include "beatsaber-hook/shared/utils/typedefs-string.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: System
namespace System {
  // Forward declaring type: Type
  class Type;
}
// Forward declaring namespace: System::Reflection
namespace System::Reflection {
  // Forward declaring type: MethodInfo
  class MethodInfo;
  // Forward declaring type: ConstructorInfo
  class ConstructorInfo;
  // Forward declaring type: ParameterInfo
  class ParameterInfo;
  // Forward declaring type: MemberInfo
  class MemberInfo;
}
// Forward declaring namespace: Nitro
namespace Nitro {
  // Forward declaring type: CompiledFragment
  class CompiledFragment;
  // Forward declaring type: CompiledMethod
  class CompiledMethod;
  // Forward declaring type: NitroIL
  class NitroIL;
  // Forward declaring type: MethodOperation
  class MethodOperation;
  // Forward declaring type: CodeFragment
  class CodeFragment;
}
// Forward declaring namespace: System::Collections::Generic
namespace System::Collections::Generic {
  // Forward declaring type: List`1<T>
  template<typename T>
  class List_1;
}
// Completed forward declares
// Type namespace: Nitro
namespace Nitro {
  // Forward declaring type: Types
  class Types;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::Nitro::Types);
DEFINE_IL2CPP_ARG_TYPE(::Nitro::Types*, "Nitro", "Types");
// Type namespace: Nitro
namespace Nitro {
  // Size: 0x10
  #pragma pack(push, 1)
  // Autogenerated type: Nitro.Types
  // [TokenAttribute] Offset: FFFFFFFF
  class Types : public ::Il2CppObject {
    public:
    // static public System.Boolean IsNumeric(System.Type type)
    // Offset: 0x16E18E4
    static bool IsNumeric(::System::Type* type);
    // static public System.Reflection.MethodInfo GetCallable(System.Type type)
    // Offset: 0x16EC1F0
    static ::System::Reflection::MethodInfo* GetCallable(::System::Type* type);
    // static public System.Reflection.ConstructorInfo GetConstructor(System.Type type, Nitro.CompiledFragment[] args)
    // Offset: 0x16EC318
    static ::System::Reflection::ConstructorInfo* GetConstructor(::System::Type* type, ::ArrayW<::Nitro::CompiledFragment*> args);
    // static private System.Reflection.ConstructorInfo GetConstructor(System.Reflection.ConstructorInfo[] constructors, System.Type[] paramSet, System.Boolean withCasting)
    // Offset: 0x16EC400
    static ::System::Reflection::ConstructorInfo* GetConstructor(::ArrayW<::System::Reflection::ConstructorInfo*> constructors, ::ArrayW<::System::Type*> paramSet, bool withCasting);
    // static public System.String SetToString(System.Reflection.ParameterInfo[] set)
    // Offset: 0x16EC7E0
    static ::StringW SetToString(::ArrayW<::System::Reflection::ParameterInfo*> set);
    // static public System.Type[] SetToTypes(System.Reflection.ParameterInfo[] set)
    // Offset: 0x16EC93C
    static ::ArrayW<::System::Type*> SetToTypes(::ArrayW<::System::Reflection::ParameterInfo*> set);
    // static public System.Boolean IsParams(System.Reflection.ParameterInfo param)
    // Offset: 0x16ECA70
    static bool IsParams(::System::Reflection::ParameterInfo* param);
    // static public System.Boolean IsDynamic(System.Reflection.MemberInfo member)
    // Offset: 0x16E6508
    static bool IsDynamic(::System::Reflection::MemberInfo* member);
    // static public System.Int32 WillAccept(System.Type[] args, System.Reflection.ParameterInfo[] parameters, System.Boolean withCasting)
    // Offset: 0x16EC554
    static int WillAccept(::ArrayW<::System::Type*> args, ::ArrayW<::System::Reflection::ParameterInfo*> parameters, bool withCasting);
    // static public System.Boolean NoReturn(System.Reflection.MethodInfo methodInfo)
    // Offset: 0x16ECDD4
    static bool NoReturn(::System::Reflection::MethodInfo* methodInfo);
    // static public System.Boolean IsVoid(System.Type T)
    // Offset: 0x16E6854
    static bool IsVoid(::System::Type* T);
    // static public System.Void OutputParameters(Nitro.CompiledFragment[] args, Nitro.CompiledMethod method, Nitro.NitroIL into, System.Reflection.ParameterInfo[] parameters)
    // Offset: 0x16ECE0C
    static void OutputParameters(::ArrayW<::Nitro::CompiledFragment*> args, ::Nitro::CompiledMethod* method, ::Nitro::NitroIL* into, ::ArrayW<::System::Reflection::ParameterInfo*> parameters);
    // static public System.Type MethodReturnType(System.Type type, System.String name)
    // Offset: 0x16E6760
    static ::System::Type* MethodReturnType(::System::Type* type, ::StringW name);
    // static public System.Reflection.MethodInfo GetOverload(System.Collections.Generic.List`1<System.Reflection.MethodInfo> overloads, System.Type[] argSet)
    // Offset: 0x16E6F9C
    static ::System::Reflection::MethodInfo* GetOverload(::System::Collections::Generic::List_1<::System::Reflection::MethodInfo*>* overloads, ::ArrayW<::System::Type*> argSet);
    // static private System.Reflection.MethodInfo GetOverload(System.Collections.Generic.List`1<System.Reflection.MethodInfo> overloads, System.Type[] argSet, System.Boolean cast)
    // Offset: 0x16EDA88
    static ::System::Reflection::MethodInfo* GetOverload(::System::Collections::Generic::List_1<::System::Reflection::MethodInfo*>* overloads, ::ArrayW<::System::Type*> argSet, bool cast);
    // static public System.Reflection.MethodInfo GetOverload(System.Reflection.MethodInfo[] overloads, System.String name, System.Type[] argSet)
    // Offset: 0x16E698C
    static ::System::Reflection::MethodInfo* GetOverload(::ArrayW<::System::Reflection::MethodInfo*> overloads, ::StringW name, ::ArrayW<::System::Type*> argSet);
    // static public System.Reflection.MethodInfo GetOverload(System.Reflection.MethodInfo[] overloads, System.String name, System.Type[] argSet, System.Boolean ignoreCase)
    // Offset: 0x16E7148
    static ::System::Reflection::MethodInfo* GetOverload(::ArrayW<::System::Reflection::MethodInfo*> overloads, ::StringW name, ::ArrayW<::System::Type*> argSet, bool ignoreCase);
    // static private System.Reflection.MethodInfo GetOverload(System.Reflection.MethodInfo[] overloads, System.String name, System.Type[] argSet, System.Boolean ignoreCase, System.Boolean cast)
    // Offset: 0x16EDBB4
    static ::System::Reflection::MethodInfo* GetOverload(::ArrayW<::System::Reflection::MethodInfo*> overloads, ::StringW name, ::ArrayW<::System::Type*> argSet, bool ignoreCase, bool cast);
    // static public System.Boolean TypeSetsMatch(System.Type[] a, System.Type[] b)
    // Offset: 0x16EDD20
    static bool TypeSetsMatch(::ArrayW<::System::Type*> a, ::ArrayW<::System::Type*> b);
    // static public System.Boolean TypeSetsMatchExactly(System.Type[] a, System.Type[] b)
    // Offset: 0x16EDEB0
    static bool TypeSetsMatchExactly(::ArrayW<::System::Type*> a, ::ArrayW<::System::Type*> b);
    // static public Nitro.MethodOperation ToStringMethod(Nitro.CompiledMethod method, Nitro.CompiledFragment frag, System.Type type)
    // Offset: 0x16EDFD8
    static ::Nitro::MethodOperation* ToStringMethod(::Nitro::CompiledMethod* method, ::Nitro::CompiledFragment* frag, ::System::Type* type);
    // static public Nitro.CompiledFragment TryCast(Nitro.CompiledMethod method, Nitro.CompiledFragment frag, System.Type to, System.Type from)
    // Offset: 0x16E1DA8
    static ::Nitro::CompiledFragment* TryCast(::Nitro::CompiledMethod* method, ::Nitro::CompiledFragment* frag, ::System::Type* to, ::System::Type* from);
    // static public Nitro.CompiledFragment TryCast(Nitro.CompiledMethod method, Nitro.CompiledFragment frag, System.Type to, System.Type from, out System.Boolean isExplicit)
    // Offset: 0x16E15D0
    static ::Nitro::CompiledFragment* TryCast(::Nitro::CompiledMethod* method, ::Nitro::CompiledFragment* frag, ::System::Type* to, ::System::Type* from, ByRef<bool> isExplicit);
    // static public System.String NameWithoutNamespace(System.String typeName)
    // Offset: 0x16EE134
    static ::StringW NameWithoutNamespace(::StringW typeName);
    // static public System.Reflection.MethodInfo IsCastableTo(System.Type from, System.Type to, out System.Boolean isExplicit)
    // Offset: 0x16ECB24
    static ::System::Reflection::MethodInfo* IsCastableTo(::System::Type* from, ::System::Type* to, ByRef<bool> isExplicit);
    // static public System.Type[] GetTypes(System.Type first, Nitro.CompiledFragment[] frags)
    // Offset: 0x16E6DC4
    static ::ArrayW<::System::Type*> GetTypes(::System::Type* first, ::ArrayW<::Nitro::CompiledFragment*> frags);
    // static public System.Type[] GetTypes(Nitro.CompiledFragment[] frags)
    // Offset: 0x16E7000
    static ::ArrayW<::System::Type*> GetTypes(::ArrayW<::Nitro::CompiledFragment*> frags);
    // static public System.Boolean IsSubclass(System.Object obj, System.Type super)
    // Offset: 0x16EE210
    static bool IsSubclass(::Il2CppObject* obj, ::System::Type* super);
    // static public System.Boolean IsTypeOf(System.Object obj, System.Type super)
    // Offset: 0x16E8E8C
    static bool IsTypeOf(::Il2CppObject* obj, ::System::Type* super);
    // static public System.Boolean IsCompiled(Nitro.CodeFragment obj)
    // Offset: 0x16EE264
    static bool IsCompiled(::Nitro::CodeFragment* obj);
  }; // Nitro.Types
  #pragma pack(pop)
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: Nitro::Types::IsNumeric
// Il2CppName: IsNumeric
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)(::System::Type*)>(&Nitro::Types::IsNumeric)> {
  static const MethodInfo* get() {
    static auto* type = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::Types*), "IsNumeric", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{type});
  }
};
// Writing MetadataGetter for method: Nitro::Types::GetCallable
// Il2CppName: GetCallable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Reflection::MethodInfo* (*)(::System::Type*)>(&Nitro::Types::GetCallable)> {
  static const MethodInfo* get() {
    static auto* type = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::Types*), "GetCallable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{type});
  }
};
// Writing MetadataGetter for method: Nitro::Types::GetConstructor
// Il2CppName: GetConstructor
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Reflection::ConstructorInfo* (*)(::System::Type*, ::ArrayW<::Nitro::CompiledFragment*>)>(&Nitro::Types::GetConstructor)> {
  static const MethodInfo* get() {
    static auto* type = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* args = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("Nitro", "CompiledFragment"), 1)->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::Types*), "GetConstructor", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{type, args});
  }
};
// Writing MetadataGetter for method: Nitro::Types::GetConstructor
// Il2CppName: GetConstructor
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Reflection::ConstructorInfo* (*)(::ArrayW<::System::Reflection::ConstructorInfo*>, ::ArrayW<::System::Type*>, bool)>(&Nitro::Types::GetConstructor)> {
  static const MethodInfo* get() {
    static auto* constructors = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("System.Reflection", "ConstructorInfo"), 1)->byval_arg;
    static auto* paramSet = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("System", "Type"), 1)->byval_arg;
    static auto* withCasting = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::Types*), "GetConstructor", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{constructors, paramSet, withCasting});
  }
};
// Writing MetadataGetter for method: Nitro::Types::SetToString
// Il2CppName: SetToString
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::StringW (*)(::ArrayW<::System::Reflection::ParameterInfo*>)>(&Nitro::Types::SetToString)> {
  static const MethodInfo* get() {
    static auto* set = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("System.Reflection", "ParameterInfo"), 1)->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::Types*), "SetToString", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{set});
  }
};
// Writing MetadataGetter for method: Nitro::Types::SetToTypes
// Il2CppName: SetToTypes
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::ArrayW<::System::Type*> (*)(::ArrayW<::System::Reflection::ParameterInfo*>)>(&Nitro::Types::SetToTypes)> {
  static const MethodInfo* get() {
    static auto* set = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("System.Reflection", "ParameterInfo"), 1)->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::Types*), "SetToTypes", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{set});
  }
};
// Writing MetadataGetter for method: Nitro::Types::IsParams
// Il2CppName: IsParams
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)(::System::Reflection::ParameterInfo*)>(&Nitro::Types::IsParams)> {
  static const MethodInfo* get() {
    static auto* param = &::il2cpp_utils::GetClassFromName("System.Reflection", "ParameterInfo")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::Types*), "IsParams", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{param});
  }
};
// Writing MetadataGetter for method: Nitro::Types::IsDynamic
// Il2CppName: IsDynamic
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)(::System::Reflection::MemberInfo*)>(&Nitro::Types::IsDynamic)> {
  static const MethodInfo* get() {
    static auto* member = &::il2cpp_utils::GetClassFromName("System.Reflection", "MemberInfo")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::Types*), "IsDynamic", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{member});
  }
};
// Writing MetadataGetter for method: Nitro::Types::WillAccept
// Il2CppName: WillAccept
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (*)(::ArrayW<::System::Type*>, ::ArrayW<::System::Reflection::ParameterInfo*>, bool)>(&Nitro::Types::WillAccept)> {
  static const MethodInfo* get() {
    static auto* args = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("System", "Type"), 1)->byval_arg;
    static auto* parameters = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("System.Reflection", "ParameterInfo"), 1)->byval_arg;
    static auto* withCasting = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::Types*), "WillAccept", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{args, parameters, withCasting});
  }
};
// Writing MetadataGetter for method: Nitro::Types::NoReturn
// Il2CppName: NoReturn
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)(::System::Reflection::MethodInfo*)>(&Nitro::Types::NoReturn)> {
  static const MethodInfo* get() {
    static auto* methodInfo = &::il2cpp_utils::GetClassFromName("System.Reflection", "MethodInfo")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::Types*), "NoReturn", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{methodInfo});
  }
};
// Writing MetadataGetter for method: Nitro::Types::IsVoid
// Il2CppName: IsVoid
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)(::System::Type*)>(&Nitro::Types::IsVoid)> {
  static const MethodInfo* get() {
    static auto* T = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::Types*), "IsVoid", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{T});
  }
};
// Writing MetadataGetter for method: Nitro::Types::OutputParameters
// Il2CppName: OutputParameters
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(::ArrayW<::Nitro::CompiledFragment*>, ::Nitro::CompiledMethod*, ::Nitro::NitroIL*, ::ArrayW<::System::Reflection::ParameterInfo*>)>(&Nitro::Types::OutputParameters)> {
  static const MethodInfo* get() {
    static auto* args = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("Nitro", "CompiledFragment"), 1)->byval_arg;
    static auto* method = &::il2cpp_utils::GetClassFromName("Nitro", "CompiledMethod")->byval_arg;
    static auto* into = &::il2cpp_utils::GetClassFromName("Nitro", "NitroIL")->byval_arg;
    static auto* parameters = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("System.Reflection", "ParameterInfo"), 1)->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::Types*), "OutputParameters", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{args, method, into, parameters});
  }
};
// Writing MetadataGetter for method: Nitro::Types::MethodReturnType
// Il2CppName: MethodReturnType
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Type* (*)(::System::Type*, ::StringW)>(&Nitro::Types::MethodReturnType)> {
  static const MethodInfo* get() {
    static auto* type = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* name = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::Types*), "MethodReturnType", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{type, name});
  }
};
// Writing MetadataGetter for method: Nitro::Types::GetOverload
// Il2CppName: GetOverload
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Reflection::MethodInfo* (*)(::System::Collections::Generic::List_1<::System::Reflection::MethodInfo*>*, ::ArrayW<::System::Type*>)>(&Nitro::Types::GetOverload)> {
  static const MethodInfo* get() {
    static auto* overloads = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System.Reflection", "MethodInfo")})->byval_arg;
    static auto* argSet = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("System", "Type"), 1)->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::Types*), "GetOverload", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{overloads, argSet});
  }
};
// Writing MetadataGetter for method: Nitro::Types::GetOverload
// Il2CppName: GetOverload
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Reflection::MethodInfo* (*)(::System::Collections::Generic::List_1<::System::Reflection::MethodInfo*>*, ::ArrayW<::System::Type*>, bool)>(&Nitro::Types::GetOverload)> {
  static const MethodInfo* get() {
    static auto* overloads = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System.Reflection", "MethodInfo")})->byval_arg;
    static auto* argSet = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("System", "Type"), 1)->byval_arg;
    static auto* cast = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::Types*), "GetOverload", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{overloads, argSet, cast});
  }
};
// Writing MetadataGetter for method: Nitro::Types::GetOverload
// Il2CppName: GetOverload
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Reflection::MethodInfo* (*)(::ArrayW<::System::Reflection::MethodInfo*>, ::StringW, ::ArrayW<::System::Type*>)>(&Nitro::Types::GetOverload)> {
  static const MethodInfo* get() {
    static auto* overloads = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("System.Reflection", "MethodInfo"), 1)->byval_arg;
    static auto* name = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* argSet = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("System", "Type"), 1)->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::Types*), "GetOverload", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{overloads, name, argSet});
  }
};
// Writing MetadataGetter for method: Nitro::Types::GetOverload
// Il2CppName: GetOverload
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Reflection::MethodInfo* (*)(::ArrayW<::System::Reflection::MethodInfo*>, ::StringW, ::ArrayW<::System::Type*>, bool)>(&Nitro::Types::GetOverload)> {
  static const MethodInfo* get() {
    static auto* overloads = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("System.Reflection", "MethodInfo"), 1)->byval_arg;
    static auto* name = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* argSet = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("System", "Type"), 1)->byval_arg;
    static auto* ignoreCase = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::Types*), "GetOverload", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{overloads, name, argSet, ignoreCase});
  }
};
// Writing MetadataGetter for method: Nitro::Types::GetOverload
// Il2CppName: GetOverload
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Reflection::MethodInfo* (*)(::ArrayW<::System::Reflection::MethodInfo*>, ::StringW, ::ArrayW<::System::Type*>, bool, bool)>(&Nitro::Types::GetOverload)> {
  static const MethodInfo* get() {
    static auto* overloads = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("System.Reflection", "MethodInfo"), 1)->byval_arg;
    static auto* name = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* argSet = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("System", "Type"), 1)->byval_arg;
    static auto* ignoreCase = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* cast = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::Types*), "GetOverload", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{overloads, name, argSet, ignoreCase, cast});
  }
};
// Writing MetadataGetter for method: Nitro::Types::TypeSetsMatch
// Il2CppName: TypeSetsMatch
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)(::ArrayW<::System::Type*>, ::ArrayW<::System::Type*>)>(&Nitro::Types::TypeSetsMatch)> {
  static const MethodInfo* get() {
    static auto* a = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("System", "Type"), 1)->byval_arg;
    static auto* b = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("System", "Type"), 1)->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::Types*), "TypeSetsMatch", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{a, b});
  }
};
// Writing MetadataGetter for method: Nitro::Types::TypeSetsMatchExactly
// Il2CppName: TypeSetsMatchExactly
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)(::ArrayW<::System::Type*>, ::ArrayW<::System::Type*>)>(&Nitro::Types::TypeSetsMatchExactly)> {
  static const MethodInfo* get() {
    static auto* a = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("System", "Type"), 1)->byval_arg;
    static auto* b = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("System", "Type"), 1)->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::Types*), "TypeSetsMatchExactly", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{a, b});
  }
};
// Writing MetadataGetter for method: Nitro::Types::ToStringMethod
// Il2CppName: ToStringMethod
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Nitro::MethodOperation* (*)(::Nitro::CompiledMethod*, ::Nitro::CompiledFragment*, ::System::Type*)>(&Nitro::Types::ToStringMethod)> {
  static const MethodInfo* get() {
    static auto* method = &::il2cpp_utils::GetClassFromName("Nitro", "CompiledMethod")->byval_arg;
    static auto* frag = &::il2cpp_utils::GetClassFromName("Nitro", "CompiledFragment")->byval_arg;
    static auto* type = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::Types*), "ToStringMethod", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{method, frag, type});
  }
};
// Writing MetadataGetter for method: Nitro::Types::TryCast
// Il2CppName: TryCast
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Nitro::CompiledFragment* (*)(::Nitro::CompiledMethod*, ::Nitro::CompiledFragment*, ::System::Type*, ::System::Type*)>(&Nitro::Types::TryCast)> {
  static const MethodInfo* get() {
    static auto* method = &::il2cpp_utils::GetClassFromName("Nitro", "CompiledMethod")->byval_arg;
    static auto* frag = &::il2cpp_utils::GetClassFromName("Nitro", "CompiledFragment")->byval_arg;
    static auto* to = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* from = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::Types*), "TryCast", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{method, frag, to, from});
  }
};
// Writing MetadataGetter for method: Nitro::Types::TryCast
// Il2CppName: TryCast
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Nitro::CompiledFragment* (*)(::Nitro::CompiledMethod*, ::Nitro::CompiledFragment*, ::System::Type*, ::System::Type*, ByRef<bool>)>(&Nitro::Types::TryCast)> {
  static const MethodInfo* get() {
    static auto* method = &::il2cpp_utils::GetClassFromName("Nitro", "CompiledMethod")->byval_arg;
    static auto* frag = &::il2cpp_utils::GetClassFromName("Nitro", "CompiledFragment")->byval_arg;
    static auto* to = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* from = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* isExplicit = &::il2cpp_utils::GetClassFromName("System", "Boolean")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::Types*), "TryCast", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{method, frag, to, from, isExplicit});
  }
};
// Writing MetadataGetter for method: Nitro::Types::NameWithoutNamespace
// Il2CppName: NameWithoutNamespace
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::StringW (*)(::StringW)>(&Nitro::Types::NameWithoutNamespace)> {
  static const MethodInfo* get() {
    static auto* typeName = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::Types*), "NameWithoutNamespace", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{typeName});
  }
};
// Writing MetadataGetter for method: Nitro::Types::IsCastableTo
// Il2CppName: IsCastableTo
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Reflection::MethodInfo* (*)(::System::Type*, ::System::Type*, ByRef<bool>)>(&Nitro::Types::IsCastableTo)> {
  static const MethodInfo* get() {
    static auto* from = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* to = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* isExplicit = &::il2cpp_utils::GetClassFromName("System", "Boolean")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::Types*), "IsCastableTo", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{from, to, isExplicit});
  }
};
// Writing MetadataGetter for method: Nitro::Types::GetTypes
// Il2CppName: GetTypes
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::ArrayW<::System::Type*> (*)(::System::Type*, ::ArrayW<::Nitro::CompiledFragment*>)>(&Nitro::Types::GetTypes)> {
  static const MethodInfo* get() {
    static auto* first = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* frags = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("Nitro", "CompiledFragment"), 1)->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::Types*), "GetTypes", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{first, frags});
  }
};
// Writing MetadataGetter for method: Nitro::Types::GetTypes
// Il2CppName: GetTypes
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::ArrayW<::System::Type*> (*)(::ArrayW<::Nitro::CompiledFragment*>)>(&Nitro::Types::GetTypes)> {
  static const MethodInfo* get() {
    static auto* frags = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("Nitro", "CompiledFragment"), 1)->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::Types*), "GetTypes", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{frags});
  }
};
// Writing MetadataGetter for method: Nitro::Types::IsSubclass
// Il2CppName: IsSubclass
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)(::Il2CppObject*, ::System::Type*)>(&Nitro::Types::IsSubclass)> {
  static const MethodInfo* get() {
    static auto* obj = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    static auto* super = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::Types*), "IsSubclass", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{obj, super});
  }
};
// Writing MetadataGetter for method: Nitro::Types::IsTypeOf
// Il2CppName: IsTypeOf
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)(::Il2CppObject*, ::System::Type*)>(&Nitro::Types::IsTypeOf)> {
  static const MethodInfo* get() {
    static auto* obj = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    static auto* super = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::Types*), "IsTypeOf", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{obj, super});
  }
};
// Writing MetadataGetter for method: Nitro::Types::IsCompiled
// Il2CppName: IsCompiled
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)(::Nitro::CodeFragment*)>(&Nitro::Types::IsCompiled)> {
  static const MethodInfo* get() {
    static auto* obj = &::il2cpp_utils::GetClassFromName("Nitro", "CodeFragment")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::Types*), "IsCompiled", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{obj});
  }
};
