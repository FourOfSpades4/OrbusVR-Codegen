// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-string.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: System
namespace System {
  // Forward declaring type: Type
  class Type;
}
// Forward declaring namespace: System::Reflection::Emit
namespace System::Reflection::Emit {
  // Forward declaring type: ModuleBuilder
  class ModuleBuilder;
}
// Forward declaring namespace: Nitro
namespace Nitro {
  // Forward declaring type: CompiledClass
  class CompiledClass;
  // Forward declaring type: CodeReference
  class CodeReference;
  // Forward declaring type: NitroDomainManager
  class NitroDomainManager;
  // Forward declaring type: AotFileEvent
  class AotFileEvent;
  // Forward declaring type: CodeFragment
  class CodeFragment;
}
// Forward declaring namespace: System::Collections::Generic
namespace System::Collections::Generic {
  // Forward declaring type: List`1<T>
  template<typename T>
  class List_1;
  // Forward declaring type: Dictionary`2<TKey, TValue>
  template<typename TKey, typename TValue>
  class Dictionary_2;
}
// Completed forward declares
// Type namespace: Nitro
namespace Nitro {
  // Forward declaring type: NitroCode
  class NitroCode;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::Nitro::NitroCode);
DEFINE_IL2CPP_ARG_TYPE(::Nitro::NitroCode*, "Nitro", "NitroCode");
// Type namespace: Nitro
namespace Nitro {
  // Size: 0x48
  #pragma pack(push, 1)
  // Autogenerated type: Nitro.NitroCode
  // [TokenAttribute] Offset: FFFFFFFF
  class NitroCode : public ::Il2CppObject {
    public:
    public:
    // public System.String Code
    // Size: 0x8
    // Offset: 0x10
    ::StringW Code;
    // Field size check
    static_assert(sizeof(::StringW) == 0x8);
    // private System.Type CompiledType
    // Size: 0x8
    // Offset: 0x18
    ::System::Type* CompiledType;
    // Field size check
    static_assert(sizeof(::System::Type*) == 0x8);
    // public System.Reflection.Emit.ModuleBuilder Builder
    // Size: 0x8
    // Offset: 0x20
    ::System::Reflection::Emit::ModuleBuilder* Builder;
    // Field size check
    static_assert(sizeof(::System::Reflection::Emit::ModuleBuilder*) == 0x8);
    // private Nitro.CompiledClass BaseClass
    // Size: 0x8
    // Offset: 0x28
    ::Nitro::CompiledClass* BaseClass;
    // Field size check
    static_assert(sizeof(::Nitro::CompiledClass*) == 0x8);
    // private System.Collections.Generic.List`1<Nitro.CodeReference> References
    // Size: 0x8
    // Offset: 0x30
    ::System::Collections::Generic::List_1<::Nitro::CodeReference*>* References;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::List_1<::Nitro::CodeReference*>*) == 0x8);
    // private Nitro.NitroDomainManager ScriptDomainManager
    // Size: 0x8
    // Offset: 0x38
    ::Nitro::NitroDomainManager* ScriptDomainManager;
    // Field size check
    static_assert(sizeof(::Nitro::NitroDomainManager*) == 0x8);
    // private System.Collections.Generic.Dictionary`2<System.String,Nitro.CompiledClass> Types
    // Size: 0x8
    // Offset: 0x40
    ::System::Collections::Generic::Dictionary_2<::StringW, ::Nitro::CompiledClass*>* Types;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::Dictionary_2<::StringW, ::Nitro::CompiledClass*>*) == 0x8);
    public:
    // Get static field: static public System.Boolean AotMode
    static bool _get_AotMode();
    // Set static field: static public System.Boolean AotMode
    static void _set_AotMode(bool value);
    // Get static field: static private System.Boolean Started
    static bool _get_Started();
    // Set static field: static private System.Boolean Started
    static void _set_Started(bool value);
    // Get static field: static public System.Int32 ModuleCounter
    static int _get_ModuleCounter();
    // Set static field: static public System.Int32 ModuleCounter
    static void _set_ModuleCounter(int value);
    // Get static field: static public Nitro.AotFileEvent OnAotFileExists
    static ::Nitro::AotFileEvent* _get_OnAotFileExists();
    // Set static field: static public Nitro.AotFileEvent OnAotFileExists
    static void _set_OnAotFileExists(::Nitro::AotFileEvent* value);
    // Get instance field reference: public System.String Code
    [[deprecated("Use field access instead!")]] ::StringW& dyn_Code();
    // Get instance field reference: private System.Type CompiledType
    [[deprecated("Use field access instead!")]] ::System::Type*& dyn_CompiledType();
    // Get instance field reference: public System.Reflection.Emit.ModuleBuilder Builder
    [[deprecated("Use field access instead!")]] ::System::Reflection::Emit::ModuleBuilder*& dyn_Builder();
    // Get instance field reference: private Nitro.CompiledClass BaseClass
    [[deprecated("Use field access instead!")]] ::Nitro::CompiledClass*& dyn_BaseClass();
    // Get instance field reference: private System.Collections.Generic.List`1<Nitro.CodeReference> References
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::List_1<::Nitro::CodeReference*>*& dyn_References();
    // Get instance field reference: private Nitro.NitroDomainManager ScriptDomainManager
    [[deprecated("Use field access instead!")]] ::Nitro::NitroDomainManager*& dyn_ScriptDomainManager();
    // Get instance field reference: private System.Collections.Generic.Dictionary`2<System.String,Nitro.CompiledClass> Types
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::Dictionary_2<::StringW, ::Nitro::CompiledClass*>*& dyn_Types();
    // static public System.Void Setup()
    // Offset: 0xF65E94
    static void Setup();
    // public System.Void .ctor()
    // Offset: 0xF66128
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static NitroCode* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::Nitro::NitroCode::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<NitroCode*, creationType>()));
    }
    // public System.Void .ctor(System.String code)
    // Offset: 0xF6625C
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static NitroCode* New_ctor(::StringW code) {
      static auto ___internal__logger = ::Logger::get().WithContext("::Nitro::NitroCode::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<NitroCode*, creationType>(code)));
    }
    // public System.Void .ctor(System.String code, System.Type baseType)
    // Offset: 0xF66270
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static NitroCode* New_ctor(::StringW code, ::System::Type* baseType) {
      static auto ___internal__logger = ::Logger::get().WithContext("::Nitro::NitroCode::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<NitroCode*, creationType>(code, baseType)));
    }
    // public System.Void .ctor(Nitro.NitroDomainManager manager)
    // Offset: 0xF66280
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static NitroCode* New_ctor(::Nitro::NitroDomainManager* manager) {
      static auto ___internal__logger = ::Logger::get().WithContext("::Nitro::NitroCode::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<NitroCode*, creationType>(manager)));
    }
    // public System.Void .ctor(System.String code, Nitro.NitroDomainManager manager)
    // Offset: 0xF6629C
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static NitroCode* New_ctor(::StringW code, ::Nitro::NitroDomainManager* manager) {
      static auto ___internal__logger = ::Logger::get().WithContext("::Nitro::NitroCode::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<NitroCode*, creationType>(code, manager)));
    }
    // public System.Void .ctor(System.String code, System.Type baseType, Nitro.NitroDomainManager manager)
    // Offset: 0xF662B4
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static NitroCode* New_ctor(::StringW code, ::System::Type* baseType, ::Nitro::NitroDomainManager* manager) {
      static auto ___internal__logger = ::Logger::get().WithContext("::Nitro::NitroCode::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<NitroCode*, creationType>(code, baseType, manager)));
    }
    // public System.Void .ctor(System.String code, System.Type baseType, Nitro.NitroDomainManager manager, System.String aotFile, System.String aotAssemblyName)
    // Offset: 0xF66140
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static NitroCode* New_ctor(::StringW code, ::System::Type* baseType, ::Nitro::NitroDomainManager* manager, ::StringW aotFile, ::StringW aotAssemblyName) {
      static auto ___internal__logger = ::Logger::get().WithContext("::Nitro::NitroCode::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<NitroCode*, creationType>(code, baseType, manager, aotFile, aotAssemblyName)));
    }
    // public System.Void Compile(System.String code, System.Type baseType)
    // Offset: 0xF66A2C
    void Compile(::StringW code, ::System::Type* baseType);
    // public System.Void Compile(System.String code, System.Type baseType, System.String aotFile, System.String aotAssemblyName)
    // Offset: 0xF664B8
    void Compile(::StringW code, ::System::Type* baseType, ::StringW aotFile, ::StringW aotAssemblyName);
    // public System.Void AddReference(Nitro.CodeFragment usingName)
    // Offset: 0xF63B60
    void AddReference(::Nitro::CodeFragment* usingName);
    // private System.String ParseReference(Nitro.CodeFragment usingName)
    // Offset: 0xF67030
    ::StringW ParseReference(::Nitro::CodeFragment* usingName);
    // private System.Void FindClasses(Nitro.CodeFragment frag)
    // Offset: 0xF66A38
    void FindClasses(::Nitro::CodeFragment* frag);
    // public System.Boolean AllowUse(System.Type ofType)
    // Offset: 0xF67300
    bool AllowUse(::System::Type* ofType);
    // public System.Boolean ContainsMethod(System.String name)
    // Offset: 0xF6757C
    bool ContainsMethod(::StringW name);
    // public System.Boolean ContainsField(System.String field)
    // Offset: 0xF67674
    bool ContainsField(::StringW field);
    // public System.Type GetType(System.String name)
    // Offset: 0xF67764
    ::System::Type* GetType(::StringW name);
    // public System.Collections.Generic.List`1<System.Type> GetTypes(System.String name)
    // Offset: 0xF67BC4
    ::System::Collections::Generic::List_1<::System::Type*>* GetTypes(::StringW name);
    // public Nitro.CompiledClass GetClass(System.Type type)
    // Offset: 0xF68120
    ::Nitro::CompiledClass* GetClass(::System::Type* type);
    // public Nitro.CompiledClass get_MainClass()
    // Offset: 0xF6820C
    ::Nitro::CompiledClass* get_MainClass();
    // public Nitro.CompiledClass GetClass(System.String name)
    // Offset: 0xF68164
    ::Nitro::CompiledClass* GetClass(::StringW name);
    // public System.Object Instance()
    // Offset: 0xF68214
    ::Il2CppObject* Instance();
    // public System.Type get_OutputType()
    // Offset: 0xF682A4
    ::System::Type* get_OutputType();
    // static private System.Void .cctor()
    // Offset: 0xF682AC
    static void _cctor();
  }; // Nitro.NitroCode
  #pragma pack(pop)
  static check_size<sizeof(NitroCode), 64 + sizeof(::System::Collections::Generic::Dictionary_2<::StringW, ::Nitro::CompiledClass*>*)> __Nitro_NitroCodeSizeCheck;
  static_assert(sizeof(NitroCode) == 0x48);
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: Nitro::NitroCode::Setup
// Il2CppName: Setup
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)()>(&Nitro::NitroCode::Setup)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Nitro::NitroCode*), "Setup", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Nitro::NitroCode::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: Nitro::NitroCode::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: Nitro::NitroCode::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: Nitro::NitroCode::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: Nitro::NitroCode::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: Nitro::NitroCode::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: Nitro::NitroCode::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: Nitro::NitroCode::Compile
// Il2CppName: Compile
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Nitro::NitroCode::*)(::StringW, ::System::Type*)>(&Nitro::NitroCode::Compile)> {
  static const MethodInfo* get() {
    static auto* code = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* baseType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::NitroCode*), "Compile", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{code, baseType});
  }
};
// Writing MetadataGetter for method: Nitro::NitroCode::Compile
// Il2CppName: Compile
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Nitro::NitroCode::*)(::StringW, ::System::Type*, ::StringW, ::StringW)>(&Nitro::NitroCode::Compile)> {
  static const MethodInfo* get() {
    static auto* code = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* baseType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* aotFile = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* aotAssemblyName = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::NitroCode*), "Compile", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{code, baseType, aotFile, aotAssemblyName});
  }
};
// Writing MetadataGetter for method: Nitro::NitroCode::AddReference
// Il2CppName: AddReference
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Nitro::NitroCode::*)(::Nitro::CodeFragment*)>(&Nitro::NitroCode::AddReference)> {
  static const MethodInfo* get() {
    static auto* usingName = &::il2cpp_utils::GetClassFromName("Nitro", "CodeFragment")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::NitroCode*), "AddReference", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{usingName});
  }
};
// Writing MetadataGetter for method: Nitro::NitroCode::ParseReference
// Il2CppName: ParseReference
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::StringW (Nitro::NitroCode::*)(::Nitro::CodeFragment*)>(&Nitro::NitroCode::ParseReference)> {
  static const MethodInfo* get() {
    static auto* usingName = &::il2cpp_utils::GetClassFromName("Nitro", "CodeFragment")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::NitroCode*), "ParseReference", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{usingName});
  }
};
// Writing MetadataGetter for method: Nitro::NitroCode::FindClasses
// Il2CppName: FindClasses
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Nitro::NitroCode::*)(::Nitro::CodeFragment*)>(&Nitro::NitroCode::FindClasses)> {
  static const MethodInfo* get() {
    static auto* frag = &::il2cpp_utils::GetClassFromName("Nitro", "CodeFragment")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::NitroCode*), "FindClasses", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{frag});
  }
};
// Writing MetadataGetter for method: Nitro::NitroCode::AllowUse
// Il2CppName: AllowUse
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Nitro::NitroCode::*)(::System::Type*)>(&Nitro::NitroCode::AllowUse)> {
  static const MethodInfo* get() {
    static auto* ofType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::NitroCode*), "AllowUse", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{ofType});
  }
};
// Writing MetadataGetter for method: Nitro::NitroCode::ContainsMethod
// Il2CppName: ContainsMethod
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Nitro::NitroCode::*)(::StringW)>(&Nitro::NitroCode::ContainsMethod)> {
  static const MethodInfo* get() {
    static auto* name = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::NitroCode*), "ContainsMethod", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{name});
  }
};
// Writing MetadataGetter for method: Nitro::NitroCode::ContainsField
// Il2CppName: ContainsField
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Nitro::NitroCode::*)(::StringW)>(&Nitro::NitroCode::ContainsField)> {
  static const MethodInfo* get() {
    static auto* field = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::NitroCode*), "ContainsField", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{field});
  }
};
// Writing MetadataGetter for method: Nitro::NitroCode::GetType
// Il2CppName: GetType
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Type* (Nitro::NitroCode::*)(::StringW)>(&Nitro::NitroCode::GetType)> {
  static const MethodInfo* get() {
    static auto* name = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::NitroCode*), "GetType", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{name});
  }
};
// Writing MetadataGetter for method: Nitro::NitroCode::GetTypes
// Il2CppName: GetTypes
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Collections::Generic::List_1<::System::Type*>* (Nitro::NitroCode::*)(::StringW)>(&Nitro::NitroCode::GetTypes)> {
  static const MethodInfo* get() {
    static auto* name = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::NitroCode*), "GetTypes", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{name});
  }
};
// Writing MetadataGetter for method: Nitro::NitroCode::GetClass
// Il2CppName: GetClass
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Nitro::CompiledClass* (Nitro::NitroCode::*)(::System::Type*)>(&Nitro::NitroCode::GetClass)> {
  static const MethodInfo* get() {
    static auto* type = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::NitroCode*), "GetClass", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{type});
  }
};
// Writing MetadataGetter for method: Nitro::NitroCode::get_MainClass
// Il2CppName: get_MainClass
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Nitro::CompiledClass* (Nitro::NitroCode::*)()>(&Nitro::NitroCode::get_MainClass)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Nitro::NitroCode*), "get_MainClass", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Nitro::NitroCode::GetClass
// Il2CppName: GetClass
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Nitro::CompiledClass* (Nitro::NitroCode::*)(::StringW)>(&Nitro::NitroCode::GetClass)> {
  static const MethodInfo* get() {
    static auto* name = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::NitroCode*), "GetClass", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{name});
  }
};
// Writing MetadataGetter for method: Nitro::NitroCode::Instance
// Il2CppName: Instance
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Nitro::NitroCode::*)()>(&Nitro::NitroCode::Instance)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Nitro::NitroCode*), "Instance", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Nitro::NitroCode::get_OutputType
// Il2CppName: get_OutputType
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Type* (Nitro::NitroCode::*)()>(&Nitro::NitroCode::get_OutputType)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Nitro::NitroCode*), "get_OutputType", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Nitro::NitroCode::_cctor
// Il2CppName: .cctor
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)()>(&Nitro::NitroCode::_cctor)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Nitro::NitroCode*), ".cctor", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
