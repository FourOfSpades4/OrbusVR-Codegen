// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: System.Reflection.Emit.Label
#include "System/Reflection/Emit/Label.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
#include "beatsaber-hook/shared/utils/typedefs-string.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: Nitro
namespace Nitro {
  // Forward declaring type: NitroCode
  class NitroCode;
  // Forward declaring type: NitroIL
  class NitroIL;
  // Forward declaring type: CompiledClass
  class CompiledClass;
  // Forward declaring type: BracketFragment
  class BracketFragment;
  // Forward declaring type: CompiledFragment
  class CompiledFragment;
  // Forward declaring type: BreakPoint
  class BreakPoint;
  // Forward declaring type: LocalVariable
  class LocalVariable;
  // Forward declaring type: ParameterVariable
  class ParameterVariable;
  // Forward declaring type: TypeFragment
  class TypeFragment;
  // Forward declaring type: Variable
  class Variable;
  // Forward declaring type: VariableType
  struct VariableType;
}
// Forward declaring namespace: System::Reflection::Emit
namespace System::Reflection::Emit {
  // Forward declaring type: MethodBuilder
  class MethodBuilder;
  // Forward declaring type: LocalBuilder
  class LocalBuilder;
}
// Forward declaring namespace: System
namespace System {
  // Forward declaring type: Type
  class Type;
}
// Forward declaring namespace: System::Collections::Generic
namespace System::Collections::Generic {
  // Forward declaring type: List`1<T>
  template<typename T>
  class List_1;
  // Forward declaring type: Dictionary`2<TKey, TValue>
  template<typename TKey, typename TValue>
  class Dictionary_2;
}
// Forward declaring namespace: System::Reflection
namespace System::Reflection {
  // Forward declaring type: MethodInfo
  class MethodInfo;
}
// Completed forward declares
// Type namespace: Nitro
namespace Nitro {
  // Forward declaring type: CompiledMethod
  class CompiledMethod;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::Nitro::CompiledMethod);
DEFINE_IL2CPP_ARG_TYPE(::Nitro::CompiledMethod*, "Nitro", "CompiledMethod");
// Type namespace: Nitro
namespace Nitro {
  // Size: 0x90
  #pragma pack(push, 1)
  // Autogenerated type: Nitro.CompiledMethod
  // [TokenAttribute] Offset: FFFFFFFF
  class CompiledMethod : public ::Il2CppObject {
    public:
    public:
    // public System.String Name
    // Size: 0x8
    // Offset: 0x10
    ::StringW Name;
    // Field size check
    static_assert(sizeof(::StringW) == 0x8);
    // public System.Int32 CurrentLine
    // Size: 0x4
    // Offset: 0x18
    int CurrentLine;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // Padding between fields: CurrentLine and: Script
    char __padding1[0x4] = {};
    // public Nitro.NitroCode Script
    // Size: 0x8
    // Offset: 0x20
    ::Nitro::NitroCode* Script;
    // Field size check
    static_assert(sizeof(::Nitro::NitroCode*) == 0x8);
    // public Nitro.NitroIL ILStream
    // Size: 0x8
    // Offset: 0x28
    ::Nitro::NitroIL* ILStream;
    // Field size check
    static_assert(sizeof(::Nitro::NitroIL*) == 0x8);
    // public System.Reflection.Emit.Label EndOfMethod
    // Size: 0x4
    // Offset: 0x30
    ::System::Reflection::Emit::Label EndOfMethod;
    // Field size check
    static_assert(sizeof(::System::Reflection::Emit::Label) == 0x4);
    // public System.Boolean GloballyScoped
    // Size: 0x1
    // Offset: 0x34
    bool GloballyScoped;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: GloballyScoped and: Parent
    char __padding5[0x3] = {};
    // public Nitro.CompiledClass Parent
    // Size: 0x8
    // Offset: 0x38
    ::Nitro::CompiledClass* Parent;
    // Field size check
    static_assert(sizeof(::Nitro::CompiledClass*) == 0x8);
    // public System.Boolean ParametersLoaded
    // Size: 0x1
    // Offset: 0x40
    bool ParametersLoaded;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: ParametersLoaded and: Builder
    char __padding7[0x7] = {};
    // public System.Reflection.Emit.MethodBuilder Builder
    // Size: 0x8
    // Offset: 0x48
    ::System::Reflection::Emit::MethodBuilder* Builder;
    // Field size check
    static_assert(sizeof(::System::Reflection::Emit::MethodBuilder*) == 0x8);
    // public System.Type[] ParameterTypes
    // Size: 0x8
    // Offset: 0x50
    ::ArrayW<::System::Type*> ParameterTypes;
    // Field size check
    static_assert(sizeof(::ArrayW<::System::Type*>) == 0x8);
    // public System.Reflection.Emit.LocalBuilder ReturnBay
    // Size: 0x8
    // Offset: 0x58
    ::System::Reflection::Emit::LocalBuilder* ReturnBay;
    // Field size check
    static_assert(sizeof(::System::Reflection::Emit::LocalBuilder*) == 0x8);
    // public Nitro.BracketFragment CodeBlock
    // Size: 0x8
    // Offset: 0x60
    ::Nitro::BracketFragment* CodeBlock;
    // Field size check
    static_assert(sizeof(::Nitro::BracketFragment*) == 0x8);
    // public Nitro.BracketFragment ParameterBlock
    // Size: 0x8
    // Offset: 0x68
    ::Nitro::BracketFragment* ParameterBlock;
    // Field size check
    static_assert(sizeof(::Nitro::BracketFragment*) == 0x8);
    // public Nitro.CompiledFragment[] DefaultParameterValues
    // Size: 0x8
    // Offset: 0x70
    ::ArrayW<::Nitro::CompiledFragment*> DefaultParameterValues;
    // Field size check
    static_assert(sizeof(::ArrayW<::Nitro::CompiledFragment*>) == 0x8);
    // public System.Collections.Generic.List`1<Nitro.BreakPoint> BreakPoints
    // Size: 0x8
    // Offset: 0x78
    ::System::Collections::Generic::List_1<::Nitro::BreakPoint*>* BreakPoints;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::List_1<::Nitro::BreakPoint*>*) == 0x8);
    // public System.Collections.Generic.Dictionary`2<System.String,Nitro.LocalVariable> LocalSet
    // Size: 0x8
    // Offset: 0x80
    ::System::Collections::Generic::Dictionary_2<::StringW, ::Nitro::LocalVariable*>* LocalSet;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::Dictionary_2<::StringW, ::Nitro::LocalVariable*>*) == 0x8);
    // public System.Collections.Generic.Dictionary`2<System.String,Nitro.ParameterVariable> ParameterSet
    // Size: 0x8
    // Offset: 0x88
    ::System::Collections::Generic::Dictionary_2<::StringW, ::Nitro::ParameterVariable*>* ParameterSet;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::Dictionary_2<::StringW, ::Nitro::ParameterVariable*>*) == 0x8);
    public:
    // Get instance field reference: public System.String Name
    [[deprecated("Use field access instead!")]] ::StringW& dyn_Name();
    // Get instance field reference: public System.Int32 CurrentLine
    [[deprecated("Use field access instead!")]] int& dyn_CurrentLine();
    // Get instance field reference: public Nitro.NitroCode Script
    [[deprecated("Use field access instead!")]] ::Nitro::NitroCode*& dyn_Script();
    // Get instance field reference: public Nitro.NitroIL ILStream
    [[deprecated("Use field access instead!")]] ::Nitro::NitroIL*& dyn_ILStream();
    // Get instance field reference: public System.Reflection.Emit.Label EndOfMethod
    [[deprecated("Use field access instead!")]] ::System::Reflection::Emit::Label& dyn_EndOfMethod();
    // Get instance field reference: public System.Boolean GloballyScoped
    [[deprecated("Use field access instead!")]] bool& dyn_GloballyScoped();
    // Get instance field reference: public Nitro.CompiledClass Parent
    [[deprecated("Use field access instead!")]] ::Nitro::CompiledClass*& dyn_Parent();
    // Get instance field reference: public System.Boolean ParametersLoaded
    [[deprecated("Use field access instead!")]] bool& dyn_ParametersLoaded();
    // Get instance field reference: public System.Reflection.Emit.MethodBuilder Builder
    [[deprecated("Use field access instead!")]] ::System::Reflection::Emit::MethodBuilder*& dyn_Builder();
    // Get instance field reference: public System.Type[] ParameterTypes
    [[deprecated("Use field access instead!")]] ::ArrayW<::System::Type*>& dyn_ParameterTypes();
    // Get instance field reference: public System.Reflection.Emit.LocalBuilder ReturnBay
    [[deprecated("Use field access instead!")]] ::System::Reflection::Emit::LocalBuilder*& dyn_ReturnBay();
    // Get instance field reference: public Nitro.BracketFragment CodeBlock
    [[deprecated("Use field access instead!")]] ::Nitro::BracketFragment*& dyn_CodeBlock();
    // Get instance field reference: public Nitro.BracketFragment ParameterBlock
    [[deprecated("Use field access instead!")]] ::Nitro::BracketFragment*& dyn_ParameterBlock();
    // Get instance field reference: public Nitro.CompiledFragment[] DefaultParameterValues
    [[deprecated("Use field access instead!")]] ::ArrayW<::Nitro::CompiledFragment*>& dyn_DefaultParameterValues();
    // Get instance field reference: public System.Collections.Generic.List`1<Nitro.BreakPoint> BreakPoints
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::List_1<::Nitro::BreakPoint*>*& dyn_BreakPoints();
    // Get instance field reference: public System.Collections.Generic.Dictionary`2<System.String,Nitro.LocalVariable> LocalSet
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::Dictionary_2<::StringW, ::Nitro::LocalVariable*>*& dyn_LocalSet();
    // Get instance field reference: public System.Collections.Generic.Dictionary`2<System.String,Nitro.ParameterVariable> ParameterSet
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::Dictionary_2<::StringW, ::Nitro::ParameterVariable*>*& dyn_ParameterSet();
    // public System.Void .ctor(System.String name)
    // Offset: 0xF5F01C
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static CompiledMethod* New_ctor(::StringW name) {
      static auto ___internal__logger = ::Logger::get().WithContext("::Nitro::CompiledMethod::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<CompiledMethod*, creationType>(name)));
    }
    // public System.Void .ctor(Nitro.CompiledClass parent, System.String name, Nitro.BracketFragment parameterBlock, Nitro.BracketFragment codeBlock, Nitro.TypeFragment retType, System.Boolean isPublic)
    // Offset: 0xF5D288
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static CompiledMethod* New_ctor(::Nitro::CompiledClass* parent, ::StringW name, ::Nitro::BracketFragment* parameterBlock, ::Nitro::BracketFragment* codeBlock, ::Nitro::TypeFragment* retType, bool isPublic) {
      static auto ___internal__logger = ::Logger::get().WithContext("::Nitro::CompiledMethod::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<CompiledMethod*, creationType>(parent, name, parameterBlock, codeBlock, retType, isPublic)));
    }
    // public System.Void AddBreakPoint(Nitro.BreakPoint bp)
    // Offset: 0xF5FE00
    void AddBreakPoint(::Nitro::BreakPoint* bp);
    // public System.Void PopBreakPoint()
    // Offset: 0xF5FE70
    void PopBreakPoint();
    // public System.Boolean Break(Nitro.NitroIL into, System.Int32 depth)
    // Offset: 0xF5929C
    bool Break(::Nitro::NitroIL* into, int depth);
    // public System.Boolean Continue(Nitro.NitroIL into, System.Int32 depth)
    // Offset: 0xF5FF10
    bool Continue(::Nitro::NitroIL* into, int depth);
    // public System.Void Done()
    // Offset: 0xF6000C
    void Done();
    // public System.Void Error(System.String message)
    // Offset: 0xF5F0F0
    void Error(::StringW message);
    // public System.Type ReturnType()
    // Offset: 0xF60098
    ::System::Type* ReturnType();
    // public System.Reflection.MethodInfo getMethodInfo()
    // Offset: 0xF600D0
    ::System::Reflection::MethodInfo* getMethodInfo();
    // public Nitro.ParameterVariable GetParameter(System.String variableName)
    // Offset: 0xF600D8
    ::Nitro::ParameterVariable* GetParameter(::StringW variableName);
    // public Nitro.LocalVariable GetLocal(System.String variableName)
    // Offset: 0xF60158
    ::Nitro::LocalVariable* GetLocal(::StringW variableName);
    // public Nitro.LocalVariable GetLocal(System.String variableName, System.Boolean create, System.Type createType)
    // Offset: 0xF60164
    ::Nitro::LocalVariable* GetLocal(::StringW variableName, bool create, ::System::Type* createType);
    // public Nitro.Variable GetVariable(System.String name)
    // Offset: 0xF6027C
    ::Nitro::Variable* GetVariable(::StringW name);
    // public Nitro.Variable GetVariable(System.String name, System.Boolean create, System.Type createType)
    // Offset: 0xF6028C
    ::Nitro::Variable* GetVariable(::StringW name, bool create, ::System::Type* createType);
    // public Nitro.Variable GetVariable(System.String name, Nitro.VariableType type, System.Boolean create, System.Type createType)
    // Offset: 0xF602A0
    ::Nitro::Variable* GetVariable(::StringW name, ::Nitro::VariableType type, bool create, ::System::Type* createType);
    // private System.Void ParametersOk()
    // Offset: 0xF60340
    void ParametersOk();
    // private System.Void ParseParameters()
    // Offset: 0xF5F15C
    void ParseParameters();
    // private System.Void ApplyParameters()
    // Offset: 0xF5FBA4
    void ApplyParameters();
  }; // Nitro.CompiledMethod
  #pragma pack(pop)
  static check_size<sizeof(CompiledMethod), 136 + sizeof(::System::Collections::Generic::Dictionary_2<::StringW, ::Nitro::ParameterVariable*>*)> __Nitro_CompiledMethodSizeCheck;
  static_assert(sizeof(CompiledMethod) == 0x90);
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: Nitro::CompiledMethod::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: Nitro::CompiledMethod::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: Nitro::CompiledMethod::AddBreakPoint
// Il2CppName: AddBreakPoint
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Nitro::CompiledMethod::*)(::Nitro::BreakPoint*)>(&Nitro::CompiledMethod::AddBreakPoint)> {
  static const MethodInfo* get() {
    static auto* bp = &::il2cpp_utils::GetClassFromName("Nitro", "BreakPoint")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::CompiledMethod*), "AddBreakPoint", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{bp});
  }
};
// Writing MetadataGetter for method: Nitro::CompiledMethod::PopBreakPoint
// Il2CppName: PopBreakPoint
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Nitro::CompiledMethod::*)()>(&Nitro::CompiledMethod::PopBreakPoint)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Nitro::CompiledMethod*), "PopBreakPoint", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Nitro::CompiledMethod::Break
// Il2CppName: Break
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Nitro::CompiledMethod::*)(::Nitro::NitroIL*, int)>(&Nitro::CompiledMethod::Break)> {
  static const MethodInfo* get() {
    static auto* into = &::il2cpp_utils::GetClassFromName("Nitro", "NitroIL")->byval_arg;
    static auto* depth = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::CompiledMethod*), "Break", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{into, depth});
  }
};
// Writing MetadataGetter for method: Nitro::CompiledMethod::Continue
// Il2CppName: Continue
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Nitro::CompiledMethod::*)(::Nitro::NitroIL*, int)>(&Nitro::CompiledMethod::Continue)> {
  static const MethodInfo* get() {
    static auto* into = &::il2cpp_utils::GetClassFromName("Nitro", "NitroIL")->byval_arg;
    static auto* depth = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::CompiledMethod*), "Continue", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{into, depth});
  }
};
// Writing MetadataGetter for method: Nitro::CompiledMethod::Done
// Il2CppName: Done
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Nitro::CompiledMethod::*)()>(&Nitro::CompiledMethod::Done)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Nitro::CompiledMethod*), "Done", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Nitro::CompiledMethod::Error
// Il2CppName: Error
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Nitro::CompiledMethod::*)(::StringW)>(&Nitro::CompiledMethod::Error)> {
  static const MethodInfo* get() {
    static auto* message = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::CompiledMethod*), "Error", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{message});
  }
};
// Writing MetadataGetter for method: Nitro::CompiledMethod::ReturnType
// Il2CppName: ReturnType
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Type* (Nitro::CompiledMethod::*)()>(&Nitro::CompiledMethod::ReturnType)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Nitro::CompiledMethod*), "ReturnType", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Nitro::CompiledMethod::getMethodInfo
// Il2CppName: getMethodInfo
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Reflection::MethodInfo* (Nitro::CompiledMethod::*)()>(&Nitro::CompiledMethod::getMethodInfo)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Nitro::CompiledMethod*), "getMethodInfo", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Nitro::CompiledMethod::GetParameter
// Il2CppName: GetParameter
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Nitro::ParameterVariable* (Nitro::CompiledMethod::*)(::StringW)>(&Nitro::CompiledMethod::GetParameter)> {
  static const MethodInfo* get() {
    static auto* variableName = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::CompiledMethod*), "GetParameter", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{variableName});
  }
};
// Writing MetadataGetter for method: Nitro::CompiledMethod::GetLocal
// Il2CppName: GetLocal
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Nitro::LocalVariable* (Nitro::CompiledMethod::*)(::StringW)>(&Nitro::CompiledMethod::GetLocal)> {
  static const MethodInfo* get() {
    static auto* variableName = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::CompiledMethod*), "GetLocal", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{variableName});
  }
};
// Writing MetadataGetter for method: Nitro::CompiledMethod::GetLocal
// Il2CppName: GetLocal
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Nitro::LocalVariable* (Nitro::CompiledMethod::*)(::StringW, bool, ::System::Type*)>(&Nitro::CompiledMethod::GetLocal)> {
  static const MethodInfo* get() {
    static auto* variableName = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* create = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* createType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::CompiledMethod*), "GetLocal", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{variableName, create, createType});
  }
};
// Writing MetadataGetter for method: Nitro::CompiledMethod::GetVariable
// Il2CppName: GetVariable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Nitro::Variable* (Nitro::CompiledMethod::*)(::StringW)>(&Nitro::CompiledMethod::GetVariable)> {
  static const MethodInfo* get() {
    static auto* name = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::CompiledMethod*), "GetVariable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{name});
  }
};
// Writing MetadataGetter for method: Nitro::CompiledMethod::GetVariable
// Il2CppName: GetVariable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Nitro::Variable* (Nitro::CompiledMethod::*)(::StringW, bool, ::System::Type*)>(&Nitro::CompiledMethod::GetVariable)> {
  static const MethodInfo* get() {
    static auto* name = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* create = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* createType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::CompiledMethod*), "GetVariable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{name, create, createType});
  }
};
// Writing MetadataGetter for method: Nitro::CompiledMethod::GetVariable
// Il2CppName: GetVariable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Nitro::Variable* (Nitro::CompiledMethod::*)(::StringW, ::Nitro::VariableType, bool, ::System::Type*)>(&Nitro::CompiledMethod::GetVariable)> {
  static const MethodInfo* get() {
    static auto* name = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* type = &::il2cpp_utils::GetClassFromName("Nitro", "VariableType")->byval_arg;
    static auto* create = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* createType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Nitro::CompiledMethod*), "GetVariable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{name, type, create, createType});
  }
};
// Writing MetadataGetter for method: Nitro::CompiledMethod::ParametersOk
// Il2CppName: ParametersOk
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Nitro::CompiledMethod::*)()>(&Nitro::CompiledMethod::ParametersOk)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Nitro::CompiledMethod*), "ParametersOk", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Nitro::CompiledMethod::ParseParameters
// Il2CppName: ParseParameters
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Nitro::CompiledMethod::*)()>(&Nitro::CompiledMethod::ParseParameters)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Nitro::CompiledMethod*), "ParseParameters", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Nitro::CompiledMethod::ApplyParameters
// Il2CppName: ApplyParameters
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Nitro::CompiledMethod::*)()>(&Nitro::CompiledMethod::ApplyParameters)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Nitro::CompiledMethod*), "ApplyParameters", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
