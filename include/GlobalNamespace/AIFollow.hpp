// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: UnityEngine.MonoBehaviour
#include "UnityEngine/MonoBehaviour.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: GlobalNamespace
namespace GlobalNamespace {
  // Forward declaring type: Seeker
  class Seeker;
}
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: Transform
  class Transform;
  // Forward declaring type: CharacterController
  class CharacterController;
}
// Forward declaring namespace: Pathfinding
namespace Pathfinding {
  // Forward declaring type: Path
  class Path;
}
// Forward declaring namespace: System::Collections
namespace System::Collections {
  // Forward declaring type: IEnumerator
  class IEnumerator;
}
// Completed forward declares
// Type namespace: 
namespace GlobalNamespace {
  // Forward declaring type: AIFollow
  class AIFollow;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::GlobalNamespace::AIFollow);
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::AIFollow*, "", "AIFollow");
// Type namespace: 
namespace GlobalNamespace {
  // Size: 0x60
  #pragma pack(push, 1)
  // Autogenerated type: AIFollow
  // [TokenAttribute] Offset: FFFFFFFF
  // [HelpURLAttribute] Offset: ACD258
  // [AddComponentMenu] Offset: ACD258
  // [RequireComponent] Offset: ACD258
  // [RequireComponent] Offset: ACD258
  class AIFollow : public ::UnityEngine::MonoBehaviour {
    public:
    // Nested type: ::GlobalNamespace::AIFollow::$WaitToRepath$d__18
    class $WaitToRepath$d__18;
    public:
    // public UnityEngine.Transform target
    // Size: 0x8
    // Offset: 0x18
    ::UnityEngine::Transform* target;
    // Field size check
    static_assert(sizeof(::UnityEngine::Transform*) == 0x8);
    // public System.Single repathRate
    // Size: 0x4
    // Offset: 0x20
    float repathRate;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single pickNextWaypointDistance
    // Size: 0x4
    // Offset: 0x24
    float pickNextWaypointDistance;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single targetReached
    // Size: 0x4
    // Offset: 0x28
    float targetReached;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single speed
    // Size: 0x4
    // Offset: 0x2C
    float speed;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single rotationSpeed
    // Size: 0x4
    // Offset: 0x30
    float rotationSpeed;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Boolean drawGizmos
    // Size: 0x1
    // Offset: 0x34
    bool drawGizmos;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Boolean canSearch
    // Size: 0x1
    // Offset: 0x35
    bool canSearch;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Boolean canMove
    // Size: 0x1
    // Offset: 0x36
    bool canMove;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: canMove and: seeker
    char __padding8[0x1] = {};
    // protected Seeker seeker
    // Size: 0x8
    // Offset: 0x38
    ::GlobalNamespace::Seeker* seeker;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::Seeker*) == 0x8);
    // protected UnityEngine.CharacterController controller
    // Size: 0x8
    // Offset: 0x40
    ::UnityEngine::CharacterController* controller;
    // Field size check
    static_assert(sizeof(::UnityEngine::CharacterController*) == 0x8);
    // protected UnityEngine.Transform tr
    // Size: 0x8
    // Offset: 0x48
    ::UnityEngine::Transform* tr;
    // Field size check
    static_assert(sizeof(::UnityEngine::Transform*) == 0x8);
    // protected System.Single lastPathSearch
    // Size: 0x4
    // Offset: 0x50
    float lastPathSearch;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // protected System.Int32 pathIndex
    // Size: 0x4
    // Offset: 0x54
    int pathIndex;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // protected UnityEngine.Vector3[] path
    // Size: 0x8
    // Offset: 0x58
    ::ArrayW<::UnityEngine::Vector3> path;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::Vector3>) == 0x8);
    public:
    // Deleting conversion operator: operator ::System::IntPtr
    constexpr operator ::System::IntPtr() const noexcept = delete;
    // Get instance field reference: public UnityEngine.Transform target
    [[deprecated("Use field access instead!")]] ::UnityEngine::Transform*& dyn_target();
    // Get instance field reference: public System.Single repathRate
    [[deprecated("Use field access instead!")]] float& dyn_repathRate();
    // Get instance field reference: public System.Single pickNextWaypointDistance
    [[deprecated("Use field access instead!")]] float& dyn_pickNextWaypointDistance();
    // Get instance field reference: public System.Single targetReached
    [[deprecated("Use field access instead!")]] float& dyn_targetReached();
    // Get instance field reference: public System.Single speed
    [[deprecated("Use field access instead!")]] float& dyn_speed();
    // Get instance field reference: public System.Single rotationSpeed
    [[deprecated("Use field access instead!")]] float& dyn_rotationSpeed();
    // Get instance field reference: public System.Boolean drawGizmos
    [[deprecated("Use field access instead!")]] bool& dyn_drawGizmos();
    // Get instance field reference: public System.Boolean canSearch
    [[deprecated("Use field access instead!")]] bool& dyn_canSearch();
    // Get instance field reference: public System.Boolean canMove
    [[deprecated("Use field access instead!")]] bool& dyn_canMove();
    // Get instance field reference: protected Seeker seeker
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::Seeker*& dyn_seeker();
    // Get instance field reference: protected UnityEngine.CharacterController controller
    [[deprecated("Use field access instead!")]] ::UnityEngine::CharacterController*& dyn_controller();
    // Get instance field reference: protected UnityEngine.Transform tr
    [[deprecated("Use field access instead!")]] ::UnityEngine::Transform*& dyn_tr();
    // Get instance field reference: protected System.Single lastPathSearch
    [[deprecated("Use field access instead!")]] float& dyn_lastPathSearch();
    // Get instance field reference: protected System.Int32 pathIndex
    [[deprecated("Use field access instead!")]] int& dyn_pathIndex();
    // Get instance field reference: protected UnityEngine.Vector3[] path
    [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::Vector3>& dyn_path();
    // public System.Void Start()
    // Offset: 0xEEEF58
    void Start();
    // public System.Void Reset()
    // Offset: 0xEEEFE4
    void Reset();
    // public System.Void OnPathComplete(Pathfinding.Path p)
    // Offset: 0xEEEFEC
    void OnPathComplete(::Pathfinding::Path* p);
    // public System.Collections.IEnumerator WaitToRepath()
    // Offset: 0xEEF1D4
    ::System::Collections::IEnumerator* WaitToRepath();
    // public System.Void Stop()
    // Offset: 0xEEF274
    void Stop();
    // public System.Void Resume()
    // Offset: 0xEEF27C
    void Resume();
    // public System.Void Repath()
    // Offset: 0xEEF288
    void Repath();
    // public System.Void PathToTarget(UnityEngine.Vector3 targetPoint)
    // Offset: 0xEEF470
    void PathToTarget(::UnityEngine::Vector3 targetPoint);
    // public System.Void ReachedEndOfPath()
    // Offset: 0xEEF5CC
    void ReachedEndOfPath();
    // public System.Void Update()
    // Offset: 0xEEF5D0
    void Update();
    // public System.Void OnDrawGizmos()
    // Offset: 0xEEFBBC
    void OnDrawGizmos();
    // public System.Void .ctor()
    // Offset: 0xEEFFE4
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static AIFollow* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::AIFollow::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<AIFollow*, creationType>()));
    }
  }; // AIFollow
  #pragma pack(pop)
  static check_size<sizeof(AIFollow), 88 + sizeof(::ArrayW<::UnityEngine::Vector3>)> __GlobalNamespace_AIFollowSizeCheck;
  static_assert(sizeof(AIFollow) == 0x60);
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: GlobalNamespace::AIFollow::Start
// Il2CppName: Start
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::AIFollow::*)()>(&GlobalNamespace::AIFollow::Start)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::AIFollow*), "Start", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::AIFollow::Reset
// Il2CppName: Reset
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::AIFollow::*)()>(&GlobalNamespace::AIFollow::Reset)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::AIFollow*), "Reset", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::AIFollow::OnPathComplete
// Il2CppName: OnPathComplete
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::AIFollow::*)(::Pathfinding::Path*)>(&GlobalNamespace::AIFollow::OnPathComplete)> {
  static const MethodInfo* get() {
    static auto* p = &::il2cpp_utils::GetClassFromName("Pathfinding", "Path")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::AIFollow*), "OnPathComplete", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{p});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::AIFollow::WaitToRepath
// Il2CppName: WaitToRepath
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Collections::IEnumerator* (GlobalNamespace::AIFollow::*)()>(&GlobalNamespace::AIFollow::WaitToRepath)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::AIFollow*), "WaitToRepath", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::AIFollow::Stop
// Il2CppName: Stop
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::AIFollow::*)()>(&GlobalNamespace::AIFollow::Stop)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::AIFollow*), "Stop", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::AIFollow::Resume
// Il2CppName: Resume
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::AIFollow::*)()>(&GlobalNamespace::AIFollow::Resume)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::AIFollow*), "Resume", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::AIFollow::Repath
// Il2CppName: Repath
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::AIFollow::*)()>(&GlobalNamespace::AIFollow::Repath)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::AIFollow*), "Repath", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::AIFollow::PathToTarget
// Il2CppName: PathToTarget
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::AIFollow::*)(::UnityEngine::Vector3)>(&GlobalNamespace::AIFollow::PathToTarget)> {
  static const MethodInfo* get() {
    static auto* targetPoint = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::AIFollow*), "PathToTarget", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{targetPoint});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::AIFollow::ReachedEndOfPath
// Il2CppName: ReachedEndOfPath
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::AIFollow::*)()>(&GlobalNamespace::AIFollow::ReachedEndOfPath)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::AIFollow*), "ReachedEndOfPath", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::AIFollow::Update
// Il2CppName: Update
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::AIFollow::*)()>(&GlobalNamespace::AIFollow::Update)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::AIFollow*), "Update", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::AIFollow::OnDrawGizmos
// Il2CppName: OnDrawGizmos
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::AIFollow::*)()>(&GlobalNamespace::AIFollow::OnDrawGizmos)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::AIFollow*), "OnDrawGizmos", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::AIFollow::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
