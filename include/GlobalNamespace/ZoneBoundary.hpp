// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: UnityEngine.MonoBehaviour
#include "UnityEngine/MonoBehaviour.hpp"
// Including type: UnityEngine.Vector2
#include "UnityEngine/Vector2.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: GlobalNamespace
namespace GlobalNamespace {
}
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: Collider
  class Collider;
  // Forward declaring type: MeshRenderer
  class MeshRenderer;
  // Forward declaring type: MeshFilter
  class MeshFilter;
  // Forward declaring type: Mesh
  class Mesh;
  // Forward declaring type: MaterialPropertyBlock
  class MaterialPropertyBlock;
  // Forward declaring type: SphereCollider
  class SphereCollider;
  // Forward declaring type: BoxCollider
  class BoxCollider;
}
// Forward declaring namespace: System::Collections::Generic
namespace System::Collections::Generic {
  // Forward declaring type: List`1<T>
  template<typename T>
  class List_1;
}
// Forward declaring namespace: System::Collections
namespace System::Collections {
  // Forward declaring type: IEnumerator
  class IEnumerator;
}
// Completed forward declares
// Type namespace: 
namespace GlobalNamespace {
  // Forward declaring type: ZoneBoundary
  class ZoneBoundary;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::GlobalNamespace::ZoneBoundary);
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::ZoneBoundary*, "", "ZoneBoundary");
// Type namespace: 
namespace GlobalNamespace {
  // Size: 0x80
  #pragma pack(push, 1)
  // Autogenerated type: ZoneBoundary
  // [TokenAttribute] Offset: FFFFFFFF
  class ZoneBoundary : public ::UnityEngine::MonoBehaviour {
    public:
    // Nested type: ::GlobalNamespace::ZoneBoundary::$BuildBoundary$d__17
    class $BuildBoundary$d__17;
    public:
    // public System.Single accuracy
    // Size: 0x4
    // Offset: 0x18
    float accuracy;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // Padding between fields: accuracy and: zoneCollider
    char __padding0[0x4] = {};
    // public UnityEngine.Collider zoneCollider
    // Size: 0x8
    // Offset: 0x20
    ::UnityEngine::Collider* zoneCollider;
    // Field size check
    static_assert(sizeof(::UnityEngine::Collider*) == 0x8);
    // private UnityEngine.MeshRenderer myRenderer
    // Size: 0x8
    // Offset: 0x28
    ::UnityEngine::MeshRenderer* myRenderer;
    // Field size check
    static_assert(sizeof(::UnityEngine::MeshRenderer*) == 0x8);
    // private UnityEngine.MeshFilter meshFilter
    // Size: 0x8
    // Offset: 0x30
    ::UnityEngine::MeshFilter* meshFilter;
    // Field size check
    static_assert(sizeof(::UnityEngine::MeshFilter*) == 0x8);
    // private UnityEngine.Mesh mesh
    // Size: 0x8
    // Offset: 0x38
    ::UnityEngine::Mesh* mesh;
    // Field size check
    static_assert(sizeof(::UnityEngine::Mesh*) == 0x8);
    // private UnityEngine.MaterialPropertyBlock block
    // Size: 0x8
    // Offset: 0x40
    ::UnityEngine::MaterialPropertyBlock* block;
    // Field size check
    static_assert(sizeof(::UnityEngine::MaterialPropertyBlock*) == 0x8);
    // private System.Int32 colorID
    // Size: 0x4
    // Offset: 0x48
    int colorID;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // Padding between fields: colorID and: points
    char __padding6[0x4] = {};
    // private System.Collections.Generic.List`1<UnityEngine.Vector3> points
    // Size: 0x8
    // Offset: 0x50
    ::System::Collections::Generic::List_1<::UnityEngine::Vector3>* points;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::List_1<::UnityEngine::Vector3>*) == 0x8);
    // private UnityEngine.Vector3[] vertices
    // Size: 0x8
    // Offset: 0x58
    ::ArrayW<::UnityEngine::Vector3> vertices;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::Vector3>) == 0x8);
    // private System.Int32[] tri
    // Size: 0x8
    // Offset: 0x60
    ::ArrayW<int> tri;
    // Field size check
    static_assert(sizeof(::ArrayW<int>) == 0x8);
    // private UnityEngine.Vector3[] normals
    // Size: 0x8
    // Offset: 0x68
    ::ArrayW<::UnityEngine::Vector3> normals;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::Vector3>) == 0x8);
    // private UnityEngine.Vector2[] uv
    // Size: 0x8
    // Offset: 0x70
    ::ArrayW<::UnityEngine::Vector2> uv;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::Vector2>) == 0x8);
    // private System.Boolean hasFoundTerrain
    // Size: 0x1
    // Offset: 0x78
    bool hasFoundTerrain;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: hasFoundTerrain and: terrainLayer
    char __padding12[0x3] = {};
    // private System.Int32 terrainLayer
    // Size: 0x4
    // Offset: 0x7C
    int terrainLayer;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    public:
    // Deleting conversion operator: operator ::System::IntPtr
    constexpr operator ::System::IntPtr() const noexcept = delete;
    // static field const value: static private System.Single HEIGHT_OFF_GROUND
    static constexpr const float HEIGHT_OFF_GROUND = 0.4;
    // Get static field: static private System.Single HEIGHT_OFF_GROUND
    static float _get_HEIGHT_OFF_GROUND();
    // Set static field: static private System.Single HEIGHT_OFF_GROUND
    static void _set_HEIGHT_OFF_GROUND(float value);
    // static field const value: static private System.Single BOUNDARY_HEIGHT
    static constexpr const float BOUNDARY_HEIGHT = 0.8;
    // Get static field: static private System.Single BOUNDARY_HEIGHT
    static float _get_BOUNDARY_HEIGHT();
    // Set static field: static private System.Single BOUNDARY_HEIGHT
    static void _set_BOUNDARY_HEIGHT(float value);
    // Get instance field reference: public System.Single accuracy
    [[deprecated("Use field access instead!")]] float& dyn_accuracy();
    // Get instance field reference: public UnityEngine.Collider zoneCollider
    [[deprecated("Use field access instead!")]] ::UnityEngine::Collider*& dyn_zoneCollider();
    // Get instance field reference: private UnityEngine.MeshRenderer myRenderer
    [[deprecated("Use field access instead!")]] ::UnityEngine::MeshRenderer*& dyn_myRenderer();
    // Get instance field reference: private UnityEngine.MeshFilter meshFilter
    [[deprecated("Use field access instead!")]] ::UnityEngine::MeshFilter*& dyn_meshFilter();
    // Get instance field reference: private UnityEngine.Mesh mesh
    [[deprecated("Use field access instead!")]] ::UnityEngine::Mesh*& dyn_mesh();
    // Get instance field reference: private UnityEngine.MaterialPropertyBlock block
    [[deprecated("Use field access instead!")]] ::UnityEngine::MaterialPropertyBlock*& dyn_block();
    // Get instance field reference: private System.Int32 colorID
    [[deprecated("Use field access instead!")]] int& dyn_colorID();
    // Get instance field reference: private System.Collections.Generic.List`1<UnityEngine.Vector3> points
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::List_1<::UnityEngine::Vector3>*& dyn_points();
    // Get instance field reference: private UnityEngine.Vector3[] vertices
    [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::Vector3>& dyn_vertices();
    // Get instance field reference: private System.Int32[] tri
    [[deprecated("Use field access instead!")]] ::ArrayW<int>& dyn_tri();
    // Get instance field reference: private UnityEngine.Vector3[] normals
    [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::Vector3>& dyn_normals();
    // Get instance field reference: private UnityEngine.Vector2[] uv
    [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::Vector2>& dyn_uv();
    // Get instance field reference: private System.Boolean hasFoundTerrain
    [[deprecated("Use field access instead!")]] bool& dyn_hasFoundTerrain();
    // Get instance field reference: private System.Int32 terrainLayer
    [[deprecated("Use field access instead!")]] int& dyn_terrainLayer();
    // private System.Void Awake()
    // Offset: 0x28319A4
    void Awake();
    // public System.Collections.IEnumerator BuildBoundary()
    // Offset: 0x2831AF4
    ::System::Collections::IEnumerator* BuildBoundary();
    // public System.Void ShowBoundary()
    // Offset: 0x2831B94
    void ShowBoundary();
    // public System.Void HideBoundary()
    // Offset: 0x2831BC8
    void HideBoundary();
    // public System.Void SetState(System.Byte state)
    // Offset: 0x2831BFC
    void SetState(uint8_t state);
    // private System.Void BuildBoundary(UnityEngine.SphereCollider collider)
    // Offset: 0x2831CD8
    void BuildBoundary(::UnityEngine::SphereCollider* collider);
    // private System.Void BuildBoundary(UnityEngine.BoxCollider collider)
    // Offset: 0x28321B8
    void BuildBoundary(::UnityEngine::BoxCollider* collider);
    // private UnityEngine.Vector3 FindGround(UnityEngine.Vector3 topBox, System.Single boxHeight)
    // Offset: 0x2831FB0
    ::UnityEngine::Vector3 FindGround(::UnityEngine::Vector3 topBox, float boxHeight);
    // private System.Void InitArrays(UnityEngine.Collider collider)
    // Offset: 0x283286C
    void InitArrays(::UnityEngine::Collider* collider);
    // public System.Void .ctor()
    // Offset: 0x283376C
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static ZoneBoundary* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::ZoneBoundary::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<ZoneBoundary*, creationType>()));
    }
  }; // ZoneBoundary
  #pragma pack(pop)
  static check_size<sizeof(ZoneBoundary), 124 + sizeof(int)> __GlobalNamespace_ZoneBoundarySizeCheck;
  static_assert(sizeof(ZoneBoundary) == 0x80);
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: GlobalNamespace::ZoneBoundary::Awake
// Il2CppName: Awake
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::ZoneBoundary::*)()>(&GlobalNamespace::ZoneBoundary::Awake)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::ZoneBoundary*), "Awake", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::ZoneBoundary::BuildBoundary
// Il2CppName: BuildBoundary
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Collections::IEnumerator* (GlobalNamespace::ZoneBoundary::*)()>(&GlobalNamespace::ZoneBoundary::BuildBoundary)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::ZoneBoundary*), "BuildBoundary", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::ZoneBoundary::ShowBoundary
// Il2CppName: ShowBoundary
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::ZoneBoundary::*)()>(&GlobalNamespace::ZoneBoundary::ShowBoundary)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::ZoneBoundary*), "ShowBoundary", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::ZoneBoundary::HideBoundary
// Il2CppName: HideBoundary
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::ZoneBoundary::*)()>(&GlobalNamespace::ZoneBoundary::HideBoundary)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::ZoneBoundary*), "HideBoundary", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::ZoneBoundary::SetState
// Il2CppName: SetState
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::ZoneBoundary::*)(uint8_t)>(&GlobalNamespace::ZoneBoundary::SetState)> {
  static const MethodInfo* get() {
    static auto* state = &::il2cpp_utils::GetClassFromName("System", "Byte")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::ZoneBoundary*), "SetState", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{state});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::ZoneBoundary::BuildBoundary
// Il2CppName: BuildBoundary
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::ZoneBoundary::*)(::UnityEngine::SphereCollider*)>(&GlobalNamespace::ZoneBoundary::BuildBoundary)> {
  static const MethodInfo* get() {
    static auto* collider = &::il2cpp_utils::GetClassFromName("UnityEngine", "SphereCollider")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::ZoneBoundary*), "BuildBoundary", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{collider});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::ZoneBoundary::BuildBoundary
// Il2CppName: BuildBoundary
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::ZoneBoundary::*)(::UnityEngine::BoxCollider*)>(&GlobalNamespace::ZoneBoundary::BuildBoundary)> {
  static const MethodInfo* get() {
    static auto* collider = &::il2cpp_utils::GetClassFromName("UnityEngine", "BoxCollider")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::ZoneBoundary*), "BuildBoundary", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{collider});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::ZoneBoundary::FindGround
// Il2CppName: FindGround
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Vector3 (GlobalNamespace::ZoneBoundary::*)(::UnityEngine::Vector3, float)>(&GlobalNamespace::ZoneBoundary::FindGround)> {
  static const MethodInfo* get() {
    static auto* topBox = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* boxHeight = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::ZoneBoundary*), "FindGround", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{topBox, boxHeight});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::ZoneBoundary::InitArrays
// Il2CppName: InitArrays
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::ZoneBoundary::*)(::UnityEngine::Collider*)>(&GlobalNamespace::ZoneBoundary::InitArrays)> {
  static const MethodInfo* get() {
    static auto* collider = &::il2cpp_utils::GetClassFromName("UnityEngine", "Collider")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::ZoneBoundary*), "InitArrays", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{collider});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::ZoneBoundary::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
