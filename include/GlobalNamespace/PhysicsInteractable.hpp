// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: InteractableObject
#include "GlobalNamespace/InteractableObject.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-string.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: GlobalNamespace
namespace GlobalNamespace {
}
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: Rigidbody
  class Rigidbody;
  // Forward declaring type: BoxCollider
  class BoxCollider;
  // Forward declaring type: GameObject
  class GameObject;
}
// Forward declaring namespace: MagicalActual
namespace MagicalActual {
  // Forward declaring type: Grabber
  class Grabber;
}
// Completed forward declares
// Type namespace: 
namespace GlobalNamespace {
  // Forward declaring type: PhysicsInteractable
  class PhysicsInteractable;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::GlobalNamespace::PhysicsInteractable);
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::PhysicsInteractable*, "", "PhysicsInteractable");
// Type namespace: 
namespace GlobalNamespace {
  // Size: 0x100
  #pragma pack(push, 1)
  // Autogenerated type: PhysicsInteractable
  // [TokenAttribute] Offset: FFFFFFFF
  // [RequireComponent] Offset: ACE028
  // [RequireComponent] Offset: ACE028
  class PhysicsInteractable : public ::GlobalNamespace::InteractableObject {
    public:
    // Nested type: ::GlobalNamespace::PhysicsInteractable::GameObjectEvent
    class GameObjectEvent;
    public:
    // public System.Boolean canPickUp
    // Size: 0x1
    // Offset: 0x18
    bool canPickUp;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Byte pickUpTracker
    // Size: 0x1
    // Offset: 0x19
    uint8_t pickUpTracker;
    // Field size check
    static_assert(sizeof(uint8_t) == 0x1);
    // private System.Byte grabIndicatorTracker
    // Size: 0x1
    // Offset: 0x1A
    uint8_t grabIndicatorTracker;
    // Field size check
    static_assert(sizeof(uint8_t) == 0x1);
    // private System.Boolean setFirst
    // Size: 0x1
    // Offset: 0x1B
    bool setFirst;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Boolean isEnemy
    // Size: 0x1
    // Offset: 0x1C
    bool isEnemy;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Boolean throwWhenReleased
    // Size: 0x1
    // Offset: 0x1D
    bool throwWhenReleased;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Boolean cloneToGrab
    // Size: 0x1
    // Offset: 0x1E
    bool cloneToGrab;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Boolean isAClone
    // Size: 0x1
    // Offset: 0x1F
    bool isAClone;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Boolean hideHandWhenHolding
    // Size: 0x1
    // Offset: 0x20
    bool hideHandWhenHolding;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Boolean orientWhenGrabbed
    // Size: 0x1
    // Offset: 0x21
    bool orientWhenGrabbed;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Boolean allowLongRangeGrab
    // Size: 0x1
    // Offset: 0x22
    bool allowLongRangeGrab;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Boolean hideLongRangeGrabCircle
    // Size: 0x1
    // Offset: 0x23
    bool hideLongRangeGrabCircle;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Boolean ignoreOffset
    // Size: 0x1
    // Offset: 0x24
    bool ignoreOffset;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: ignoreOffset and: grabOrientation
    char __padding12[0x3] = {};
    // public UnityEngine.Vector3 grabOrientation
    // Size: 0xC
    // Offset: 0x28
    ::UnityEngine::Vector3 grabOrientation;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // public UnityEngine.Vector3 grabOrientationVive
    // Size: 0xC
    // Offset: 0x34
    ::UnityEngine::Vector3 grabOrientationVive;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // public UnityEngine.Vector3 grabOffset
    // Size: 0xC
    // Offset: 0x40
    ::UnityEngine::Vector3 grabOffset;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // Padding between fields: grabOffset and: myRigidBody
    char __padding15[0x4] = {};
    // public UnityEngine.Rigidbody myRigidBody
    // Size: 0x8
    // Offset: 0x50
    ::UnityEngine::Rigidbody* myRigidBody;
    // Field size check
    static_assert(sizeof(::UnityEngine::Rigidbody*) == 0x8);
    // [CompilerGeneratedAttribute] Offset: 0xADA4A8
    // private MagicalActual.Grabber <attachedToObject>k__BackingField
    // Size: 0x8
    // Offset: 0x58
    ::MagicalActual::Grabber* attachedToObject;
    // Field size check
    static_assert(sizeof(::MagicalActual::Grabber*) == 0x8);
    // public MagicalActual.Grabber lastClonedGrabber
    // Size: 0x8
    // Offset: 0x60
    ::MagicalActual::Grabber* lastClonedGrabber;
    // Field size check
    static_assert(sizeof(::MagicalActual::Grabber*) == 0x8);
    // private UnityEngine.BoxCollider myBoxCollider
    // Size: 0x8
    // Offset: 0x68
    ::UnityEngine::BoxCollider* myBoxCollider;
    // Field size check
    static_assert(sizeof(::UnityEngine::BoxCollider*) == 0x8);
    // public System.Boolean broadcastToNetwork
    // Size: 0x1
    // Offset: 0x70
    bool broadcastToNetwork;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: broadcastToNetwork and: networkKey
    char __padding20[0x7] = {};
    // public System.String networkKey
    // Size: 0x8
    // Offset: 0x78
    ::StringW networkKey;
    // Field size check
    static_assert(sizeof(::StringW) == 0x8);
    // private UnityEngine.GameObject clonedCopy
    // Size: 0x8
    // Offset: 0x80
    ::UnityEngine::GameObject* clonedCopy;
    // Field size check
    static_assert(sizeof(::UnityEngine::GameObject*) == 0x8);
    // private System.Boolean isFakeGrabbing
    // Size: 0x1
    // Offset: 0x88
    bool isFakeGrabbing;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: isFakeGrabbing and: myGrabIndicator
    char __padding23[0x7] = {};
    // [CompilerGeneratedAttribute] Offset: 0xADA4D8
    // private UnityEngine.GameObject <myGrabIndicator>k__BackingField
    // Size: 0x8
    // Offset: 0x90
    ::UnityEngine::GameObject* myGrabIndicator;
    // Field size check
    static_assert(sizeof(::UnityEngine::GameObject*) == 0x8);
    // private System.Single lastShakeIndicator
    // Size: 0x4
    // Offset: 0x98
    float lastShakeIndicator;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single lastShook
    // Size: 0x4
    // Offset: 0x9C
    float lastShook;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single allowShakeEvery
    // Size: 0x4
    // Offset: 0xA0
    float allowShakeEvery;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single shakeThreshold
    // Size: 0x4
    // Offset: 0xA4
    float shakeThreshold;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private UnityEngine.Vector3 previousPosition
    // Size: 0xC
    // Offset: 0xA8
    ::UnityEngine::Vector3 previousPosition;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private UnityEngine.Vector3 prevDirection
    // Size: 0xC
    // Offset: 0xB4
    ::UnityEngine::Vector3 prevDirection;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private System.Int32 numShakes
    // Size: 0x4
    // Offset: 0xC0
    int numShakes;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // Padding between fields: numShakes and: latestGrabber
    char __padding31[0x4] = {};
    // private MagicalActual.Grabber latestGrabber
    // Size: 0x8
    // Offset: 0xC8
    ::MagicalActual::Grabber* latestGrabber;
    // Field size check
    static_assert(sizeof(::MagicalActual::Grabber*) == 0x8);
    // private UnityEngine.Vector3 originalGrabLocation
    // Size: 0xC
    // Offset: 0xD0
    ::UnityEngine::Vector3 originalGrabLocation;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private System.Boolean justGrabbed
    // Size: 0x1
    // Offset: 0xDC
    bool justGrabbed;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: justGrabbed and: stickyGrabTime
    char __padding34[0x3] = {};
    // private System.Single stickyGrabTime
    // Size: 0x4
    // Offset: 0xE0
    float stickyGrabTime;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single stickyGrabTimeNeeded
    // Size: 0x4
    // Offset: 0xE4
    float stickyGrabTimeNeeded;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Boolean ignoreFirstUngrip
    // Size: 0x1
    // Offset: 0xE8
    bool ignoreFirstUngrip;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Boolean noStickyGrip
    // Size: 0x1
    // Offset: 0xE9
    bool noStickyGrip;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: noStickyGrip and: doGripEvent
    char __padding38[0x6] = {};
    // public PhysicsInteractable/GameObjectEvent doGripEvent
    // Size: 0x8
    // Offset: 0xF0
    ::GlobalNamespace::PhysicsInteractable::GameObjectEvent* doGripEvent;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::PhysicsInteractable::GameObjectEvent*) == 0x8);
    // public PhysicsInteractable/GameObjectEvent doUngripEvent
    // Size: 0x8
    // Offset: 0xF8
    ::GlobalNamespace::PhysicsInteractable::GameObjectEvent* doUngripEvent;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::PhysicsInteractable::GameObjectEvent*) == 0x8);
    public:
    // Deleting conversion operator: operator ::System::IntPtr
    constexpr operator ::System::IntPtr() const noexcept = delete;
    // Get instance field reference: public System.Boolean canPickUp
    [[deprecated("Use field access instead!")]] bool& dyn_canPickUp();
    // Get instance field reference: private System.Byte pickUpTracker
    [[deprecated("Use field access instead!")]] uint8_t& dyn_pickUpTracker();
    // Get instance field reference: private System.Byte grabIndicatorTracker
    [[deprecated("Use field access instead!")]] uint8_t& dyn_grabIndicatorTracker();
    // Get instance field reference: private System.Boolean setFirst
    [[deprecated("Use field access instead!")]] bool& dyn_setFirst();
    // Get instance field reference: public System.Boolean isEnemy
    [[deprecated("Use field access instead!")]] bool& dyn_isEnemy();
    // Get instance field reference: public System.Boolean throwWhenReleased
    [[deprecated("Use field access instead!")]] bool& dyn_throwWhenReleased();
    // Get instance field reference: public System.Boolean cloneToGrab
    [[deprecated("Use field access instead!")]] bool& dyn_cloneToGrab();
    // Get instance field reference: private System.Boolean isAClone
    [[deprecated("Use field access instead!")]] bool& dyn_isAClone();
    // Get instance field reference: public System.Boolean hideHandWhenHolding
    [[deprecated("Use field access instead!")]] bool& dyn_hideHandWhenHolding();
    // Get instance field reference: public System.Boolean orientWhenGrabbed
    [[deprecated("Use field access instead!")]] bool& dyn_orientWhenGrabbed();
    // Get instance field reference: public System.Boolean allowLongRangeGrab
    [[deprecated("Use field access instead!")]] bool& dyn_allowLongRangeGrab();
    // Get instance field reference: private System.Boolean hideLongRangeGrabCircle
    [[deprecated("Use field access instead!")]] bool& dyn_hideLongRangeGrabCircle();
    // Get instance field reference: public System.Boolean ignoreOffset
    [[deprecated("Use field access instead!")]] bool& dyn_ignoreOffset();
    // Get instance field reference: public UnityEngine.Vector3 grabOrientation
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_grabOrientation();
    // Get instance field reference: public UnityEngine.Vector3 grabOrientationVive
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_grabOrientationVive();
    // Get instance field reference: public UnityEngine.Vector3 grabOffset
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_grabOffset();
    // Get instance field reference: public UnityEngine.Rigidbody myRigidBody
    [[deprecated("Use field access instead!")]] ::UnityEngine::Rigidbody*& dyn_myRigidBody();
    // Get instance field reference: private MagicalActual.Grabber <attachedToObject>k__BackingField
    [[deprecated("Use field access instead!")]] ::MagicalActual::Grabber*& dyn_$attachedToObject$k__BackingField();
    // Get instance field reference: public MagicalActual.Grabber lastClonedGrabber
    [[deprecated("Use field access instead!")]] ::MagicalActual::Grabber*& dyn_lastClonedGrabber();
    // Get instance field reference: private UnityEngine.BoxCollider myBoxCollider
    [[deprecated("Use field access instead!")]] ::UnityEngine::BoxCollider*& dyn_myBoxCollider();
    // Get instance field reference: public System.Boolean broadcastToNetwork
    [[deprecated("Use field access instead!")]] bool& dyn_broadcastToNetwork();
    // Get instance field reference: public System.String networkKey
    [[deprecated("Use field access instead!")]] ::StringW& dyn_networkKey();
    // Get instance field reference: private UnityEngine.GameObject clonedCopy
    [[deprecated("Use field access instead!")]] ::UnityEngine::GameObject*& dyn_clonedCopy();
    // Get instance field reference: private System.Boolean isFakeGrabbing
    [[deprecated("Use field access instead!")]] bool& dyn_isFakeGrabbing();
    // Get instance field reference: private UnityEngine.GameObject <myGrabIndicator>k__BackingField
    [[deprecated("Use field access instead!")]] ::UnityEngine::GameObject*& dyn_$myGrabIndicator$k__BackingField();
    // Get instance field reference: private System.Single lastShakeIndicator
    [[deprecated("Use field access instead!")]] float& dyn_lastShakeIndicator();
    // Get instance field reference: private System.Single lastShook
    [[deprecated("Use field access instead!")]] float& dyn_lastShook();
    // Get instance field reference: private System.Single allowShakeEvery
    [[deprecated("Use field access instead!")]] float& dyn_allowShakeEvery();
    // Get instance field reference: private System.Single shakeThreshold
    [[deprecated("Use field access instead!")]] float& dyn_shakeThreshold();
    // Get instance field reference: private UnityEngine.Vector3 previousPosition
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_previousPosition();
    // Get instance field reference: private UnityEngine.Vector3 prevDirection
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_prevDirection();
    // Get instance field reference: private System.Int32 numShakes
    [[deprecated("Use field access instead!")]] int& dyn_numShakes();
    // Get instance field reference: private MagicalActual.Grabber latestGrabber
    [[deprecated("Use field access instead!")]] ::MagicalActual::Grabber*& dyn_latestGrabber();
    // Get instance field reference: private UnityEngine.Vector3 originalGrabLocation
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_originalGrabLocation();
    // Get instance field reference: private System.Boolean justGrabbed
    [[deprecated("Use field access instead!")]] bool& dyn_justGrabbed();
    // Get instance field reference: private System.Single stickyGrabTime
    [[deprecated("Use field access instead!")]] float& dyn_stickyGrabTime();
    // Get instance field reference: private System.Single stickyGrabTimeNeeded
    [[deprecated("Use field access instead!")]] float& dyn_stickyGrabTimeNeeded();
    // Get instance field reference: public System.Boolean ignoreFirstUngrip
    [[deprecated("Use field access instead!")]] bool& dyn_ignoreFirstUngrip();
    // Get instance field reference: public System.Boolean noStickyGrip
    [[deprecated("Use field access instead!")]] bool& dyn_noStickyGrip();
    // Get instance field reference: public PhysicsInteractable/GameObjectEvent doGripEvent
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::PhysicsInteractable::GameObjectEvent*& dyn_doGripEvent();
    // Get instance field reference: public PhysicsInteractable/GameObjectEvent doUngripEvent
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::PhysicsInteractable::GameObjectEvent*& dyn_doUngripEvent();
    // public MagicalActual.Grabber get_attachedToObject()
    // Offset: 0xE4F78C
    ::MagicalActual::Grabber* get_attachedToObject();
    // public System.Void set_attachedToObject(MagicalActual.Grabber value)
    // Offset: 0xE4F794
    void set_attachedToObject(::MagicalActual::Grabber* value);
    // public UnityEngine.GameObject get_myGrabIndicator()
    // Offset: 0xE4F79C
    ::UnityEngine::GameObject* get_myGrabIndicator();
    // private System.Void set_myGrabIndicator(UnityEngine.GameObject value)
    // Offset: 0xE4F7A4
    void set_myGrabIndicator(::UnityEngine::GameObject* value);
    // protected System.Void Awake()
    // Offset: 0xE4F7AC
    void Awake();
    // public System.Void OnDisable()
    // Offset: 0xE4FB9C
    void OnDisable();
    // public System.Void OnEnable()
    // Offset: 0xE4FC44
    void OnEnable();
    // public System.Void OnDestroy()
    // Offset: 0xE4FCEC
    void OnDestroy();
    // private System.Void LateUpdate()
    // Offset: 0xE4FDD4
    void LateUpdate();
    // public System.Void LongRangeActive()
    // Offset: 0xE50560
    void LongRangeActive();
    // public System.Void LongRangeInactive()
    // Offset: 0xE50658
    void LongRangeInactive();
    // public System.Void doFakeGripInteraction(MagicalActual.Grabber grabber)
    // Offset: 0xE50750
    void doFakeGripInteraction(::MagicalActual::Grabber* grabber);
    // public System.Void doGripInteraction(UnityEngine.GameObject sender)
    // Offset: 0xE508D4
    void doGripInteraction(::UnityEngine::GameObject* sender);
    // public System.Void doFakeUnGripInteraction()
    // Offset: 0xE5106C
    void doFakeUnGripInteraction();
    // public System.Void doUnGripInteraction(UnityEngine.GameObject sender)
    // Offset: 0xE5119C
    void doUnGripInteraction(::UnityEngine::GameObject* sender);
    // public System.Void forceUngrip(System.Boolean doThrow)
    // Offset: 0xE51748
    void forceUngrip(bool doThrow);
    // public System.Void setCanPickUp(System.Int32 index, System.Boolean pickUp, System.Boolean onlyHideIndicator)
    // Offset: 0xE5157C
    void setCanPickUp(int index, bool pickUp, bool onlyHideIndicator);
    // protected override System.Void Start()
    // Offset: 0xE4F934
    // Implemented from: InteractableObject
    // Base method: System.Void InteractableObject::Start()
    void Start();
    // protected override System.Void FixedUpdate()
    // Offset: 0xE500F8
    // Implemented from: InteractableObject
    // Base method: System.Void InteractableObject::FixedUpdate()
    void FixedUpdate();
    // public System.Void .ctor()
    // Offset: 0xE51828
    // Implemented from: InteractableObject
    // Base method: System.Void InteractableObject::.ctor()
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static PhysicsInteractable* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::PhysicsInteractable::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<PhysicsInteractable*, creationType>()));
    }
  }; // PhysicsInteractable
  #pragma pack(pop)
  static check_size<sizeof(PhysicsInteractable), 248 + sizeof(::GlobalNamespace::PhysicsInteractable::GameObjectEvent*)> __GlobalNamespace_PhysicsInteractableSizeCheck;
  static_assert(sizeof(PhysicsInteractable) == 0x100);
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: GlobalNamespace::PhysicsInteractable::get_attachedToObject
// Il2CppName: get_attachedToObject
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::MagicalActual::Grabber* (GlobalNamespace::PhysicsInteractable::*)()>(&GlobalNamespace::PhysicsInteractable::get_attachedToObject)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::PhysicsInteractable*), "get_attachedToObject", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::PhysicsInteractable::set_attachedToObject
// Il2CppName: set_attachedToObject
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::PhysicsInteractable::*)(::MagicalActual::Grabber*)>(&GlobalNamespace::PhysicsInteractable::set_attachedToObject)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("MagicalActual", "Grabber")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::PhysicsInteractable*), "set_attachedToObject", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::PhysicsInteractable::get_myGrabIndicator
// Il2CppName: get_myGrabIndicator
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::GameObject* (GlobalNamespace::PhysicsInteractable::*)()>(&GlobalNamespace::PhysicsInteractable::get_myGrabIndicator)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::PhysicsInteractable*), "get_myGrabIndicator", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::PhysicsInteractable::set_myGrabIndicator
// Il2CppName: set_myGrabIndicator
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::PhysicsInteractable::*)(::UnityEngine::GameObject*)>(&GlobalNamespace::PhysicsInteractable::set_myGrabIndicator)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::PhysicsInteractable*), "set_myGrabIndicator", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::PhysicsInteractable::Awake
// Il2CppName: Awake
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::PhysicsInteractable::*)()>(&GlobalNamespace::PhysicsInteractable::Awake)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::PhysicsInteractable*), "Awake", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::PhysicsInteractable::OnDisable
// Il2CppName: OnDisable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::PhysicsInteractable::*)()>(&GlobalNamespace::PhysicsInteractable::OnDisable)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::PhysicsInteractable*), "OnDisable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::PhysicsInteractable::OnEnable
// Il2CppName: OnEnable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::PhysicsInteractable::*)()>(&GlobalNamespace::PhysicsInteractable::OnEnable)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::PhysicsInteractable*), "OnEnable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::PhysicsInteractable::OnDestroy
// Il2CppName: OnDestroy
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::PhysicsInteractable::*)()>(&GlobalNamespace::PhysicsInteractable::OnDestroy)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::PhysicsInteractable*), "OnDestroy", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::PhysicsInteractable::LateUpdate
// Il2CppName: LateUpdate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::PhysicsInteractable::*)()>(&GlobalNamespace::PhysicsInteractable::LateUpdate)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::PhysicsInteractable*), "LateUpdate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::PhysicsInteractable::LongRangeActive
// Il2CppName: LongRangeActive
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::PhysicsInteractable::*)()>(&GlobalNamespace::PhysicsInteractable::LongRangeActive)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::PhysicsInteractable*), "LongRangeActive", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::PhysicsInteractable::LongRangeInactive
// Il2CppName: LongRangeInactive
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::PhysicsInteractable::*)()>(&GlobalNamespace::PhysicsInteractable::LongRangeInactive)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::PhysicsInteractable*), "LongRangeInactive", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::PhysicsInteractable::doFakeGripInteraction
// Il2CppName: doFakeGripInteraction
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::PhysicsInteractable::*)(::MagicalActual::Grabber*)>(&GlobalNamespace::PhysicsInteractable::doFakeGripInteraction)> {
  static const MethodInfo* get() {
    static auto* grabber = &::il2cpp_utils::GetClassFromName("MagicalActual", "Grabber")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::PhysicsInteractable*), "doFakeGripInteraction", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{grabber});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::PhysicsInteractable::doGripInteraction
// Il2CppName: doGripInteraction
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::PhysicsInteractable::*)(::UnityEngine::GameObject*)>(&GlobalNamespace::PhysicsInteractable::doGripInteraction)> {
  static const MethodInfo* get() {
    static auto* sender = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::PhysicsInteractable*), "doGripInteraction", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{sender});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::PhysicsInteractable::doFakeUnGripInteraction
// Il2CppName: doFakeUnGripInteraction
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::PhysicsInteractable::*)()>(&GlobalNamespace::PhysicsInteractable::doFakeUnGripInteraction)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::PhysicsInteractable*), "doFakeUnGripInteraction", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::PhysicsInteractable::doUnGripInteraction
// Il2CppName: doUnGripInteraction
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::PhysicsInteractable::*)(::UnityEngine::GameObject*)>(&GlobalNamespace::PhysicsInteractable::doUnGripInteraction)> {
  static const MethodInfo* get() {
    static auto* sender = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::PhysicsInteractable*), "doUnGripInteraction", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{sender});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::PhysicsInteractable::forceUngrip
// Il2CppName: forceUngrip
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::PhysicsInteractable::*)(bool)>(&GlobalNamespace::PhysicsInteractable::forceUngrip)> {
  static const MethodInfo* get() {
    static auto* doThrow = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::PhysicsInteractable*), "forceUngrip", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{doThrow});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::PhysicsInteractable::setCanPickUp
// Il2CppName: setCanPickUp
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::PhysicsInteractable::*)(int, bool, bool)>(&GlobalNamespace::PhysicsInteractable::setCanPickUp)> {
  static const MethodInfo* get() {
    static auto* index = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* pickUp = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* onlyHideIndicator = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::PhysicsInteractable*), "setCanPickUp", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{index, pickUp, onlyHideIndicator});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::PhysicsInteractable::Start
// Il2CppName: Start
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::PhysicsInteractable::*)()>(&GlobalNamespace::PhysicsInteractable::Start)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::PhysicsInteractable*), "Start", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::PhysicsInteractable::FixedUpdate
// Il2CppName: FixedUpdate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::PhysicsInteractable::*)()>(&GlobalNamespace::PhysicsInteractable::FixedUpdate)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::PhysicsInteractable*), "FixedUpdate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::PhysicsInteractable::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
