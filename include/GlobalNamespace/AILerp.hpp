// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: UnityEngine.MonoBehaviour
#include "UnityEngine/MonoBehaviour.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
// Completed includes
// Begin forward declares
// Forward declaring namespace: GlobalNamespace
namespace GlobalNamespace {
  // Forward declaring type: Seeker
  class Seeker;
}
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: Transform
  class Transform;
}
// Forward declaring namespace: Pathfinding
namespace Pathfinding {
  // Forward declaring type: ABPath
  class ABPath;
  // Forward declaring type: Path
  class Path;
}
// Forward declaring namespace: System::Collections
namespace System::Collections {
  // Forward declaring type: IEnumerator
  class IEnumerator;
}
// Completed forward declares
// Type namespace: 
namespace GlobalNamespace {
  // Forward declaring type: AILerp
  class AILerp;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::GlobalNamespace::AILerp);
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::AILerp*, "", "AILerp");
// Type namespace: 
namespace GlobalNamespace {
  // Size: 0x89
  #pragma pack(push, 1)
  // Autogenerated type: AILerp
  // [TokenAttribute] Offset: FFFFFFFF
  // [HelpURLAttribute] Offset: ACCE30
  // [AddComponentMenu] Offset: ACCE30
  // [RequireComponent] Offset: ACCE30
  class AILerp : public ::UnityEngine::MonoBehaviour {
    public:
    // Nested type: ::GlobalNamespace::AILerp::$RepeatTrySearchPath$d__29
    class $RepeatTrySearchPath$d__29;
    public:
    // public System.Single repathRate
    // Size: 0x4
    // Offset: 0x18
    float repathRate;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // Padding between fields: repathRate and: target
    char __padding0[0x4] = {};
    // public UnityEngine.Transform target
    // Size: 0x8
    // Offset: 0x20
    ::UnityEngine::Transform* target;
    // Field size check
    static_assert(sizeof(::UnityEngine::Transform*) == 0x8);
    // public System.Boolean canSearch
    // Size: 0x1
    // Offset: 0x28
    bool canSearch;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Boolean canMove
    // Size: 0x1
    // Offset: 0x29
    bool canMove;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: canMove and: speed
    char __padding3[0x2] = {};
    // public System.Single speed
    // Size: 0x4
    // Offset: 0x2C
    float speed;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Boolean enableRotation
    // Size: 0x1
    // Offset: 0x30
    bool enableRotation;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Boolean rotationIn2D
    // Size: 0x1
    // Offset: 0x31
    bool rotationIn2D;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: rotationIn2D and: rotationSpeed
    char __padding6[0x2] = {};
    // public System.Single rotationSpeed
    // Size: 0x4
    // Offset: 0x34
    float rotationSpeed;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Boolean interpolatePathSwitches
    // Size: 0x1
    // Offset: 0x38
    bool interpolatePathSwitches;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: interpolatePathSwitches and: switchPathInterpolationSpeed
    char __padding8[0x3] = {};
    // public System.Single switchPathInterpolationSpeed
    // Size: 0x4
    // Offset: 0x3C
    float switchPathInterpolationSpeed;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // protected Seeker seeker
    // Size: 0x8
    // Offset: 0x40
    ::GlobalNamespace::Seeker* seeker;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::Seeker*) == 0x8);
    // protected UnityEngine.Transform tr
    // Size: 0x8
    // Offset: 0x48
    ::UnityEngine::Transform* tr;
    // Field size check
    static_assert(sizeof(::UnityEngine::Transform*) == 0x8);
    // protected System.Single lastRepath
    // Size: 0x4
    // Offset: 0x50
    float lastRepath;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // Padding between fields: lastRepath and: path
    char __padding12[0x4] = {};
    // protected Pathfinding.ABPath path
    // Size: 0x8
    // Offset: 0x58
    ::Pathfinding::ABPath* path;
    // Field size check
    static_assert(sizeof(::Pathfinding::ABPath*) == 0x8);
    // protected System.Int32 currentWaypointIndex
    // Size: 0x4
    // Offset: 0x60
    int currentWaypointIndex;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // protected System.Single distanceAlongSegment
    // Size: 0x4
    // Offset: 0x64
    float distanceAlongSegment;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // [CompilerGeneratedAttribute] Offset: 0xAD89CC
    // private System.Boolean <targetReached>k__BackingField
    // Size: 0x1
    // Offset: 0x68
    bool targetReached;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // protected System.Boolean canSearchAgain
    // Size: 0x1
    // Offset: 0x69
    bool canSearchAgain;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: canSearchAgain and: previousMovementOrigin
    char __padding17[0x2] = {};
    // protected UnityEngine.Vector3 previousMovementOrigin
    // Size: 0xC
    // Offset: 0x6C
    ::UnityEngine::Vector3 previousMovementOrigin;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // protected UnityEngine.Vector3 previousMovementDirection
    // Size: 0xC
    // Offset: 0x78
    ::UnityEngine::Vector3 previousMovementDirection;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // protected System.Single previousMovementStartTime
    // Size: 0x4
    // Offset: 0x84
    float previousMovementStartTime;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Boolean startHasRun
    // Size: 0x1
    // Offset: 0x88
    bool startHasRun;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    public:
    // Deleting conversion operator: operator ::System::IntPtr
    constexpr operator ::System::IntPtr() const noexcept = delete;
    // Get instance field reference: public System.Single repathRate
    [[deprecated("Use field access instead!")]] float& dyn_repathRate();
    // Get instance field reference: public UnityEngine.Transform target
    [[deprecated("Use field access instead!")]] ::UnityEngine::Transform*& dyn_target();
    // Get instance field reference: public System.Boolean canSearch
    [[deprecated("Use field access instead!")]] bool& dyn_canSearch();
    // Get instance field reference: public System.Boolean canMove
    [[deprecated("Use field access instead!")]] bool& dyn_canMove();
    // Get instance field reference: public System.Single speed
    [[deprecated("Use field access instead!")]] float& dyn_speed();
    // Get instance field reference: public System.Boolean enableRotation
    [[deprecated("Use field access instead!")]] bool& dyn_enableRotation();
    // Get instance field reference: public System.Boolean rotationIn2D
    [[deprecated("Use field access instead!")]] bool& dyn_rotationIn2D();
    // Get instance field reference: public System.Single rotationSpeed
    [[deprecated("Use field access instead!")]] float& dyn_rotationSpeed();
    // Get instance field reference: public System.Boolean interpolatePathSwitches
    [[deprecated("Use field access instead!")]] bool& dyn_interpolatePathSwitches();
    // Get instance field reference: public System.Single switchPathInterpolationSpeed
    [[deprecated("Use field access instead!")]] float& dyn_switchPathInterpolationSpeed();
    // Get instance field reference: protected Seeker seeker
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::Seeker*& dyn_seeker();
    // Get instance field reference: protected UnityEngine.Transform tr
    [[deprecated("Use field access instead!")]] ::UnityEngine::Transform*& dyn_tr();
    // Get instance field reference: protected System.Single lastRepath
    [[deprecated("Use field access instead!")]] float& dyn_lastRepath();
    // Get instance field reference: protected Pathfinding.ABPath path
    [[deprecated("Use field access instead!")]] ::Pathfinding::ABPath*& dyn_path();
    // Get instance field reference: protected System.Int32 currentWaypointIndex
    [[deprecated("Use field access instead!")]] int& dyn_currentWaypointIndex();
    // Get instance field reference: protected System.Single distanceAlongSegment
    [[deprecated("Use field access instead!")]] float& dyn_distanceAlongSegment();
    // Get instance field reference: private System.Boolean <targetReached>k__BackingField
    [[deprecated("Use field access instead!")]] bool& dyn_$targetReached$k__BackingField();
    // Get instance field reference: protected System.Boolean canSearchAgain
    [[deprecated("Use field access instead!")]] bool& dyn_canSearchAgain();
    // Get instance field reference: protected UnityEngine.Vector3 previousMovementOrigin
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_previousMovementOrigin();
    // Get instance field reference: protected UnityEngine.Vector3 previousMovementDirection
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_previousMovementDirection();
    // Get instance field reference: protected System.Single previousMovementStartTime
    [[deprecated("Use field access instead!")]] float& dyn_previousMovementStartTime();
    // Get instance field reference: private System.Boolean startHasRun
    [[deprecated("Use field access instead!")]] bool& dyn_startHasRun();
    // public System.Boolean get_targetReached()
    // Offset: 0xEF0194
    bool get_targetReached();
    // private System.Void set_targetReached(System.Boolean value)
    // Offset: 0xEF019C
    void set_targetReached(bool value);
    // protected System.Void Awake()
    // Offset: 0xEF01A8
    void Awake();
    // protected System.Void Start()
    // Offset: 0xEF026C
    void Start();
    // protected System.Void OnEnable()
    // Offset: 0xEF0280
    void OnEnable();
    // public System.Void OnDisable()
    // Offset: 0xEF0424
    void OnDisable();
    // protected System.Collections.IEnumerator RepeatTrySearchPath()
    // Offset: 0xEF03B0
    ::System::Collections::IEnumerator* RepeatTrySearchPath();
    // public System.Single TrySearchPath()
    // Offset: 0xEF05F4
    float TrySearchPath();
    // public System.Void SearchPath()
    // Offset: 0xEF06D8
    void SearchPath();
    // public System.Void ForceSearchPath()
    // Offset: 0xEF06E4
    void ForceSearchPath();
    // public System.Void OnTargetReached()
    // Offset: 0xEF08C0
    void OnTargetReached();
    // public System.Void OnPathComplete(Pathfinding.Path _p)
    // Offset: 0xEF08C4
    void OnPathComplete(::Pathfinding::Path* _p);
    // protected System.Void ConfigurePathSwitchInterpolation()
    // Offset: 0xEF0AC4
    void ConfigurePathSwitchInterpolation();
    // public UnityEngine.Vector3 GetFeetPosition()
    // Offset: 0xEF0FE8
    ::UnityEngine::Vector3 GetFeetPosition();
    // protected System.Void ConfigureNewPath()
    // Offset: 0xEF1018
    void ConfigureNewPath();
    // protected System.Void Update()
    // Offset: 0xEF1484
    void Update();
    // protected UnityEngine.Vector3 CalculateNextPosition(out UnityEngine.Vector3 direction)
    // Offset: 0xEF1754
    ::UnityEngine::Vector3 CalculateNextPosition(ByRef<::UnityEngine::Vector3> direction);
    // public System.Void .ctor()
    // Offset: 0xEF1CE8
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static AILerp* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::AILerp::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<AILerp*, creationType>()));
    }
    // private UnityEngine.Vector3 <Awake>b__25_0()
    // Offset: 0xEF1D38
    ::UnityEngine::Vector3 $Awake$b__25_0();
  }; // AILerp
  #pragma pack(pop)
  static check_size<sizeof(AILerp), 136 + sizeof(bool)> __GlobalNamespace_AILerpSizeCheck;
  static_assert(sizeof(AILerp) == 0x89);
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: GlobalNamespace::AILerp::get_targetReached
// Il2CppName: get_targetReached
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GlobalNamespace::AILerp::*)()>(&GlobalNamespace::AILerp::get_targetReached)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::AILerp*), "get_targetReached", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::AILerp::set_targetReached
// Il2CppName: set_targetReached
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::AILerp::*)(bool)>(&GlobalNamespace::AILerp::set_targetReached)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::AILerp*), "set_targetReached", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::AILerp::Awake
// Il2CppName: Awake
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::AILerp::*)()>(&GlobalNamespace::AILerp::Awake)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::AILerp*), "Awake", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::AILerp::Start
// Il2CppName: Start
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::AILerp::*)()>(&GlobalNamespace::AILerp::Start)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::AILerp*), "Start", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::AILerp::OnEnable
// Il2CppName: OnEnable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::AILerp::*)()>(&GlobalNamespace::AILerp::OnEnable)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::AILerp*), "OnEnable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::AILerp::OnDisable
// Il2CppName: OnDisable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::AILerp::*)()>(&GlobalNamespace::AILerp::OnDisable)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::AILerp*), "OnDisable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::AILerp::RepeatTrySearchPath
// Il2CppName: RepeatTrySearchPath
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Collections::IEnumerator* (GlobalNamespace::AILerp::*)()>(&GlobalNamespace::AILerp::RepeatTrySearchPath)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::AILerp*), "RepeatTrySearchPath", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::AILerp::TrySearchPath
// Il2CppName: TrySearchPath
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<float (GlobalNamespace::AILerp::*)()>(&GlobalNamespace::AILerp::TrySearchPath)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::AILerp*), "TrySearchPath", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::AILerp::SearchPath
// Il2CppName: SearchPath
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::AILerp::*)()>(&GlobalNamespace::AILerp::SearchPath)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::AILerp*), "SearchPath", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::AILerp::ForceSearchPath
// Il2CppName: ForceSearchPath
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::AILerp::*)()>(&GlobalNamespace::AILerp::ForceSearchPath)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::AILerp*), "ForceSearchPath", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::AILerp::OnTargetReached
// Il2CppName: OnTargetReached
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::AILerp::*)()>(&GlobalNamespace::AILerp::OnTargetReached)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::AILerp*), "OnTargetReached", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::AILerp::OnPathComplete
// Il2CppName: OnPathComplete
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::AILerp::*)(::Pathfinding::Path*)>(&GlobalNamespace::AILerp::OnPathComplete)> {
  static const MethodInfo* get() {
    static auto* _p = &::il2cpp_utils::GetClassFromName("Pathfinding", "Path")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::AILerp*), "OnPathComplete", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{_p});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::AILerp::ConfigurePathSwitchInterpolation
// Il2CppName: ConfigurePathSwitchInterpolation
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::AILerp::*)()>(&GlobalNamespace::AILerp::ConfigurePathSwitchInterpolation)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::AILerp*), "ConfigurePathSwitchInterpolation", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::AILerp::GetFeetPosition
// Il2CppName: GetFeetPosition
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Vector3 (GlobalNamespace::AILerp::*)()>(&GlobalNamespace::AILerp::GetFeetPosition)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::AILerp*), "GetFeetPosition", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::AILerp::ConfigureNewPath
// Il2CppName: ConfigureNewPath
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::AILerp::*)()>(&GlobalNamespace::AILerp::ConfigureNewPath)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::AILerp*), "ConfigureNewPath", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::AILerp::Update
// Il2CppName: Update
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::AILerp::*)()>(&GlobalNamespace::AILerp::Update)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::AILerp*), "Update", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::AILerp::CalculateNextPosition
// Il2CppName: CalculateNextPosition
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Vector3 (GlobalNamespace::AILerp::*)(ByRef<::UnityEngine::Vector3>)>(&GlobalNamespace::AILerp::CalculateNextPosition)> {
  static const MethodInfo* get() {
    static auto* direction = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::AILerp*), "CalculateNextPosition", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{direction});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::AILerp::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: GlobalNamespace::AILerp::$Awake$b__25_0
// Il2CppName: <Awake>b__25_0
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Vector3 (GlobalNamespace::AILerp::*)()>(&GlobalNamespace::AILerp::$Awake$b__25_0)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::AILerp*), "<Awake>b__25_0", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
