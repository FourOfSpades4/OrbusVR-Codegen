// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: System.Collections.Generic.IEnumerable`1
#include "System/Collections/Generic/IEnumerable_1.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
// Completed includes
// Begin forward declares
// Forward declaring namespace: System
namespace System {
  // Forward declaring type: EventHandler`1<TEventArgs>
  template<typename TEventArgs>
  class EventHandler_1;
}
// Forward declaring namespace: VivoxUnity
namespace VivoxUnity {
  // Forward declaring type: KeyEventArg`1<TK>
  template<typename TK>
  class KeyEventArg_1;
  // Forward declaring type: ValueEventArg`2<TK, TV>
  template<typename TK, typename TV>
  class ValueEventArg_2;
}
// Forward declaring namespace: System::Collections::Generic
namespace System::Collections::Generic {
  // Forward declaring type: ICollection`1<T>
  template<typename T>
  class ICollection_1;
}
// Completed forward declares
// Type namespace: VivoxUnity
namespace VivoxUnity {
  // Forward declaring type: IReadOnlyDictionary`2<TK, T>
  template<typename TK, typename T>
  class IReadOnlyDictionary_2;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE_GENERIC_CLASS(::VivoxUnity::IReadOnlyDictionary_2, "VivoxUnity", "IReadOnlyDictionary`2");
// Type namespace: VivoxUnity
namespace VivoxUnity {
  // WARNING Size may be invalid!
  // Autogenerated type: VivoxUnity.IReadOnlyDictionary`2
  // [TokenAttribute] Offset: FFFFFFFF
  // [DefaultMemberAttribute] Offset: ABCE80
  template<typename TK, typename T>
  class IReadOnlyDictionary_2/*, public ::System::Collections::Generic::IEnumerable_1<T>*/ {
    public:
    // Creating interface conversion operator: operator ::System::Collections::Generic::IEnumerable_1<T>
    operator ::System::Collections::Generic::IEnumerable_1<T>() noexcept {
      return *reinterpret_cast<::System::Collections::Generic::IEnumerable_1<T>*>(this);
    }
    // public System.Void add_AfterKeyAdded(System.EventHandler`1<VivoxUnity.KeyEventArg`1<TK>> value)
    // Offset: 0xFFFFFFFFFFFFFFFF
    void add_AfterKeyAdded(::System::EventHandler_1<::VivoxUnity::KeyEventArg_1<TK>*>* value) {
      static auto ___internal__logger = ::Logger::get().WithContext("::VivoxUnity::IReadOnlyDictionary_2::add_AfterKeyAdded");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(this, classof(::VivoxUnity::IReadOnlyDictionary_2<TK, T>*), -1)));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method, value);
    }
    // public System.Void remove_AfterKeyAdded(System.EventHandler`1<VivoxUnity.KeyEventArg`1<TK>> value)
    // Offset: 0xFFFFFFFFFFFFFFFF
    void remove_AfterKeyAdded(::System::EventHandler_1<::VivoxUnity::KeyEventArg_1<TK>*>* value) {
      static auto ___internal__logger = ::Logger::get().WithContext("::VivoxUnity::IReadOnlyDictionary_2::remove_AfterKeyAdded");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(this, classof(::VivoxUnity::IReadOnlyDictionary_2<TK, T>*), -1)));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method, value);
    }
    // public System.Void add_BeforeKeyRemoved(System.EventHandler`1<VivoxUnity.KeyEventArg`1<TK>> value)
    // Offset: 0xFFFFFFFFFFFFFFFF
    void add_BeforeKeyRemoved(::System::EventHandler_1<::VivoxUnity::KeyEventArg_1<TK>*>* value) {
      static auto ___internal__logger = ::Logger::get().WithContext("::VivoxUnity::IReadOnlyDictionary_2::add_BeforeKeyRemoved");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(this, classof(::VivoxUnity::IReadOnlyDictionary_2<TK, T>*), -1)));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method, value);
    }
    // public System.Void remove_BeforeKeyRemoved(System.EventHandler`1<VivoxUnity.KeyEventArg`1<TK>> value)
    // Offset: 0xFFFFFFFFFFFFFFFF
    void remove_BeforeKeyRemoved(::System::EventHandler_1<::VivoxUnity::KeyEventArg_1<TK>*>* value) {
      static auto ___internal__logger = ::Logger::get().WithContext("::VivoxUnity::IReadOnlyDictionary_2::remove_BeforeKeyRemoved");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(this, classof(::VivoxUnity::IReadOnlyDictionary_2<TK, T>*), -1)));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method, value);
    }
    // public System.Void add_AfterValueUpdated(System.EventHandler`1<VivoxUnity.ValueEventArg`2<TK,T>> value)
    // Offset: 0xFFFFFFFFFFFFFFFF
    void add_AfterValueUpdated(::System::EventHandler_1<::VivoxUnity::ValueEventArg_2<TK, T>*>* value) {
      static auto ___internal__logger = ::Logger::get().WithContext("::VivoxUnity::IReadOnlyDictionary_2::add_AfterValueUpdated");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(this, classof(::VivoxUnity::IReadOnlyDictionary_2<TK, T>*), -1)));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method, value);
    }
    // public System.Void remove_AfterValueUpdated(System.EventHandler`1<VivoxUnity.ValueEventArg`2<TK,T>> value)
    // Offset: 0xFFFFFFFFFFFFFFFF
    void remove_AfterValueUpdated(::System::EventHandler_1<::VivoxUnity::ValueEventArg_2<TK, T>*>* value) {
      static auto ___internal__logger = ::Logger::get().WithContext("::VivoxUnity::IReadOnlyDictionary_2::remove_AfterValueUpdated");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(this, classof(::VivoxUnity::IReadOnlyDictionary_2<TK, T>*), -1)));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method, value);
    }
    // public System.Collections.Generic.ICollection`1<TK> get_Keys()
    // Offset: 0xFFFFFFFFFFFFFFFF
    ::System::Collections::Generic::ICollection_1<TK>* get_Keys() {
      static auto ___internal__logger = ::Logger::get().WithContext("::VivoxUnity::IReadOnlyDictionary_2::get_Keys");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(this, classof(::VivoxUnity::IReadOnlyDictionary_2<TK, T>*), -1)));
      return ::il2cpp_utils::RunMethodRethrow<::System::Collections::Generic::ICollection_1<TK>*, false>(this, ___internal__method);
    }
    // public T get_Item(TK key)
    // Offset: 0xFFFFFFFFFFFFFFFF
    T get_Item(TK key) {
      static auto ___internal__logger = ::Logger::get().WithContext("::VivoxUnity::IReadOnlyDictionary_2::get_Item");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(this, classof(::VivoxUnity::IReadOnlyDictionary_2<TK, T>*), -1)));
      return ::il2cpp_utils::RunMethodRethrow<T, false>(this, ___internal__method, key);
    }
    // public System.Boolean ContainsKey(TK key)
    // Offset: 0xFFFFFFFFFFFFFFFF
    bool ContainsKey(TK key) {
      static auto ___internal__logger = ::Logger::get().WithContext("::VivoxUnity::IReadOnlyDictionary_2::ContainsKey");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(this, classof(::VivoxUnity::IReadOnlyDictionary_2<TK, T>*), -1)));
      return ::il2cpp_utils::RunMethodRethrow<bool, false>(this, ___internal__method, key);
    }
    // public System.Int32 get_Count()
    // Offset: 0xFFFFFFFFFFFFFFFF
    int get_Count() {
      static auto ___internal__logger = ::Logger::get().WithContext("::VivoxUnity::IReadOnlyDictionary_2::get_Count");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(this, classof(::VivoxUnity::IReadOnlyDictionary_2<TK, T>*), -1)));
      return ::il2cpp_utils::RunMethodRethrow<int, false>(this, ___internal__method);
    }
  }; // VivoxUnity.IReadOnlyDictionary`2
  // Could not write size check! Type: VivoxUnity.IReadOnlyDictionary`2 is generic, or has no fields that are valid for size checks!
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
