// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: Xefier.Threading.Tasks.TaskBase
#include "Xefier/Threading/Tasks/TaskBase.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: Xefier::Threading::Tasks
namespace Xefier::Threading::Tasks {
  // Skipping declaration: ITask because it is already included!
  // Forward declaring type: ITask`1<TResult>
  template<typename TResult>
  class ITask_1;
}
// Forward declaring namespace: System::Threading
namespace System::Threading {
  // Forward declaring type: ManualResetEvent
  class ManualResetEvent;
  // Forward declaring type: WaitHandle
  class WaitHandle;
}
// Forward declaring namespace: System
namespace System {
  // Forward declaring type: Action
  class Action;
}
// Forward declaring namespace: System::Collections::Generic
namespace System::Collections::Generic {
  // Forward declaring type: IEnumerable`1<T>
  template<typename T>
  class IEnumerable_1;
}
// Completed forward declares
// Type namespace: Xefier.Threading.Tasks
namespace Xefier::Threading::Tasks {
  // Forward declaring type: Task
  class Task;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::Xefier::Threading::Tasks::Task);
DEFINE_IL2CPP_ARG_TYPE(::Xefier::Threading::Tasks::Task*, "Xefier.Threading.Tasks", "Task");
// Type namespace: Xefier.Threading.Tasks
namespace Xefier::Threading::Tasks {
  // Size: 0x38
  #pragma pack(push, 1)
  // Autogenerated type: Xefier.Threading.Tasks.Task
  // [TokenAttribute] Offset: FFFFFFFF
  class Task : public ::Xefier::Threading::Tasks::TaskBase {
    public:
    // Nested type: ::Xefier::Threading::Tasks::Task::$$c__DisplayClass4_0
    class $$c__DisplayClass4_0;
    // Nested type: ::Xefier::Threading::Tasks::Task::$$c__DisplayClass5_0
    class $$c__DisplayClass5_0;
    public:
    // private System.Threading.ManualResetEvent waitHandle
    // Size: 0x8
    // Offset: 0x30
    ::System::Threading::ManualResetEvent* waitHandle;
    // Field size check
    static_assert(sizeof(::System::Threading::ManualResetEvent*) == 0x8);
    public:
    // Creating conversion operator: operator ::System::Threading::ManualResetEvent*
    constexpr operator ::System::Threading::ManualResetEvent*() const noexcept {
      return waitHandle;
    }
    // Get instance field reference: private System.Threading.ManualResetEvent waitHandle
    [[deprecated("Use field access instead!")]] ::System::Threading::ManualResetEvent*& dyn_waitHandle();
    // static public Xefier.Threading.Tasks.ITask Run(System.Action action)
    // Offset: 0x28A2804
    static ::Xefier::Threading::Tasks::ITask* Run(::System::Action* action);
    // static public Xefier.Threading.Tasks.ITask WhenAll(System.Collections.Generic.IEnumerable`1<Xefier.Threading.Tasks.ITask> tasks)
    // Offset: 0x28A290C
    static ::Xefier::Threading::Tasks::ITask* WhenAll(::System::Collections::Generic::IEnumerable_1<::Xefier::Threading::Tasks::ITask*>* tasks);
    // static public Xefier.Threading.Tasks.ITask`1<Xefier.Threading.Tasks.ITask> WhenAny(System.Collections.Generic.IEnumerable`1<Xefier.Threading.Tasks.ITask> tasks)
    // Offset: 0x28A29C8
    static ::Xefier::Threading::Tasks::ITask_1<::Xefier::Threading::Tasks::ITask*>* WhenAny(::System::Collections::Generic::IEnumerable_1<::Xefier::Threading::Tasks::ITask*>* tasks);
    // static public System.Void WaitAll(System.Collections.Generic.IEnumerable`1<Xefier.Threading.Tasks.ITask> tasks)
    // Offset: 0x28A2AD8
    static void WaitAll(::System::Collections::Generic::IEnumerable_1<::Xefier::Threading::Tasks::ITask*>* tasks);
    // static public System.Int32 WaitAny(System.Collections.Generic.IEnumerable`1<Xefier.Threading.Tasks.ITask> tasks)
    // Offset: 0x28A2B94
    static int WaitAny(::System::Collections::Generic::IEnumerable_1<::Xefier::Threading::Tasks::ITask*>* tasks);
    // public System.Void .ctor(System.Action action)
    // Offset: 0x28A2884
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static Task* New_ctor(::System::Action* action) {
      static auto ___internal__logger = ::Logger::get().WithContext("::Xefier::Threading::Tasks::Task::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<Task*, creationType>(action)));
    }
    // protected System.Void .ctor()
    // Offset: 0x28A2D04
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static Task* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::Xefier::Threading::Tasks::Task::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<Task*, creationType>()));
    }
    // private System.Void ThreadRun(System.Object state)
    // Offset: 0x28A2E3C
    void ThreadRun(::Il2CppObject* state);
    // static private System.Threading.WaitHandle[] GetWaitHandles(System.Collections.Generic.IEnumerable`1<Xefier.Threading.Tasks.ITask> tasks)
    // Offset: 0x28A3014
    static ::ArrayW<::System::Threading::WaitHandle*> GetWaitHandles(::System::Collections::Generic::IEnumerable_1<::Xefier::Threading::Tasks::ITask*>* tasks);
    // public override System.Threading.WaitHandle get_AsyncWaitHandle()
    // Offset: 0x28A27FC
    // Implemented from: Xefier.Threading.Tasks.TaskBase
    // Base method: System.Threading.WaitHandle TaskBase::get_AsyncWaitHandle()
    ::System::Threading::WaitHandle* get_AsyncWaitHandle();
    // public override System.Void Start()
    // Offset: 0x28A2D70
    // Implemented from: Xefier.Threading.Tasks.TaskBase
    // Base method: System.Void TaskBase::Start()
    void Start();
    // public override System.Void Wait()
    // Offset: 0x28A2E08
    // Implemented from: Xefier.Threading.Tasks.TaskBase
    // Base method: System.Void TaskBase::Wait()
    void Wait();
  }; // Xefier.Threading.Tasks.Task
  #pragma pack(pop)
  static check_size<sizeof(Task), 48 + sizeof(::System::Threading::ManualResetEvent*)> __Xefier_Threading_Tasks_TaskSizeCheck;
  static_assert(sizeof(Task) == 0x38);
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: Xefier::Threading::Tasks::Task::Run
// Il2CppName: Run
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Xefier::Threading::Tasks::ITask* (*)(::System::Action*)>(&Xefier::Threading::Tasks::Task::Run)> {
  static const MethodInfo* get() {
    static auto* action = &::il2cpp_utils::GetClassFromName("System", "Action")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Xefier::Threading::Tasks::Task*), "Run", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{action});
  }
};
// Writing MetadataGetter for method: Xefier::Threading::Tasks::Task::WhenAll
// Il2CppName: WhenAll
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Xefier::Threading::Tasks::ITask* (*)(::System::Collections::Generic::IEnumerable_1<::Xefier::Threading::Tasks::ITask*>*)>(&Xefier::Threading::Tasks::Task::WhenAll)> {
  static const MethodInfo* get() {
    static auto* tasks = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "IEnumerable`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Xefier.Threading.Tasks", "ITask")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Xefier::Threading::Tasks::Task*), "WhenAll", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{tasks});
  }
};
// Writing MetadataGetter for method: Xefier::Threading::Tasks::Task::WhenAny
// Il2CppName: WhenAny
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Xefier::Threading::Tasks::ITask_1<::Xefier::Threading::Tasks::ITask*>* (*)(::System::Collections::Generic::IEnumerable_1<::Xefier::Threading::Tasks::ITask*>*)>(&Xefier::Threading::Tasks::Task::WhenAny)> {
  static const MethodInfo* get() {
    static auto* tasks = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "IEnumerable`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Xefier.Threading.Tasks", "ITask")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Xefier::Threading::Tasks::Task*), "WhenAny", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{tasks});
  }
};
// Writing MetadataGetter for method: Xefier::Threading::Tasks::Task::WaitAll
// Il2CppName: WaitAll
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(::System::Collections::Generic::IEnumerable_1<::Xefier::Threading::Tasks::ITask*>*)>(&Xefier::Threading::Tasks::Task::WaitAll)> {
  static const MethodInfo* get() {
    static auto* tasks = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "IEnumerable`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Xefier.Threading.Tasks", "ITask")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Xefier::Threading::Tasks::Task*), "WaitAll", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{tasks});
  }
};
// Writing MetadataGetter for method: Xefier::Threading::Tasks::Task::WaitAny
// Il2CppName: WaitAny
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (*)(::System::Collections::Generic::IEnumerable_1<::Xefier::Threading::Tasks::ITask*>*)>(&Xefier::Threading::Tasks::Task::WaitAny)> {
  static const MethodInfo* get() {
    static auto* tasks = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "IEnumerable`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Xefier.Threading.Tasks", "ITask")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Xefier::Threading::Tasks::Task*), "WaitAny", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{tasks});
  }
};
// Writing MetadataGetter for method: Xefier::Threading::Tasks::Task::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: Xefier::Threading::Tasks::Task::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: Xefier::Threading::Tasks::Task::ThreadRun
// Il2CppName: ThreadRun
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Xefier::Threading::Tasks::Task::*)(::Il2CppObject*)>(&Xefier::Threading::Tasks::Task::ThreadRun)> {
  static const MethodInfo* get() {
    static auto* state = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Xefier::Threading::Tasks::Task*), "ThreadRun", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{state});
  }
};
// Writing MetadataGetter for method: Xefier::Threading::Tasks::Task::GetWaitHandles
// Il2CppName: GetWaitHandles
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::ArrayW<::System::Threading::WaitHandle*> (*)(::System::Collections::Generic::IEnumerable_1<::Xefier::Threading::Tasks::ITask*>*)>(&Xefier::Threading::Tasks::Task::GetWaitHandles)> {
  static const MethodInfo* get() {
    static auto* tasks = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "IEnumerable`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Xefier.Threading.Tasks", "ITask")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Xefier::Threading::Tasks::Task*), "GetWaitHandles", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{tasks});
  }
};
// Writing MetadataGetter for method: Xefier::Threading::Tasks::Task::get_AsyncWaitHandle
// Il2CppName: get_AsyncWaitHandle
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Threading::WaitHandle* (Xefier::Threading::Tasks::Task::*)()>(&Xefier::Threading::Tasks::Task::get_AsyncWaitHandle)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Xefier::Threading::Tasks::Task*), "get_AsyncWaitHandle", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Xefier::Threading::Tasks::Task::Start
// Il2CppName: Start
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Xefier::Threading::Tasks::Task::*)()>(&Xefier::Threading::Tasks::Task::Start)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Xefier::Threading::Tasks::Task*), "Start", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Xefier::Threading::Tasks::Task::Wait
// Il2CppName: Wait
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Xefier::Threading::Tasks::Task::*)()>(&Xefier::Threading::Tasks::Task::Wait)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Xefier::Threading::Tasks::Task*), "Wait", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
