// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: UnityEngine.MonoBehaviour
#include "UnityEngine/MonoBehaviour.hpp"
// Including type: HighlightPlus.SkinnedMeshBakeMode
#include "HighlightPlus/SkinnedMeshBakeMode.hpp"
// Including type: UnityEngine.Color
#include "UnityEngine/Color.hpp"
// Including type: HighlightPlus.GlowPassData
#include "HighlightPlus/GlowPassData.hpp"
// Including type: HighlightPlus.SeeThroughMode
#include "HighlightPlus/SeeThroughMode.hpp"
// Including type: UnityEngine.Bounds
#include "UnityEngine/Bounds.hpp"
// Including type: UnityEngine.Matrix4x4
#include "UnityEngine/Matrix4x4.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
#include "beatsaber-hook/shared/utils/typedefs-string.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: Transform
  class Transform;
  // Forward declaring type: Coroutine
  class Coroutine;
  // Forward declaring type: Material
  class Material;
  // Forward declaring type: Mesh
  class Mesh;
  // Forward declaring type: Renderer
  class Renderer;
  // Forward declaring type: SkinnedMeshRenderer
  class SkinnedMeshRenderer;
}
// Forward declaring namespace: HighlightPlus
namespace HighlightPlus {
  // Forward declaring type: HighlightProfile
  class HighlightProfile;
  // Forward declaring type: OnObjectHighlightStartEvent
  class OnObjectHighlightStartEvent;
  // Forward declaring type: OnObjectHighlightEndEvent
  class OnObjectHighlightEndEvent;
  // Forward declaring type: OnRendererHighlightEvent
  class OnRendererHighlightEvent;
}
// Forward declaring namespace: System
namespace System {
  // Forward declaring type: String
  class String;
}
// Forward declaring namespace: System::Collections
namespace System::Collections {
  // Forward declaring type: IEnumerator
  class IEnumerator;
}
// Completed forward declares
// Type namespace: HighlightPlus
namespace HighlightPlus {
  // Forward declaring type: HighlightEffect
  class HighlightEffect;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::HighlightPlus::HighlightEffect);
DEFINE_IL2CPP_ARG_TYPE(::HighlightPlus::HighlightEffect*, "HighlightPlus", "HighlightEffect");
// Type namespace: HighlightPlus
namespace HighlightPlus {
  // Size: 0x148
  #pragma pack(push, 1)
  // Autogenerated type: HighlightPlus.HighlightEffect
  // [TokenAttribute] Offset: FFFFFFFF
  // [ExecuteInEditMode] Offset: FFFFFFFF
  // [HelpURLAttribute] Offset: AD219C
  class HighlightEffect : public ::UnityEngine::MonoBehaviour {
    public:
    // Nested type: ::HighlightPlus::HighlightEffect::ModelMaterials
    struct ModelMaterials;
    // Nested type: ::HighlightPlus::HighlightEffect::FadingState
    struct FadingState;
    // Nested type: ::HighlightPlus::HighlightEffect::$OverlayOneShotAnimator$d__94
    class $OverlayOneShotAnimator$d__94;
    // Size: 0xE9
    #pragma pack(push, 1)
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: HighlightPlus.HighlightEffect/ModelMaterials
    // [TokenAttribute] Offset: FFFFFFFF
    struct ModelMaterials/*, public ::System::ValueType*/ {
      public:
      public:
      // public UnityEngine.Transform transform
      // Size: 0x8
      // Offset: 0x0
      ::UnityEngine::Transform* transform;
      // Field size check
      static_assert(sizeof(::UnityEngine::Transform*) == 0x8);
      // public System.Boolean bakedTransform
      // Size: 0x1
      // Offset: 0x8
      bool bakedTransform;
      // Field size check
      static_assert(sizeof(bool) == 0x1);
      // Padding between fields: bakedTransform and: currentPosition
      char __padding1[0x3] = {};
      // public UnityEngine.Vector3 currentPosition
      // Size: 0xC
      // Offset: 0xC
      ::UnityEngine::Vector3 currentPosition;
      // Field size check
      static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
      // public UnityEngine.Vector3 currentRotation
      // Size: 0xC
      // Offset: 0x18
      ::UnityEngine::Vector3 currentRotation;
      // Field size check
      static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
      // public UnityEngine.Vector3 currentScale
      // Size: 0xC
      // Offset: 0x24
      ::UnityEngine::Vector3 currentScale;
      // Field size check
      static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
      // public System.Boolean currentRenderIsVisible
      // Size: 0x1
      // Offset: 0x30
      bool currentRenderIsVisible;
      // Field size check
      static_assert(sizeof(bool) == 0x1);
      // Padding between fields: currentRenderIsVisible and: mesh
      char __padding5[0x7] = {};
      // public UnityEngine.Mesh mesh
      // Size: 0x8
      // Offset: 0x38
      ::UnityEngine::Mesh* mesh;
      // Field size check
      static_assert(sizeof(::UnityEngine::Mesh*) == 0x8);
      // public UnityEngine.Mesh originalMesh
      // Size: 0x8
      // Offset: 0x40
      ::UnityEngine::Mesh* originalMesh;
      // Field size check
      static_assert(sizeof(::UnityEngine::Mesh*) == 0x8);
      // public UnityEngine.Renderer renderer
      // Size: 0x8
      // Offset: 0x48
      ::UnityEngine::Renderer* renderer;
      // Field size check
      static_assert(sizeof(::UnityEngine::Renderer*) == 0x8);
      // public UnityEngine.SkinnedMeshRenderer skinnedMeshRenderer
      // Size: 0x8
      // Offset: 0x50
      ::UnityEngine::SkinnedMeshRenderer* skinnedMeshRenderer;
      // Field size check
      static_assert(sizeof(::UnityEngine::SkinnedMeshRenderer*) == 0x8);
      // public UnityEngine.Bounds skinnedMeshLastBounds
      // Size: 0x18
      // Offset: 0x58
      ::UnityEngine::Bounds skinnedMeshLastBounds;
      // Field size check
      static_assert(sizeof(::UnityEngine::Bounds) == 0x18);
      // public UnityEngine.Material material
      // Size: 0x8
      // Offset: 0x70
      ::UnityEngine::Material* material;
      // Field size check
      static_assert(sizeof(::UnityEngine::Material*) == 0x8);
      // public UnityEngine.Material fxMatGlow
      // Size: 0x8
      // Offset: 0x78
      ::UnityEngine::Material* fxMatGlow;
      // Field size check
      static_assert(sizeof(::UnityEngine::Material*) == 0x8);
      // public UnityEngine.Material fxMatInnerGlow
      // Size: 0x8
      // Offset: 0x80
      ::UnityEngine::Material* fxMatInnerGlow;
      // Field size check
      static_assert(sizeof(::UnityEngine::Material*) == 0x8);
      // public UnityEngine.Material fxMatOutline
      // Size: 0x8
      // Offset: 0x88
      ::UnityEngine::Material* fxMatOutline;
      // Field size check
      static_assert(sizeof(::UnityEngine::Material*) == 0x8);
      // public UnityEngine.Material[] fxMatSeeThrough
      // Size: 0x8
      // Offset: 0x90
      ::ArrayW<::UnityEngine::Material*> fxMatSeeThrough;
      // Field size check
      static_assert(sizeof(::ArrayW<::UnityEngine::Material*>) == 0x8);
      // public UnityEngine.Material[] fxMatOverlay
      // Size: 0x8
      // Offset: 0x98
      ::ArrayW<::UnityEngine::Material*> fxMatOverlay;
      // Field size check
      static_assert(sizeof(::ArrayW<::UnityEngine::Material*>) == 0x8);
      // public UnityEngine.Mesh renderingMesh
      // Size: 0x8
      // Offset: 0xA0
      ::UnityEngine::Mesh* renderingMesh;
      // Field size check
      static_assert(sizeof(::UnityEngine::Mesh*) == 0x8);
      // public UnityEngine.Matrix4x4 renderingMatrix
      // Size: 0x40
      // Offset: 0xA8
      ::UnityEngine::Matrix4x4 renderingMatrix;
      // Field size check
      static_assert(sizeof(::UnityEngine::Matrix4x4) == 0x40);
      // public System.Boolean cloth
      // Size: 0x1
      // Offset: 0xE8
      bool cloth;
      // Field size check
      static_assert(sizeof(bool) == 0x1);
      public:
      // Creating value type constructor for type: ModelMaterials
      constexpr ModelMaterials(::UnityEngine::Transform* transform_ = {}, bool bakedTransform_ = {}, ::UnityEngine::Vector3 currentPosition_ = {}, ::UnityEngine::Vector3 currentRotation_ = {}, ::UnityEngine::Vector3 currentScale_ = {}, bool currentRenderIsVisible_ = {}, ::UnityEngine::Mesh* mesh_ = {}, ::UnityEngine::Mesh* originalMesh_ = {}, ::UnityEngine::Renderer* renderer_ = {}, ::UnityEngine::SkinnedMeshRenderer* skinnedMeshRenderer_ = {}, ::UnityEngine::Bounds skinnedMeshLastBounds_ = {}, ::UnityEngine::Material* material_ = {}, ::UnityEngine::Material* fxMatGlow_ = {}, ::UnityEngine::Material* fxMatInnerGlow_ = {}, ::UnityEngine::Material* fxMatOutline_ = {}, ::ArrayW<::UnityEngine::Material*> fxMatSeeThrough_ = ::ArrayW<::UnityEngine::Material*>(static_cast<void*>(nullptr)), ::ArrayW<::UnityEngine::Material*> fxMatOverlay_ = ::ArrayW<::UnityEngine::Material*>(static_cast<void*>(nullptr)), ::UnityEngine::Mesh* renderingMesh_ = {}, ::UnityEngine::Matrix4x4 renderingMatrix_ = {}, bool cloth_ = {}) noexcept : transform{transform_}, bakedTransform{bakedTransform_}, currentPosition{currentPosition_}, currentRotation{currentRotation_}, currentScale{currentScale_}, currentRenderIsVisible{currentRenderIsVisible_}, mesh{mesh_}, originalMesh{originalMesh_}, renderer{renderer_}, skinnedMeshRenderer{skinnedMeshRenderer_}, skinnedMeshLastBounds{skinnedMeshLastBounds_}, material{material_}, fxMatGlow{fxMatGlow_}, fxMatInnerGlow{fxMatInnerGlow_}, fxMatOutline{fxMatOutline_}, fxMatSeeThrough{fxMatSeeThrough_}, fxMatOverlay{fxMatOverlay_}, renderingMesh{renderingMesh_}, renderingMatrix{renderingMatrix_}, cloth{cloth_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Get instance field reference: public UnityEngine.Transform transform
      [[deprecated("Use field access instead!")]] ::UnityEngine::Transform*& dyn_transform();
      // Get instance field reference: public System.Boolean bakedTransform
      [[deprecated("Use field access instead!")]] bool& dyn_bakedTransform();
      // Get instance field reference: public UnityEngine.Vector3 currentPosition
      [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_currentPosition();
      // Get instance field reference: public UnityEngine.Vector3 currentRotation
      [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_currentRotation();
      // Get instance field reference: public UnityEngine.Vector3 currentScale
      [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_currentScale();
      // Get instance field reference: public System.Boolean currentRenderIsVisible
      [[deprecated("Use field access instead!")]] bool& dyn_currentRenderIsVisible();
      // Get instance field reference: public UnityEngine.Mesh mesh
      [[deprecated("Use field access instead!")]] ::UnityEngine::Mesh*& dyn_mesh();
      // Get instance field reference: public UnityEngine.Mesh originalMesh
      [[deprecated("Use field access instead!")]] ::UnityEngine::Mesh*& dyn_originalMesh();
      // Get instance field reference: public UnityEngine.Renderer renderer
      [[deprecated("Use field access instead!")]] ::UnityEngine::Renderer*& dyn_renderer();
      // Get instance field reference: public UnityEngine.SkinnedMeshRenderer skinnedMeshRenderer
      [[deprecated("Use field access instead!")]] ::UnityEngine::SkinnedMeshRenderer*& dyn_skinnedMeshRenderer();
      // Get instance field reference: public UnityEngine.Bounds skinnedMeshLastBounds
      [[deprecated("Use field access instead!")]] ::UnityEngine::Bounds& dyn_skinnedMeshLastBounds();
      // Get instance field reference: public UnityEngine.Material material
      [[deprecated("Use field access instead!")]] ::UnityEngine::Material*& dyn_material();
      // Get instance field reference: public UnityEngine.Material fxMatGlow
      [[deprecated("Use field access instead!")]] ::UnityEngine::Material*& dyn_fxMatGlow();
      // Get instance field reference: public UnityEngine.Material fxMatInnerGlow
      [[deprecated("Use field access instead!")]] ::UnityEngine::Material*& dyn_fxMatInnerGlow();
      // Get instance field reference: public UnityEngine.Material fxMatOutline
      [[deprecated("Use field access instead!")]] ::UnityEngine::Material*& dyn_fxMatOutline();
      // Get instance field reference: public UnityEngine.Material[] fxMatSeeThrough
      [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::Material*>& dyn_fxMatSeeThrough();
      // Get instance field reference: public UnityEngine.Material[] fxMatOverlay
      [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::Material*>& dyn_fxMatOverlay();
      // Get instance field reference: public UnityEngine.Mesh renderingMesh
      [[deprecated("Use field access instead!")]] ::UnityEngine::Mesh*& dyn_renderingMesh();
      // Get instance field reference: public UnityEngine.Matrix4x4 renderingMatrix
      [[deprecated("Use field access instead!")]] ::UnityEngine::Matrix4x4& dyn_renderingMatrix();
      // Get instance field reference: public System.Boolean cloth
      [[deprecated("Use field access instead!")]] bool& dyn_cloth();
    }; // HighlightPlus.HighlightEffect/ModelMaterials
    #pragma pack(pop)
    static check_size<sizeof(HighlightEffect::ModelMaterials), 232 + sizeof(bool)> __HighlightPlus_HighlightEffect_ModelMaterialsSizeCheck;
    static_assert(sizeof(HighlightEffect::ModelMaterials) == 0xE9);
    // Size: 0x4
    #pragma pack(push, 1)
    // Autogenerated type: HighlightPlus.HighlightEffect/FadingState
    // [TokenAttribute] Offset: FFFFFFFF
    struct FadingState/*, public ::System::Enum*/ {
      public:
      public:
      // public System.Int32 value__
      // Size: 0x4
      // Offset: 0x0
      int value;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      public:
      // Creating value type constructor for type: FadingState
      constexpr FadingState(int value_ = {}) noexcept : value{value_} {}
      // Creating interface conversion operator: operator ::System::Enum
      operator ::System::Enum() noexcept {
        return *reinterpret_cast<::System::Enum*>(this);
      }
      // Creating conversion operator: operator int
      constexpr operator int() const noexcept {
        return value;
      }
      // static field const value: static public HighlightPlus.HighlightEffect/FadingState FadingOut
      static constexpr const int FadingOut = -1;
      // Get static field: static public HighlightPlus.HighlightEffect/FadingState FadingOut
      static ::HighlightPlus::HighlightEffect::FadingState _get_FadingOut();
      // Set static field: static public HighlightPlus.HighlightEffect/FadingState FadingOut
      static void _set_FadingOut(::HighlightPlus::HighlightEffect::FadingState value);
      // static field const value: static public HighlightPlus.HighlightEffect/FadingState NoFading
      static constexpr const int NoFading = 0;
      // Get static field: static public HighlightPlus.HighlightEffect/FadingState NoFading
      static ::HighlightPlus::HighlightEffect::FadingState _get_NoFading();
      // Set static field: static public HighlightPlus.HighlightEffect/FadingState NoFading
      static void _set_NoFading(::HighlightPlus::HighlightEffect::FadingState value);
      // static field const value: static public HighlightPlus.HighlightEffect/FadingState FadingIn
      static constexpr const int FadingIn = 1;
      // Get static field: static public HighlightPlus.HighlightEffect/FadingState FadingIn
      static ::HighlightPlus::HighlightEffect::FadingState _get_FadingIn();
      // Set static field: static public HighlightPlus.HighlightEffect/FadingState FadingIn
      static void _set_FadingIn(::HighlightPlus::HighlightEffect::FadingState value);
      // Get instance field reference: public System.Int32 value__
      [[deprecated("Use field access instead!")]] int& dyn_value__();
    }; // HighlightPlus.HighlightEffect/FadingState
    #pragma pack(pop)
    static check_size<sizeof(HighlightEffect::FadingState), 0 + sizeof(int)> __HighlightPlus_HighlightEffect_FadingStateSizeCheck;
    static_assert(sizeof(HighlightEffect::FadingState) == 0x4);
    public:
    // public HighlightPlus.HighlightProfile profile
    // Size: 0x8
    // Offset: 0x18
    ::HighlightPlus::HighlightProfile* profile;
    // Field size check
    static_assert(sizeof(::HighlightPlus::HighlightProfile*) == 0x8);
    // [TooltipAttribute] Offset: 0xAE13FC
    // public System.Boolean profileSync
    // Size: 0x1
    // Offset: 0x20
    bool profileSync;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Boolean previewInEditor
    // Size: 0x1
    // Offset: 0x21
    bool previewInEditor;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // [TooltipAttribute] Offset: 0xAE1434
    // public System.Boolean ignoreObjectVisibility
    // Size: 0x1
    // Offset: 0x22
    bool ignoreObjectVisibility;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: ignoreObjectVisibility and: skinnedMeshBakeMode
    char __padding3[0x1] = {};
    // [TooltipAttribute] Offset: 0xAE146C
    // public HighlightPlus.SkinnedMeshBakeMode skinnedMeshBakeMode
    // Size: 0x4
    // Offset: 0x24
    ::HighlightPlus::SkinnedMeshBakeMode skinnedMeshBakeMode;
    // Field size check
    static_assert(sizeof(::HighlightPlus::SkinnedMeshBakeMode) == 0x4);
    // [TooltipAttribute] Offset: 0xAE14A4
    // public System.Boolean ignore
    // Size: 0x1
    // Offset: 0x28
    bool ignore;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Boolean _highlighted
    // Size: 0x1
    // Offset: 0x29
    bool highlighted;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: highlighted and: fadeInDuration
    char __padding6[0x2] = {};
    // public System.Single fadeInDuration
    // Size: 0x4
    // Offset: 0x2C
    float fadeInDuration;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single fadeOutDuration
    // Size: 0x4
    // Offset: 0x30
    float fadeOutDuration;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // [RangeAttribute] Offset: 0xAE14EC
    // public System.Single overlay
    // Size: 0x4
    // Offset: 0x34
    float overlay;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public UnityEngine.Color overlayColor
    // Size: 0x10
    // Offset: 0x38
    ::UnityEngine::Color overlayColor;
    // Field size check
    static_assert(sizeof(::UnityEngine::Color) == 0x10);
    // public System.Single overlayAnimationSpeed
    // Size: 0x4
    // Offset: 0x48
    float overlayAnimationSpeed;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // [RangeAttribute] Offset: 0xAE1504
    // public System.Single overlayMinIntensity
    // Size: 0x4
    // Offset: 0x4C
    float overlayMinIntensity;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // [RangeAttribute] Offset: 0xAE151C
    // public System.Single overlayBlending
    // Size: 0x4
    // Offset: 0x50
    float overlayBlending;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // [RangeAttribute] Offset: 0xAE1534
    // public System.Single outline
    // Size: 0x4
    // Offset: 0x54
    float outline;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public UnityEngine.Color outlineColor
    // Size: 0x10
    // Offset: 0x58
    ::UnityEngine::Color outlineColor;
    // Field size check
    static_assert(sizeof(::UnityEngine::Color) == 0x10);
    // public System.Single outlineWidth
    // Size: 0x4
    // Offset: 0x68
    float outlineWidth;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Boolean outlineHQ
    // Size: 0x1
    // Offset: 0x6C
    bool outlineHQ;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Boolean outlineAlwaysOnTop
    // Size: 0x1
    // Offset: 0x6D
    bool outlineAlwaysOnTop;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: outlineAlwaysOnTop and: glow
    char __padding18[0x2] = {};
    // [RangeAttribute] Offset: 0xAE154C
    // public System.Single glow
    // Size: 0x4
    // Offset: 0x70
    float glow;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single glowWidth
    // Size: 0x4
    // Offset: 0x74
    float glowWidth;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Boolean glowHQ
    // Size: 0x1
    // Offset: 0x78
    bool glowHQ;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Boolean glowDithering
    // Size: 0x1
    // Offset: 0x79
    bool glowDithering;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: glowDithering and: glowMagicNumber1
    char __padding22[0x2] = {};
    // public System.Single glowMagicNumber1
    // Size: 0x4
    // Offset: 0x7C
    float glowMagicNumber1;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single glowMagicNumber2
    // Size: 0x4
    // Offset: 0x80
    float glowMagicNumber2;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single glowAnimationSpeed
    // Size: 0x4
    // Offset: 0x84
    float glowAnimationSpeed;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Boolean glowAlwaysOnTop
    // Size: 0x1
    // Offset: 0x88
    bool glowAlwaysOnTop;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: glowAlwaysOnTop and: glowPasses
    char __padding26[0x7] = {};
    // public HighlightPlus.GlowPassData[] glowPasses
    // Size: 0x8
    // Offset: 0x90
    ::ArrayW<::HighlightPlus::GlowPassData> glowPasses;
    // Field size check
    static_assert(sizeof(::ArrayW<::HighlightPlus::GlowPassData>) == 0x8);
    // [RangeAttribute] Offset: 0xAE1564
    // public System.Single innerGlow
    // Size: 0x4
    // Offset: 0x98
    float innerGlow;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // [RangeAttribute] Offset: 0xAE157C
    // public System.Single innerGlowWidth
    // Size: 0x4
    // Offset: 0x9C
    float innerGlowWidth;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public UnityEngine.Color innerGlowColor
    // Size: 0x10
    // Offset: 0xA0
    ::UnityEngine::Color innerGlowColor;
    // Field size check
    static_assert(sizeof(::UnityEngine::Color) == 0x10);
    // public System.Boolean innerGlowAlwaysOnTop
    // Size: 0x1
    // Offset: 0xB0
    bool innerGlowAlwaysOnTop;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: innerGlowAlwaysOnTop and: OnObjectHighlightStart
    char __padding31[0x7] = {};
    // [CompilerGeneratedAttribute] Offset: 0xAE1594
    // private HighlightPlus.OnObjectHighlightStartEvent OnObjectHighlightStart
    // Size: 0x8
    // Offset: 0xB8
    ::HighlightPlus::OnObjectHighlightStartEvent* OnObjectHighlightStart;
    // Field size check
    static_assert(sizeof(::HighlightPlus::OnObjectHighlightStartEvent*) == 0x8);
    // [CompilerGeneratedAttribute] Offset: 0xAE15A4
    // private HighlightPlus.OnObjectHighlightEndEvent OnObjectHighlightEnd
    // Size: 0x8
    // Offset: 0xC0
    ::HighlightPlus::OnObjectHighlightEndEvent* OnObjectHighlightEnd;
    // Field size check
    static_assert(sizeof(::HighlightPlus::OnObjectHighlightEndEvent*) == 0x8);
    // [CompilerGeneratedAttribute] Offset: 0xAE15B4
    // private HighlightPlus.OnRendererHighlightEvent OnRendererHighlightStart
    // Size: 0x8
    // Offset: 0xC8
    ::HighlightPlus::OnRendererHighlightEvent* OnRendererHighlightStart;
    // Field size check
    static_assert(sizeof(::HighlightPlus::OnRendererHighlightEvent*) == 0x8);
    // public HighlightPlus.SeeThroughMode seeThrough
    // Size: 0x4
    // Offset: 0xD0
    ::HighlightPlus::SeeThroughMode seeThrough;
    // Field size check
    static_assert(sizeof(::HighlightPlus::SeeThroughMode) == 0x4);
    // [RangeAttribute] Offset: 0xAE15C4
    // public System.Single seeThroughIntensity
    // Size: 0x4
    // Offset: 0xD4
    float seeThroughIntensity;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // [RangeAttribute] Offset: 0xAE15DC
    // public System.Single seeThroughTintAlpha
    // Size: 0x4
    // Offset: 0xD8
    float seeThroughTintAlpha;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public UnityEngine.Color seeThroughTintColor
    // Size: 0x10
    // Offset: 0xDC
    ::UnityEngine::Color seeThroughTintColor;
    // Field size check
    static_assert(sizeof(::UnityEngine::Color) == 0x10);
    // Padding between fields: seeThroughTintColor and: rms
    char __padding38[0x4] = {};
    // private HighlightPlus.HighlightEffect/ModelMaterials[] rms
    // Size: 0x8
    // Offset: 0xF0
    ::ArrayW<::HighlightPlus::HighlightEffect::ModelMaterials> rms;
    // Field size check
    static_assert(sizeof(::ArrayW<::HighlightPlus::HighlightEffect::ModelMaterials>) == 0x8);
    // private System.Int32 rmsCount
    // Size: 0x4
    // Offset: 0xF8
    int rmsCount;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // Padding between fields: rmsCount and: target
    char __padding40[0x4] = {};
    // public UnityEngine.Transform target
    // Size: 0x8
    // Offset: 0x100
    ::UnityEngine::Transform* target;
    // Field size check
    static_assert(sizeof(::UnityEngine::Transform*) == 0x8);
    // private System.Single fadeStartTime
    // Size: 0x4
    // Offset: 0x108
    float fadeStartTime;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private HighlightPlus.HighlightEffect/FadingState fading
    // Size: 0x4
    // Offset: 0x10C
    ::HighlightPlus::HighlightEffect::FadingState fading;
    // Field size check
    static_assert(sizeof(::HighlightPlus::HighlightEffect::FadingState) == 0x4);
    // private System.Boolean overlayOneShotRunning
    // Size: 0x1
    // Offset: 0x110
    bool overlayOneShotRunning;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Boolean currentHighlighted
    // Size: 0x1
    // Offset: 0x111
    bool currentHighlighted;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: currentHighlighted and: overlayOneShotCurrentColor
    char __padding45[0x2] = {};
    // private UnityEngine.Color overlayOneShotCurrentColor
    // Size: 0x10
    // Offset: 0x114
    ::UnityEngine::Color overlayOneShotCurrentColor;
    // Field size check
    static_assert(sizeof(::UnityEngine::Color) == 0x10);
    // private System.Single overlayOneShotCurrentAnimationSpeed
    // Size: 0x4
    // Offset: 0x124
    float overlayOneShotCurrentAnimationSpeed;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single overlayOneShotCurrentOverlay
    // Size: 0x4
    // Offset: 0x128
    float overlayOneShotCurrentOverlay;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single overlayOneShotCurrentOuterGlow
    // Size: 0x4
    // Offset: 0x12C
    float overlayOneShotCurrentOuterGlow;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single overlayOneShotCurrentInnerGlow
    // Size: 0x4
    // Offset: 0x130
    float overlayOneShotCurrentInnerGlow;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single overlayOneShotCurrentOutline
    // Size: 0x4
    // Offset: 0x134
    float overlayOneShotCurrentOutline;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single overlayOneShotCurrentSeeThroughIntensity
    // Size: 0x4
    // Offset: 0x138
    float overlayOneShotCurrentSeeThroughIntensity;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // Padding between fields: overlayOneShotCurrentSeeThroughIntensity and: overlayOneShotCo
    char __padding52[0x4] = {};
    // private UnityEngine.Coroutine overlayOneShotCo
    // Size: 0x8
    // Offset: 0x140
    ::UnityEngine::Coroutine* overlayOneShotCo;
    // Field size check
    static_assert(sizeof(::UnityEngine::Coroutine*) == 0x8);
    public:
    // Deleting conversion operator: operator ::System::IntPtr
    constexpr operator ::System::IntPtr() const noexcept = delete;
    // static field const value: static private System.String UNIFORM_CUTOFF
    static constexpr const char* UNIFORM_CUTOFF = "_CutOff";
    // Get static field: static private System.String UNIFORM_CUTOFF
    static ::StringW _get_UNIFORM_CUTOFF();
    // Set static field: static private System.String UNIFORM_CUTOFF
    static void _set_UNIFORM_CUTOFF(::StringW value);
    // static field const value: static private System.String UNIFORM_ALPHA_TEX
    static constexpr const char* UNIFORM_ALPHA_TEX = "_AlphaTex";
    // Get static field: static private System.String UNIFORM_ALPHA_TEX
    static ::StringW _get_UNIFORM_ALPHA_TEX();
    // Set static field: static private System.String UNIFORM_ALPHA_TEX
    static void _set_UNIFORM_ALPHA_TEX(::StringW value);
    // static field const value: static private System.String PIXELSNAP_ON
    static constexpr const char* PIXELSNAP_ON = "PIXELSNAP_ON";
    // Get static field: static private System.String PIXELSNAP_ON
    static ::StringW _get_PIXELSNAP_ON();
    // Set static field: static private System.String PIXELSNAP_ON
    static void _set_PIXELSNAP_ON(::StringW value);
    // static field const value: static private System.String ETC1_EXTERNAL_ALPHA
    static constexpr const char* ETC1_EXTERNAL_ALPHA = "ETC1_EXTERNAL_ALPHA";
    // Get static field: static private System.String ETC1_EXTERNAL_ALPHA
    static ::StringW _get_ETC1_EXTERNAL_ALPHA();
    // Set static field: static private System.String ETC1_EXTERNAL_ALPHA
    static void _set_ETC1_EXTERNAL_ALPHA(::StringW value);
    // static field const value: static private System.Single TAU
    static constexpr const float TAU = 0.70711;
    // Get static field: static private System.Single TAU
    static float _get_TAU();
    // Set static field: static private System.Single TAU
    static void _set_TAU(float value);
    // Get static field: static private UnityEngine.Material fxMatMask
    static ::UnityEngine::Material* _get_fxMatMask();
    // Set static field: static private UnityEngine.Material fxMatMask
    static void _set_fxMatMask(::UnityEngine::Material* value);
    // Get static field: static private UnityEngine.Material fxMatSeeThrough
    static ::UnityEngine::Material* _get_fxMatSeeThrough();
    // Set static field: static private UnityEngine.Material fxMatSeeThrough
    static void _set_fxMatSeeThrough(::UnityEngine::Material* value);
    // Get static field: static private UnityEngine.Material fxMatGlow
    static ::UnityEngine::Material* _get_fxMatGlow();
    // Set static field: static private UnityEngine.Material fxMatGlow
    static void _set_fxMatGlow(::UnityEngine::Material* value);
    // Get static field: static private UnityEngine.Material fxMatInnerGlow
    static ::UnityEngine::Material* _get_fxMatInnerGlow();
    // Set static field: static private UnityEngine.Material fxMatInnerGlow
    static void _set_fxMatInnerGlow(::UnityEngine::Material* value);
    // Get static field: static private UnityEngine.Material fxMatOutline
    static ::UnityEngine::Material* _get_fxMatOutline();
    // Set static field: static private UnityEngine.Material fxMatOutline
    static void _set_fxMatOutline(::UnityEngine::Material* value);
    // Get static field: static private UnityEngine.Material fxMatOverlay
    static ::UnityEngine::Material* _get_fxMatOverlay();
    // Set static field: static private UnityEngine.Material fxMatOverlay
    static void _set_fxMatOverlay(::UnityEngine::Material* value);
    // Get static field: static private UnityEngine.Material fxMatOccluder
    static ::UnityEngine::Material* _get_fxMatOccluder();
    // Set static field: static private UnityEngine.Material fxMatOccluder
    static void _set_fxMatOccluder(::UnityEngine::Material* value);
    // Get static field: static private UnityEngine.Vector3[] offsets
    static ::ArrayW<::UnityEngine::Vector3> _get_offsets();
    // Set static field: static private UnityEngine.Vector3[] offsets
    static void _set_offsets(::ArrayW<::UnityEngine::Vector3> value);
    // Get instance field reference: public HighlightPlus.HighlightProfile profile
    [[deprecated("Use field access instead!")]] ::HighlightPlus::HighlightProfile*& dyn_profile();
    // Get instance field reference: public System.Boolean profileSync
    [[deprecated("Use field access instead!")]] bool& dyn_profileSync();
    // Get instance field reference: public System.Boolean previewInEditor
    [[deprecated("Use field access instead!")]] bool& dyn_previewInEditor();
    // Get instance field reference: public System.Boolean ignoreObjectVisibility
    [[deprecated("Use field access instead!")]] bool& dyn_ignoreObjectVisibility();
    // Get instance field reference: public HighlightPlus.SkinnedMeshBakeMode skinnedMeshBakeMode
    [[deprecated("Use field access instead!")]] ::HighlightPlus::SkinnedMeshBakeMode& dyn_skinnedMeshBakeMode();
    // Get instance field reference: public System.Boolean ignore
    [[deprecated("Use field access instead!")]] bool& dyn_ignore();
    // Get instance field reference: private System.Boolean _highlighted
    [[deprecated("Use field access instead!")]] bool& dyn__highlighted();
    // Get instance field reference: public System.Single fadeInDuration
    [[deprecated("Use field access instead!")]] float& dyn_fadeInDuration();
    // Get instance field reference: public System.Single fadeOutDuration
    [[deprecated("Use field access instead!")]] float& dyn_fadeOutDuration();
    // Get instance field reference: public System.Single overlay
    [[deprecated("Use field access instead!")]] float& dyn_overlay();
    // Get instance field reference: public UnityEngine.Color overlayColor
    [[deprecated("Use field access instead!")]] ::UnityEngine::Color& dyn_overlayColor();
    // Get instance field reference: public System.Single overlayAnimationSpeed
    [[deprecated("Use field access instead!")]] float& dyn_overlayAnimationSpeed();
    // Get instance field reference: public System.Single overlayMinIntensity
    [[deprecated("Use field access instead!")]] float& dyn_overlayMinIntensity();
    // Get instance field reference: public System.Single overlayBlending
    [[deprecated("Use field access instead!")]] float& dyn_overlayBlending();
    // Get instance field reference: public System.Single outline
    [[deprecated("Use field access instead!")]] float& dyn_outline();
    // Get instance field reference: public UnityEngine.Color outlineColor
    [[deprecated("Use field access instead!")]] ::UnityEngine::Color& dyn_outlineColor();
    // Get instance field reference: public System.Single outlineWidth
    [[deprecated("Use field access instead!")]] float& dyn_outlineWidth();
    // Get instance field reference: public System.Boolean outlineHQ
    [[deprecated("Use field access instead!")]] bool& dyn_outlineHQ();
    // Get instance field reference: public System.Boolean outlineAlwaysOnTop
    [[deprecated("Use field access instead!")]] bool& dyn_outlineAlwaysOnTop();
    // Get instance field reference: public System.Single glow
    [[deprecated("Use field access instead!")]] float& dyn_glow();
    // Get instance field reference: public System.Single glowWidth
    [[deprecated("Use field access instead!")]] float& dyn_glowWidth();
    // Get instance field reference: public System.Boolean glowHQ
    [[deprecated("Use field access instead!")]] bool& dyn_glowHQ();
    // Get instance field reference: public System.Boolean glowDithering
    [[deprecated("Use field access instead!")]] bool& dyn_glowDithering();
    // Get instance field reference: public System.Single glowMagicNumber1
    [[deprecated("Use field access instead!")]] float& dyn_glowMagicNumber1();
    // Get instance field reference: public System.Single glowMagicNumber2
    [[deprecated("Use field access instead!")]] float& dyn_glowMagicNumber2();
    // Get instance field reference: public System.Single glowAnimationSpeed
    [[deprecated("Use field access instead!")]] float& dyn_glowAnimationSpeed();
    // Get instance field reference: public System.Boolean glowAlwaysOnTop
    [[deprecated("Use field access instead!")]] bool& dyn_glowAlwaysOnTop();
    // Get instance field reference: public HighlightPlus.GlowPassData[] glowPasses
    [[deprecated("Use field access instead!")]] ::ArrayW<::HighlightPlus::GlowPassData>& dyn_glowPasses();
    // Get instance field reference: public System.Single innerGlow
    [[deprecated("Use field access instead!")]] float& dyn_innerGlow();
    // Get instance field reference: public System.Single innerGlowWidth
    [[deprecated("Use field access instead!")]] float& dyn_innerGlowWidth();
    // Get instance field reference: public UnityEngine.Color innerGlowColor
    [[deprecated("Use field access instead!")]] ::UnityEngine::Color& dyn_innerGlowColor();
    // Get instance field reference: public System.Boolean innerGlowAlwaysOnTop
    [[deprecated("Use field access instead!")]] bool& dyn_innerGlowAlwaysOnTop();
    // Get instance field reference: private HighlightPlus.OnObjectHighlightStartEvent OnObjectHighlightStart
    [[deprecated("Use field access instead!")]] ::HighlightPlus::OnObjectHighlightStartEvent*& dyn_OnObjectHighlightStart();
    // Get instance field reference: private HighlightPlus.OnObjectHighlightEndEvent OnObjectHighlightEnd
    [[deprecated("Use field access instead!")]] ::HighlightPlus::OnObjectHighlightEndEvent*& dyn_OnObjectHighlightEnd();
    // Get instance field reference: private HighlightPlus.OnRendererHighlightEvent OnRendererHighlightStart
    [[deprecated("Use field access instead!")]] ::HighlightPlus::OnRendererHighlightEvent*& dyn_OnRendererHighlightStart();
    // Get instance field reference: public HighlightPlus.SeeThroughMode seeThrough
    [[deprecated("Use field access instead!")]] ::HighlightPlus::SeeThroughMode& dyn_seeThrough();
    // Get instance field reference: public System.Single seeThroughIntensity
    [[deprecated("Use field access instead!")]] float& dyn_seeThroughIntensity();
    // Get instance field reference: public System.Single seeThroughTintAlpha
    [[deprecated("Use field access instead!")]] float& dyn_seeThroughTintAlpha();
    // Get instance field reference: public UnityEngine.Color seeThroughTintColor
    [[deprecated("Use field access instead!")]] ::UnityEngine::Color& dyn_seeThroughTintColor();
    // Get instance field reference: private HighlightPlus.HighlightEffect/ModelMaterials[] rms
    [[deprecated("Use field access instead!")]] ::ArrayW<::HighlightPlus::HighlightEffect::ModelMaterials>& dyn_rms();
    // Get instance field reference: private System.Int32 rmsCount
    [[deprecated("Use field access instead!")]] int& dyn_rmsCount();
    // Get instance field reference: public UnityEngine.Transform target
    [[deprecated("Use field access instead!")]] ::UnityEngine::Transform*& dyn_target();
    // Get instance field reference: private System.Single fadeStartTime
    [[deprecated("Use field access instead!")]] float& dyn_fadeStartTime();
    // Get instance field reference: private HighlightPlus.HighlightEffect/FadingState fading
    [[deprecated("Use field access instead!")]] ::HighlightPlus::HighlightEffect::FadingState& dyn_fading();
    // Get instance field reference: private System.Boolean overlayOneShotRunning
    [[deprecated("Use field access instead!")]] bool& dyn_overlayOneShotRunning();
    // Get instance field reference: private System.Boolean currentHighlighted
    [[deprecated("Use field access instead!")]] bool& dyn_currentHighlighted();
    // Get instance field reference: private UnityEngine.Color overlayOneShotCurrentColor
    [[deprecated("Use field access instead!")]] ::UnityEngine::Color& dyn_overlayOneShotCurrentColor();
    // Get instance field reference: private System.Single overlayOneShotCurrentAnimationSpeed
    [[deprecated("Use field access instead!")]] float& dyn_overlayOneShotCurrentAnimationSpeed();
    // Get instance field reference: private System.Single overlayOneShotCurrentOverlay
    [[deprecated("Use field access instead!")]] float& dyn_overlayOneShotCurrentOverlay();
    // Get instance field reference: private System.Single overlayOneShotCurrentOuterGlow
    [[deprecated("Use field access instead!")]] float& dyn_overlayOneShotCurrentOuterGlow();
    // Get instance field reference: private System.Single overlayOneShotCurrentInnerGlow
    [[deprecated("Use field access instead!")]] float& dyn_overlayOneShotCurrentInnerGlow();
    // Get instance field reference: private System.Single overlayOneShotCurrentOutline
    [[deprecated("Use field access instead!")]] float& dyn_overlayOneShotCurrentOutline();
    // Get instance field reference: private System.Single overlayOneShotCurrentSeeThroughIntensity
    [[deprecated("Use field access instead!")]] float& dyn_overlayOneShotCurrentSeeThroughIntensity();
    // Get instance field reference: private UnityEngine.Coroutine overlayOneShotCo
    [[deprecated("Use field access instead!")]] ::UnityEngine::Coroutine*& dyn_overlayOneShotCo();
    // public System.Boolean get_highlighted()
    // Offset: 0x1494740
    bool get_highlighted();
    // public System.Void set_highlighted(System.Boolean value)
    // Offset: 0x1494748
    void set_highlighted(bool value);
    // public System.Void add_OnObjectHighlightStart(HighlightPlus.OnObjectHighlightStartEvent value)
    // Offset: 0x1494950
    void add_OnObjectHighlightStart(::HighlightPlus::OnObjectHighlightStartEvent* value);
    // public System.Void remove_OnObjectHighlightStart(HighlightPlus.OnObjectHighlightStartEvent value)
    // Offset: 0x1494A3C
    void remove_OnObjectHighlightStart(::HighlightPlus::OnObjectHighlightStartEvent* value);
    // public System.Void add_OnObjectHighlightEnd(HighlightPlus.OnObjectHighlightEndEvent value)
    // Offset: 0x1494B28
    void add_OnObjectHighlightEnd(::HighlightPlus::OnObjectHighlightEndEvent* value);
    // public System.Void remove_OnObjectHighlightEnd(HighlightPlus.OnObjectHighlightEndEvent value)
    // Offset: 0x1494C14
    void remove_OnObjectHighlightEnd(::HighlightPlus::OnObjectHighlightEndEvent* value);
    // public System.Void add_OnRendererHighlightStart(HighlightPlus.OnRendererHighlightEvent value)
    // Offset: 0x1494D00
    void add_OnRendererHighlightStart(::HighlightPlus::OnRendererHighlightEvent* value);
    // public System.Void remove_OnRendererHighlightStart(HighlightPlus.OnRendererHighlightEvent value)
    // Offset: 0x1494DEC
    void remove_OnRendererHighlightStart(::HighlightPlus::OnRendererHighlightEvent* value);
    // private System.Void Start()
    // Offset: 0x1494ED8
    void Start();
    // private System.Void OnEnable()
    // Offset: 0x1495E88
    void OnEnable();
    // private System.Void OnDisable()
    // Offset: 0x1495E8C
    void OnDisable();
    // private System.Void Reset()
    // Offset: 0x1496994
    void Reset();
    // public System.Void Refresh()
    // Offset: 0x1496998
    void Refresh();
    // public System.Void RenderOccluder()
    // Offset: 0x14969DC
    void RenderOccluder();
    // private System.Void OnRenderObject()
    // Offset: 0x14978A4
    void OnRenderObject();
    // private System.Void InitMaterial(ref UnityEngine.Material material, System.String shaderName)
    // Offset: 0x14998C0
    void InitMaterial(ByRef<::UnityEngine::Material*> material, ::StringW shaderName);
    // public System.Void SetTarget(UnityEngine.Transform transform)
    // Offset: 0x1499A2C
    void SetTarget(::UnityEngine::Transform* transform);
    // public System.Void SetHighlighted(System.Boolean state)
    // Offset: 0x1494750
    void SetHighlighted(bool state);
    // private System.Void SetupMaterial()
    // Offset: 0x149534C
    void SetupMaterial();
    // private System.Void CheckGeometrySupportDependencies()
    // Offset: 0x149522C
    void CheckGeometrySupportDependencies();
    // private UnityEngine.Material[] Fork(UnityEngine.Material mat, UnityEngine.Mesh mesh)
    // Offset: 0x149A9B8
    ::ArrayW<::UnityEngine::Material*> Fork(::UnityEngine::Material* mat, ::UnityEngine::Mesh* mesh);
    // private System.Void BakeTransform(System.Int32 i, System.Boolean duplicateMesh)
    // Offset: 0x14972C4
    void BakeTransform(int i, bool duplicateMesh);
    // private System.Void UpdateMaterialProperties()
    // Offset: 0x1495E90
    void UpdateMaterialProperties();
    // public System.Void OverlayOneShot(UnityEngine.Color color, System.Single duration)
    // Offset: 0x149AB34
    void OverlayOneShot(::UnityEngine::Color color, float duration);
    // private System.Collections.IEnumerator OverlayOneShotAnimator(UnityEngine.Color color, System.Single duration)
    // Offset: 0x149ACA8
    ::System::Collections::IEnumerator* OverlayOneShotAnimator(::UnityEngine::Color color, float duration);
    // private System.Void OverlayOneShotEnd()
    // Offset: 0x149AC38
    void OverlayOneShotEnd();
    // public System.Void .ctor()
    // Offset: 0x149ADA0
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static HighlightEffect* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::HighlightPlus::HighlightEffect::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<HighlightEffect*, creationType>()));
    }
  }; // HighlightPlus.HighlightEffect
  #pragma pack(pop)
  static check_size<sizeof(HighlightEffect), 320 + sizeof(::UnityEngine::Coroutine*)> __HighlightPlus_HighlightEffectSizeCheck;
  static_assert(sizeof(HighlightEffect) == 0x148);
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::HighlightPlus::HighlightEffect::FadingState, "HighlightPlus", "HighlightEffect/FadingState");
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::HighlightPlus::HighlightEffect::ModelMaterials, "HighlightPlus", "HighlightEffect/ModelMaterials");
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: HighlightPlus::HighlightEffect::get_highlighted
// Il2CppName: get_highlighted
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (HighlightPlus::HighlightEffect::*)()>(&HighlightPlus::HighlightEffect::get_highlighted)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(HighlightPlus::HighlightEffect*), "get_highlighted", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: HighlightPlus::HighlightEffect::set_highlighted
// Il2CppName: set_highlighted
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (HighlightPlus::HighlightEffect::*)(bool)>(&HighlightPlus::HighlightEffect::set_highlighted)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(HighlightPlus::HighlightEffect*), "set_highlighted", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: HighlightPlus::HighlightEffect::add_OnObjectHighlightStart
// Il2CppName: add_OnObjectHighlightStart
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (HighlightPlus::HighlightEffect::*)(::HighlightPlus::OnObjectHighlightStartEvent*)>(&HighlightPlus::HighlightEffect::add_OnObjectHighlightStart)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("HighlightPlus", "OnObjectHighlightStartEvent")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(HighlightPlus::HighlightEffect*), "add_OnObjectHighlightStart", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: HighlightPlus::HighlightEffect::remove_OnObjectHighlightStart
// Il2CppName: remove_OnObjectHighlightStart
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (HighlightPlus::HighlightEffect::*)(::HighlightPlus::OnObjectHighlightStartEvent*)>(&HighlightPlus::HighlightEffect::remove_OnObjectHighlightStart)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("HighlightPlus", "OnObjectHighlightStartEvent")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(HighlightPlus::HighlightEffect*), "remove_OnObjectHighlightStart", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: HighlightPlus::HighlightEffect::add_OnObjectHighlightEnd
// Il2CppName: add_OnObjectHighlightEnd
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (HighlightPlus::HighlightEffect::*)(::HighlightPlus::OnObjectHighlightEndEvent*)>(&HighlightPlus::HighlightEffect::add_OnObjectHighlightEnd)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("HighlightPlus", "OnObjectHighlightEndEvent")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(HighlightPlus::HighlightEffect*), "add_OnObjectHighlightEnd", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: HighlightPlus::HighlightEffect::remove_OnObjectHighlightEnd
// Il2CppName: remove_OnObjectHighlightEnd
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (HighlightPlus::HighlightEffect::*)(::HighlightPlus::OnObjectHighlightEndEvent*)>(&HighlightPlus::HighlightEffect::remove_OnObjectHighlightEnd)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("HighlightPlus", "OnObjectHighlightEndEvent")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(HighlightPlus::HighlightEffect*), "remove_OnObjectHighlightEnd", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: HighlightPlus::HighlightEffect::add_OnRendererHighlightStart
// Il2CppName: add_OnRendererHighlightStart
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (HighlightPlus::HighlightEffect::*)(::HighlightPlus::OnRendererHighlightEvent*)>(&HighlightPlus::HighlightEffect::add_OnRendererHighlightStart)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("HighlightPlus", "OnRendererHighlightEvent")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(HighlightPlus::HighlightEffect*), "add_OnRendererHighlightStart", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: HighlightPlus::HighlightEffect::remove_OnRendererHighlightStart
// Il2CppName: remove_OnRendererHighlightStart
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (HighlightPlus::HighlightEffect::*)(::HighlightPlus::OnRendererHighlightEvent*)>(&HighlightPlus::HighlightEffect::remove_OnRendererHighlightStart)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("HighlightPlus", "OnRendererHighlightEvent")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(HighlightPlus::HighlightEffect*), "remove_OnRendererHighlightStart", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: HighlightPlus::HighlightEffect::Start
// Il2CppName: Start
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (HighlightPlus::HighlightEffect::*)()>(&HighlightPlus::HighlightEffect::Start)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(HighlightPlus::HighlightEffect*), "Start", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: HighlightPlus::HighlightEffect::OnEnable
// Il2CppName: OnEnable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (HighlightPlus::HighlightEffect::*)()>(&HighlightPlus::HighlightEffect::OnEnable)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(HighlightPlus::HighlightEffect*), "OnEnable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: HighlightPlus::HighlightEffect::OnDisable
// Il2CppName: OnDisable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (HighlightPlus::HighlightEffect::*)()>(&HighlightPlus::HighlightEffect::OnDisable)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(HighlightPlus::HighlightEffect*), "OnDisable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: HighlightPlus::HighlightEffect::Reset
// Il2CppName: Reset
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (HighlightPlus::HighlightEffect::*)()>(&HighlightPlus::HighlightEffect::Reset)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(HighlightPlus::HighlightEffect*), "Reset", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: HighlightPlus::HighlightEffect::Refresh
// Il2CppName: Refresh
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (HighlightPlus::HighlightEffect::*)()>(&HighlightPlus::HighlightEffect::Refresh)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(HighlightPlus::HighlightEffect*), "Refresh", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: HighlightPlus::HighlightEffect::RenderOccluder
// Il2CppName: RenderOccluder
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (HighlightPlus::HighlightEffect::*)()>(&HighlightPlus::HighlightEffect::RenderOccluder)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(HighlightPlus::HighlightEffect*), "RenderOccluder", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: HighlightPlus::HighlightEffect::OnRenderObject
// Il2CppName: OnRenderObject
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (HighlightPlus::HighlightEffect::*)()>(&HighlightPlus::HighlightEffect::OnRenderObject)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(HighlightPlus::HighlightEffect*), "OnRenderObject", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: HighlightPlus::HighlightEffect::InitMaterial
// Il2CppName: InitMaterial
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (HighlightPlus::HighlightEffect::*)(ByRef<::UnityEngine::Material*>, ::StringW)>(&HighlightPlus::HighlightEffect::InitMaterial)> {
  static const MethodInfo* get() {
    static auto* material = &::il2cpp_utils::GetClassFromName("UnityEngine", "Material")->this_arg;
    static auto* shaderName = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(HighlightPlus::HighlightEffect*), "InitMaterial", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{material, shaderName});
  }
};
// Writing MetadataGetter for method: HighlightPlus::HighlightEffect::SetTarget
// Il2CppName: SetTarget
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (HighlightPlus::HighlightEffect::*)(::UnityEngine::Transform*)>(&HighlightPlus::HighlightEffect::SetTarget)> {
  static const MethodInfo* get() {
    static auto* transform = &::il2cpp_utils::GetClassFromName("UnityEngine", "Transform")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(HighlightPlus::HighlightEffect*), "SetTarget", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{transform});
  }
};
// Writing MetadataGetter for method: HighlightPlus::HighlightEffect::SetHighlighted
// Il2CppName: SetHighlighted
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (HighlightPlus::HighlightEffect::*)(bool)>(&HighlightPlus::HighlightEffect::SetHighlighted)> {
  static const MethodInfo* get() {
    static auto* state = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(HighlightPlus::HighlightEffect*), "SetHighlighted", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{state});
  }
};
// Writing MetadataGetter for method: HighlightPlus::HighlightEffect::SetupMaterial
// Il2CppName: SetupMaterial
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (HighlightPlus::HighlightEffect::*)()>(&HighlightPlus::HighlightEffect::SetupMaterial)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(HighlightPlus::HighlightEffect*), "SetupMaterial", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: HighlightPlus::HighlightEffect::CheckGeometrySupportDependencies
// Il2CppName: CheckGeometrySupportDependencies
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (HighlightPlus::HighlightEffect::*)()>(&HighlightPlus::HighlightEffect::CheckGeometrySupportDependencies)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(HighlightPlus::HighlightEffect*), "CheckGeometrySupportDependencies", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: HighlightPlus::HighlightEffect::Fork
// Il2CppName: Fork
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::ArrayW<::UnityEngine::Material*> (HighlightPlus::HighlightEffect::*)(::UnityEngine::Material*, ::UnityEngine::Mesh*)>(&HighlightPlus::HighlightEffect::Fork)> {
  static const MethodInfo* get() {
    static auto* mat = &::il2cpp_utils::GetClassFromName("UnityEngine", "Material")->byval_arg;
    static auto* mesh = &::il2cpp_utils::GetClassFromName("UnityEngine", "Mesh")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(HighlightPlus::HighlightEffect*), "Fork", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{mat, mesh});
  }
};
// Writing MetadataGetter for method: HighlightPlus::HighlightEffect::BakeTransform
// Il2CppName: BakeTransform
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (HighlightPlus::HighlightEffect::*)(int, bool)>(&HighlightPlus::HighlightEffect::BakeTransform)> {
  static const MethodInfo* get() {
    static auto* i = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* duplicateMesh = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(HighlightPlus::HighlightEffect*), "BakeTransform", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{i, duplicateMesh});
  }
};
// Writing MetadataGetter for method: HighlightPlus::HighlightEffect::UpdateMaterialProperties
// Il2CppName: UpdateMaterialProperties
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (HighlightPlus::HighlightEffect::*)()>(&HighlightPlus::HighlightEffect::UpdateMaterialProperties)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(HighlightPlus::HighlightEffect*), "UpdateMaterialProperties", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: HighlightPlus::HighlightEffect::OverlayOneShot
// Il2CppName: OverlayOneShot
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (HighlightPlus::HighlightEffect::*)(::UnityEngine::Color, float)>(&HighlightPlus::HighlightEffect::OverlayOneShot)> {
  static const MethodInfo* get() {
    static auto* color = &::il2cpp_utils::GetClassFromName("UnityEngine", "Color")->byval_arg;
    static auto* duration = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(HighlightPlus::HighlightEffect*), "OverlayOneShot", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{color, duration});
  }
};
// Writing MetadataGetter for method: HighlightPlus::HighlightEffect::OverlayOneShotAnimator
// Il2CppName: OverlayOneShotAnimator
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Collections::IEnumerator* (HighlightPlus::HighlightEffect::*)(::UnityEngine::Color, float)>(&HighlightPlus::HighlightEffect::OverlayOneShotAnimator)> {
  static const MethodInfo* get() {
    static auto* color = &::il2cpp_utils::GetClassFromName("UnityEngine", "Color")->byval_arg;
    static auto* duration = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(HighlightPlus::HighlightEffect*), "OverlayOneShotAnimator", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{color, duration});
  }
};
// Writing MetadataGetter for method: HighlightPlus::HighlightEffect::OverlayOneShotEnd
// Il2CppName: OverlayOneShotEnd
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (HighlightPlus::HighlightEffect::*)()>(&HighlightPlus::HighlightEffect::OverlayOneShotEnd)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(HighlightPlus::HighlightEffect*), "OverlayOneShotEnd", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: HighlightPlus::HighlightEffect::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
