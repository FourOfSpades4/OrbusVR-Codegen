// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
#include "beatsaber-hook/shared/utils/typedefs-string.hpp"
// Completed includes
// Type namespace: ExtUI
namespace ExtUI {
  // Forward declaring type: InventoryItemMeta
  class InventoryItemMeta;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::ExtUI::InventoryItemMeta);
DEFINE_IL2CPP_ARG_TYPE(::ExtUI::InventoryItemMeta*, "ExtUI", "InventoryItemMeta");
// Type namespace: ExtUI
namespace ExtUI {
  // Size: 0x120
  #pragma pack(push, 1)
  // Autogenerated type: ExtUI.InventoryItemMeta
  // [TokenAttribute] Offset: FFFFFFFF
  class InventoryItemMeta : public ::Il2CppObject {
    public:
    public:
    // public System.Int32[] parts
    // Size: 0x8
    // Offset: 0x10
    ::ArrayW<int> parts;
    // Field size check
    static_assert(sizeof(::ArrayW<int>) == 0x8);
    // public System.Int32[] tileset
    // Size: 0x8
    // Offset: 0x18
    ::ArrayW<int> tileset;
    // Field size check
    static_assert(sizeof(::ArrayW<int>) == 0x8);
    // public System.String[] mutations
    // Size: 0x8
    // Offset: 0x20
    ::ArrayW<::StringW> mutations;
    // Field size check
    static_assert(sizeof(::ArrayW<::StringW>) == 0x8);
    // public System.String sharddungeon
    // Size: 0x8
    // Offset: 0x28
    ::StringW sharddungeon;
    // Field size check
    static_assert(sizeof(::StringW) == 0x8);
    // public System.Int32 shardlevel
    // Size: 0x4
    // Offset: 0x30
    int shardlevel;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // Padding between fields: shardlevel and: majordye
    char __padding4[0x4] = {};
    // public System.String majordye
    // Size: 0x8
    // Offset: 0x38
    ::StringW majordye;
    // Field size check
    static_assert(sizeof(::StringW) == 0x8);
    // public System.String minordye
    // Size: 0x8
    // Offset: 0x40
    ::StringW minordye;
    // Field size check
    static_assert(sizeof(::StringW) == 0x8);
    // public System.Int32 durability
    // Size: 0x4
    // Offset: 0x48
    int durability;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // Padding between fields: durability and: tempTradable
    char __padding7[0x4] = {};
    // public System.String[] tempTradable
    // Size: 0x8
    // Offset: 0x50
    ::ArrayW<::StringW> tempTradable;
    // Field size check
    static_assert(sizeof(::ArrayW<::StringW>) == 0x8);
    // public System.Int32 strength
    // Size: 0x4
    // Offset: 0x58
    int strength;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Int32 intellect
    // Size: 0x4
    // Offset: 0x5C
    int intellect;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Int32 regen
    // Size: 0x4
    // Offset: 0x60
    int regen;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Int32 defense
    // Size: 0x4
    // Offset: 0x64
    int defense;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Int32 magdefense
    // Size: 0x4
    // Offset: 0x68
    int magdefense;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Int32 vitality
    // Size: 0x4
    // Offset: 0x6C
    int vitality;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Int32 armor
    // Size: 0x4
    // Offset: 0x70
    int armor;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Int32 attack
    // Size: 0x4
    // Offset: 0x74
    int attack;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Int32 crit
    // Size: 0x4
    // Offset: 0x78
    int crit;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Int32 wisdom
    // Size: 0x4
    // Offset: 0x7C
    int wisdom;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Int32 speed
    // Size: 0x4
    // Offset: 0x80
    int speed;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Int32 luck
    // Size: 0x4
    // Offset: 0x84
    int luck;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Int32 maxDurability
    // Size: 0x4
    // Offset: 0x88
    int maxDurability;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // Padding between fields: maxDurability and: rarity
    char __padding21[0x4] = {};
    // public System.String rarity
    // Size: 0x8
    // Offset: 0x90
    ::StringW rarity;
    // Field size check
    static_assert(sizeof(::StringW) == 0x8);
    // public System.String[] affixes
    // Size: 0x8
    // Offset: 0x98
    ::ArrayW<::StringW> affixes;
    // Field size check
    static_assert(sizeof(::ArrayW<::StringW>) == 0x8);
    // public System.Boolean perfect
    // Size: 0x1
    // Offset: 0xA0
    bool perfect;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: perfect and: primaryColor
    char __padding24[0x7] = {};
    // public System.Int32[] primaryColor
    // Size: 0x8
    // Offset: 0xA8
    ::ArrayW<int> primaryColor;
    // Field size check
    static_assert(sizeof(::ArrayW<int>) == 0x8);
    // public System.Int32[] secondaryColor
    // Size: 0x8
    // Offset: 0xB0
    ::ArrayW<int> secondaryColor;
    // Field size check
    static_assert(sizeof(::ArrayW<int>) == 0x8);
    // public System.Int32[] spotColor
    // Size: 0x8
    // Offset: 0xB8
    ::ArrayW<int> spotColor;
    // Field size check
    static_assert(sizeof(::ArrayW<int>) == 0x8);
    // public System.Int32 size
    // Size: 0x4
    // Offset: 0xC0
    int size;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // Padding between fields: size and: type
    char __padding28[0x4] = {};
    // public System.String type
    // Size: 0x8
    // Offset: 0xC8
    ::StringW type;
    // Field size check
    static_assert(sizeof(::StringW) == 0x8);
    // public System.Int32 mood
    // Size: 0x4
    // Offset: 0xD0
    int mood;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Int32 happiness
    // Size: 0x4
    // Offset: 0xD4
    int happiness;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Int32 bonusType
    // Size: 0x4
    // Offset: 0xD8
    int bonusType;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Single rollLevel
    // Size: 0x4
    // Offset: 0xDC
    float rollLevel;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Int32 looksLike
    // Size: 0x4
    // Offset: 0xE0
    int looksLike;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Int32 itemLevel
    // Size: 0x4
    // Offset: 0xE4
    int itemLevel;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Int32 itemPlusLevel
    // Size: 0x4
    // Offset: 0xE8
    int itemPlusLevel;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // Padding between fields: itemPlusLevel and: containedItems
    char __padding36[0x4] = {};
    // public System.String[] containedItems
    // Size: 0x8
    // Offset: 0xF0
    ::ArrayW<::StringW> containedItems;
    // Field size check
    static_assert(sizeof(::ArrayW<::StringW>) == 0x8);
    // public System.String loadout
    // Size: 0x8
    // Offset: 0xF8
    ::StringW loadout;
    // Field size check
    static_assert(sizeof(::StringW) == 0x8);
    // public System.String locationId
    // Size: 0x8
    // Offset: 0x100
    ::StringW locationId;
    // Field size check
    static_assert(sizeof(::StringW) == 0x8);
    // public System.Int64 expireTime
    // Size: 0x8
    // Offset: 0x108
    int64_t expireTime;
    // Field size check
    static_assert(sizeof(int64_t) == 0x8);
    // public System.Boolean locked
    // Size: 0x1
    // Offset: 0x110
    bool locked;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: locked and: breederName
    char __padding41[0x7] = {};
    // public System.String breederName
    // Size: 0x8
    // Offset: 0x118
    ::StringW breederName;
    // Field size check
    static_assert(sizeof(::StringW) == 0x8);
    public:
    // Get instance field reference: public System.Int32[] parts
    [[deprecated("Use field access instead!")]] ::ArrayW<int>& dyn_parts();
    // Get instance field reference: public System.Int32[] tileset
    [[deprecated("Use field access instead!")]] ::ArrayW<int>& dyn_tileset();
    // Get instance field reference: public System.String[] mutations
    [[deprecated("Use field access instead!")]] ::ArrayW<::StringW>& dyn_mutations();
    // Get instance field reference: public System.String sharddungeon
    [[deprecated("Use field access instead!")]] ::StringW& dyn_sharddungeon();
    // Get instance field reference: public System.Int32 shardlevel
    [[deprecated("Use field access instead!")]] int& dyn_shardlevel();
    // Get instance field reference: public System.String majordye
    [[deprecated("Use field access instead!")]] ::StringW& dyn_majordye();
    // Get instance field reference: public System.String minordye
    [[deprecated("Use field access instead!")]] ::StringW& dyn_minordye();
    // Get instance field reference: public System.Int32 durability
    [[deprecated("Use field access instead!")]] int& dyn_durability();
    // Get instance field reference: public System.String[] tempTradable
    [[deprecated("Use field access instead!")]] ::ArrayW<::StringW>& dyn_tempTradable();
    // Get instance field reference: public System.Int32 strength
    [[deprecated("Use field access instead!")]] int& dyn_strength();
    // Get instance field reference: public System.Int32 intellect
    [[deprecated("Use field access instead!")]] int& dyn_intellect();
    // Get instance field reference: public System.Int32 regen
    [[deprecated("Use field access instead!")]] int& dyn_regen();
    // Get instance field reference: public System.Int32 defense
    [[deprecated("Use field access instead!")]] int& dyn_defense();
    // Get instance field reference: public System.Int32 magdefense
    [[deprecated("Use field access instead!")]] int& dyn_magdefense();
    // Get instance field reference: public System.Int32 vitality
    [[deprecated("Use field access instead!")]] int& dyn_vitality();
    // Get instance field reference: public System.Int32 armor
    [[deprecated("Use field access instead!")]] int& dyn_armor();
    // Get instance field reference: public System.Int32 attack
    [[deprecated("Use field access instead!")]] int& dyn_attack();
    // Get instance field reference: public System.Int32 crit
    [[deprecated("Use field access instead!")]] int& dyn_crit();
    // Get instance field reference: public System.Int32 wisdom
    [[deprecated("Use field access instead!")]] int& dyn_wisdom();
    // Get instance field reference: public System.Int32 speed
    [[deprecated("Use field access instead!")]] int& dyn_speed();
    // Get instance field reference: public System.Int32 luck
    [[deprecated("Use field access instead!")]] int& dyn_luck();
    // Get instance field reference: public System.Int32 maxDurability
    [[deprecated("Use field access instead!")]] int& dyn_maxDurability();
    // Get instance field reference: public System.String rarity
    [[deprecated("Use field access instead!")]] ::StringW& dyn_rarity();
    // Get instance field reference: public System.String[] affixes
    [[deprecated("Use field access instead!")]] ::ArrayW<::StringW>& dyn_affixes();
    // Get instance field reference: public System.Boolean perfect
    [[deprecated("Use field access instead!")]] bool& dyn_perfect();
    // Get instance field reference: public System.Int32[] primaryColor
    [[deprecated("Use field access instead!")]] ::ArrayW<int>& dyn_primaryColor();
    // Get instance field reference: public System.Int32[] secondaryColor
    [[deprecated("Use field access instead!")]] ::ArrayW<int>& dyn_secondaryColor();
    // Get instance field reference: public System.Int32[] spotColor
    [[deprecated("Use field access instead!")]] ::ArrayW<int>& dyn_spotColor();
    // Get instance field reference: public System.Int32 size
    [[deprecated("Use field access instead!")]] int& dyn_size();
    // Get instance field reference: public System.String type
    [[deprecated("Use field access instead!")]] ::StringW& dyn_type();
    // Get instance field reference: public System.Int32 mood
    [[deprecated("Use field access instead!")]] int& dyn_mood();
    // Get instance field reference: public System.Int32 happiness
    [[deprecated("Use field access instead!")]] int& dyn_happiness();
    // Get instance field reference: public System.Int32 bonusType
    [[deprecated("Use field access instead!")]] int& dyn_bonusType();
    // Get instance field reference: public System.Single rollLevel
    [[deprecated("Use field access instead!")]] float& dyn_rollLevel();
    // Get instance field reference: public System.Int32 looksLike
    [[deprecated("Use field access instead!")]] int& dyn_looksLike();
    // Get instance field reference: public System.Int32 itemLevel
    [[deprecated("Use field access instead!")]] int& dyn_itemLevel();
    // Get instance field reference: public System.Int32 itemPlusLevel
    [[deprecated("Use field access instead!")]] int& dyn_itemPlusLevel();
    // Get instance field reference: public System.String[] containedItems
    [[deprecated("Use field access instead!")]] ::ArrayW<::StringW>& dyn_containedItems();
    // Get instance field reference: public System.String loadout
    [[deprecated("Use field access instead!")]] ::StringW& dyn_loadout();
    // Get instance field reference: public System.String locationId
    [[deprecated("Use field access instead!")]] ::StringW& dyn_locationId();
    // Get instance field reference: public System.Int64 expireTime
    [[deprecated("Use field access instead!")]] int64_t& dyn_expireTime();
    // Get instance field reference: public System.Boolean locked
    [[deprecated("Use field access instead!")]] bool& dyn_locked();
    // Get instance field reference: public System.String breederName
    [[deprecated("Use field access instead!")]] ::StringW& dyn_breederName();
    // public System.Void .ctor()
    // Offset: 0x28E74BC
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static InventoryItemMeta* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::ExtUI::InventoryItemMeta::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<InventoryItemMeta*, creationType>()));
    }
  }; // ExtUI.InventoryItemMeta
  #pragma pack(pop)
  static check_size<sizeof(InventoryItemMeta), 280 + sizeof(::StringW)> __ExtUI_InventoryItemMetaSizeCheck;
  static_assert(sizeof(InventoryItemMeta) == 0x120);
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: ExtUI::InventoryItemMeta::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
