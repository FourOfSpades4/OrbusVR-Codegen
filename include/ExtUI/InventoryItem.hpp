// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-string.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: ExtUI
namespace ExtUI {
}
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: Mesh
  class Mesh;
  // Forward declaring type: GameObject
  class GameObject;
  // Forward declaring type: Texture
  class Texture;
}
// Forward declaring namespace: System
namespace System {
  // Forward declaring type: Action`1<T>
  template<typename T>
  class Action_1;
  // Forward declaring type: Action
  class Action;
}
// Completed forward declares
// Type namespace: ExtUI
namespace ExtUI {
  // Forward declaring type: InventoryItem
  class InventoryItem;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::ExtUI::InventoryItem);
DEFINE_IL2CPP_ARG_TYPE(::ExtUI::InventoryItem*, "ExtUI", "InventoryItem");
// Type namespace: ExtUI
namespace ExtUI {
  // Size: 0xAC
  #pragma pack(push, 1)
  // Autogenerated type: ExtUI.InventoryItem
  // [TokenAttribute] Offset: FFFFFFFF
  class InventoryItem : public ::Il2CppObject {
    public:
    // Nested type: ::ExtUI::InventoryItem::$$c__DisplayClass44_0
    class $$c__DisplayClass44_0;
    // Nested type: ::ExtUI::InventoryItem::$$c__DisplayClass44_1
    class $$c__DisplayClass44_1;
    // Nested type: ::ExtUI::InventoryItem::$$c__DisplayClass45_0
    class $$c__DisplayClass45_0;
    // Nested type: ::ExtUI::InventoryItem::$$c__DisplayClass45_1
    class $$c__DisplayClass45_1;
    // Nested type: ::ExtUI::InventoryItem::$$c__DisplayClass46_0
    class $$c__DisplayClass46_0;
    // Nested type: ::ExtUI::InventoryItem::$$c__DisplayClass46_1
    class $$c__DisplayClass46_1;
    // Nested type: ::ExtUI::InventoryItem::$$c__DisplayClass48_0
    class $$c__DisplayClass48_0;
    public:
    // public System.Int32 id
    // Size: 0x4
    // Offset: 0x10
    int id;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // Padding between fields: id and: name
    char __padding0[0x4] = {};
    // public System.String name
    // Size: 0x8
    // Offset: 0x18
    ::StringW name;
    // Field size check
    static_assert(sizeof(::StringW) == 0x8);
    // public System.String htmlName
    // Size: 0x8
    // Offset: 0x20
    ::StringW htmlName;
    // Field size check
    static_assert(sizeof(::StringW) == 0x8);
    // public System.String icon
    // Size: 0x8
    // Offset: 0x28
    ::StringW icon;
    // Field size check
    static_assert(sizeof(::StringW) == 0x8);
    // public System.String description
    // Size: 0x8
    // Offset: 0x30
    ::StringW description;
    // Field size check
    static_assert(sizeof(::StringW) == 0x8);
    // public System.String prefabName
    // Size: 0x8
    // Offset: 0x38
    ::StringW prefabName;
    // Field size check
    static_assert(sizeof(::StringW) == 0x8);
    // private System.Boolean descriptionCached
    // Size: 0x1
    // Offset: 0x40
    bool descriptionCached;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: descriptionCached and: maxstackable
    char __padding6[0x3] = {};
    // public System.Int32 maxstackable
    // Size: 0x4
    // Offset: 0x44
    int maxstackable;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.String defaultRarity
    // Size: 0x8
    // Offset: 0x48
    ::StringW defaultRarity;
    // Field size check
    static_assert(sizeof(::StringW) == 0x8);
    // public System.String type
    // Size: 0x8
    // Offset: 0x50
    ::StringW type;
    // Field size check
    static_assert(sizeof(::StringW) == 0x8);
    // public System.String slot
    // Size: 0x8
    // Offset: 0x58
    ::StringW slot;
    // Field size check
    static_assert(sizeof(::StringW) == 0x8);
    // public System.Int32 ilevel
    // Size: 0x4
    // Offset: 0x60
    int ilevel;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Int32 minlevel
    // Size: 0x4
    // Offset: 0x64
    int minlevel;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.String reqclass
    // Size: 0x8
    // Offset: 0x68
    ::StringW reqclass;
    // Field size check
    static_assert(sizeof(::StringW) == 0x8);
    // public System.Single weight
    // Size: 0x4
    // Offset: 0x70
    float weight;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Boolean destroyable
    // Size: 0x1
    // Offset: 0x74
    bool destroyable;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Boolean soulbound
    // Size: 0x1
    // Offset: 0x75
    bool soulbound;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: soulbound and: sellsfor
    char __padding16[0x2] = {};
    // public System.Int32 sellsfor
    // Size: 0x4
    // Offset: 0x78
    int sellsfor;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Int32 foilType
    // Size: 0x4
    // Offset: 0x7C
    int foilType;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.String model
    // Size: 0x8
    // Offset: 0x80
    ::StringW model;
    // Field size check
    static_assert(sizeof(::StringW) == 0x8);
    // private UnityEngine.Mesh _mesh
    // Size: 0x8
    // Offset: 0x88
    ::UnityEngine::Mesh* mesh;
    // Field size check
    static_assert(sizeof(::UnityEngine::Mesh*) == 0x8);
    // private UnityEngine.GameObject _instancePrefab
    // Size: 0x8
    // Offset: 0x90
    ::UnityEngine::GameObject* instancePrefab;
    // Field size check
    static_assert(sizeof(::UnityEngine::GameObject*) == 0x8);
    // private UnityEngine.GameObject _craftingPrefab
    // Size: 0x8
    // Offset: 0x98
    ::UnityEngine::GameObject* craftingPrefab;
    // Field size check
    static_assert(sizeof(::UnityEngine::GameObject*) == 0x8);
    // private UnityEngine.Texture _instanceTexture
    // Size: 0x8
    // Offset: 0xA0
    ::UnityEngine::Texture* instanceTexture;
    // Field size check
    static_assert(sizeof(::UnityEngine::Texture*) == 0x8);
    // private System.Boolean _triedFetchingMesh
    // Size: 0x1
    // Offset: 0xA8
    bool triedFetchingMesh;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Boolean _triedFetchingInstancePrefab
    // Size: 0x1
    // Offset: 0xA9
    bool triedFetchingInstancePrefab;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Boolean _triedFetchingCraftingPrefab
    // Size: 0x1
    // Offset: 0xAA
    bool triedFetchingCraftingPrefab;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Boolean _triedFetchingInstanceTexture
    // Size: 0x1
    // Offset: 0xAB
    bool triedFetchingInstanceTexture;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    public:
    // Get instance field reference: public System.Int32 id
    [[deprecated("Use field access instead!")]] int& dyn_id();
    // Get instance field reference: public System.String name
    [[deprecated("Use field access instead!")]] ::StringW& dyn_name();
    // Get instance field reference: public System.String htmlName
    [[deprecated("Use field access instead!")]] ::StringW& dyn_htmlName();
    // Get instance field reference: public System.String icon
    [[deprecated("Use field access instead!")]] ::StringW& dyn_icon();
    // Get instance field reference: public System.String description
    [[deprecated("Use field access instead!")]] ::StringW& dyn_description();
    // Get instance field reference: public System.String prefabName
    [[deprecated("Use field access instead!")]] ::StringW& dyn_prefabName();
    // Get instance field reference: private System.Boolean descriptionCached
    [[deprecated("Use field access instead!")]] bool& dyn_descriptionCached();
    // Get instance field reference: public System.Int32 maxstackable
    [[deprecated("Use field access instead!")]] int& dyn_maxstackable();
    // Get instance field reference: public System.String defaultRarity
    [[deprecated("Use field access instead!")]] ::StringW& dyn_defaultRarity();
    // Get instance field reference: public System.String type
    [[deprecated("Use field access instead!")]] ::StringW& dyn_type();
    // Get instance field reference: public System.String slot
    [[deprecated("Use field access instead!")]] ::StringW& dyn_slot();
    // Get instance field reference: public System.Int32 ilevel
    [[deprecated("Use field access instead!")]] int& dyn_ilevel();
    // Get instance field reference: public System.Int32 minlevel
    [[deprecated("Use field access instead!")]] int& dyn_minlevel();
    // Get instance field reference: public System.String reqclass
    [[deprecated("Use field access instead!")]] ::StringW& dyn_reqclass();
    // Get instance field reference: public System.Single weight
    [[deprecated("Use field access instead!")]] float& dyn_weight();
    // Get instance field reference: public System.Boolean destroyable
    [[deprecated("Use field access instead!")]] bool& dyn_destroyable();
    // Get instance field reference: public System.Boolean soulbound
    [[deprecated("Use field access instead!")]] bool& dyn_soulbound();
    // Get instance field reference: public System.Int32 sellsfor
    [[deprecated("Use field access instead!")]] int& dyn_sellsfor();
    // Get instance field reference: public System.Int32 foilType
    [[deprecated("Use field access instead!")]] int& dyn_foilType();
    // Get instance field reference: public System.String model
    [[deprecated("Use field access instead!")]] ::StringW& dyn_model();
    // Get instance field reference: private UnityEngine.Mesh _mesh
    [[deprecated("Use field access instead!")]] ::UnityEngine::Mesh*& dyn__mesh();
    // Get instance field reference: private UnityEngine.GameObject _instancePrefab
    [[deprecated("Use field access instead!")]] ::UnityEngine::GameObject*& dyn__instancePrefab();
    // Get instance field reference: private UnityEngine.GameObject _craftingPrefab
    [[deprecated("Use field access instead!")]] ::UnityEngine::GameObject*& dyn__craftingPrefab();
    // Get instance field reference: private UnityEngine.Texture _instanceTexture
    [[deprecated("Use field access instead!")]] ::UnityEngine::Texture*& dyn__instanceTexture();
    // Get instance field reference: private System.Boolean _triedFetchingMesh
    [[deprecated("Use field access instead!")]] bool& dyn__triedFetchingMesh();
    // Get instance field reference: private System.Boolean _triedFetchingInstancePrefab
    [[deprecated("Use field access instead!")]] bool& dyn__triedFetchingInstancePrefab();
    // Get instance field reference: private System.Boolean _triedFetchingCraftingPrefab
    [[deprecated("Use field access instead!")]] bool& dyn__triedFetchingCraftingPrefab();
    // Get instance field reference: private System.Boolean _triedFetchingInstanceTexture
    [[deprecated("Use field access instead!")]] bool& dyn__triedFetchingInstanceTexture();
    // private System.Void FetchMesh()
    // Offset: 0x28E327C
    void FetchMesh();
    // public UnityEngine.Mesh get_mesh()
    // Offset: 0x28E3520
    ::UnityEngine::Mesh* get_mesh();
    // public System.Void set_mesh(UnityEngine.Mesh value)
    // Offset: 0x28E3544
    void set_mesh(::UnityEngine::Mesh* value);
    // private System.Void FetchInstancePrefab()
    // Offset: 0x28E354C
    void FetchInstancePrefab();
    // public UnityEngine.GameObject get_instancePrefab()
    // Offset: 0x28E3700
    ::UnityEngine::GameObject* get_instancePrefab();
    // public System.Void set_instancePrefab(UnityEngine.GameObject value)
    // Offset: 0x28E3724
    void set_instancePrefab(::UnityEngine::GameObject* value);
    // private System.Void FetchCraftingPrefab()
    // Offset: 0x28E372C
    void FetchCraftingPrefab();
    // public UnityEngine.GameObject get_craftingPrefab()
    // Offset: 0x28E3934
    ::UnityEngine::GameObject* get_craftingPrefab();
    // public System.Void set_craftingPrefab(UnityEngine.GameObject value)
    // Offset: 0x28E3958
    void set_craftingPrefab(::UnityEngine::GameObject* value);
    // private System.Void FetchInstanceTexture()
    // Offset: 0x28E3960
    void FetchInstanceTexture();
    // public UnityEngine.Texture get_instanceTexture()
    // Offset: 0x28E3B14
    ::UnityEngine::Texture* get_instanceTexture();
    // public System.Void set_instanceTexture(UnityEngine.Texture value)
    // Offset: 0x28E3B38
    void set_instanceTexture(::UnityEngine::Texture* value);
    // public System.Void GetMeshAsync(System.Action`1<UnityEngine.Mesh> callback)
    // Offset: 0x28E3B40
    void GetMeshAsync(::System::Action_1<::UnityEngine::Mesh*>* callback);
    // public System.Void GetPrefabAsync(System.Action`1<UnityEngine.GameObject> callback)
    // Offset: 0x28E3E18
    void GetPrefabAsync(::System::Action_1<::UnityEngine::GameObject*>* callback);
    // public System.Void GetTextureAsync(System.Action`1<UnityEngine.Texture> callback)
    // Offset: 0x28E4040
    void GetTextureAsync(::System::Action_1<::UnityEngine::Texture*>* callback);
    // public System.Void .ctor(System.Int32 _itemid, System.String _name, System.String _icon, System.String _model, System.String _prefab, System.String _desc, System.Int32 _maxstackable, System.String _rarity, System.String _type, System.String _slot, System.Int32 _ilevel, System.Int32 _minlevel, System.String _reqclass, System.Single _weight, System.Int32 _destroyable, System.Int32 _soulbound, System.Int32 _sellsfor, System.Int32 _foiltype)
    // Offset: 0x28CEA70
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static InventoryItem* New_ctor(int _itemid, ::StringW _name, ::StringW _icon, ::StringW _model, ::StringW _prefab, ::StringW _desc, int _maxstackable, ::StringW _rarity, ::StringW _type, ::StringW _slot, int _ilevel, int _minlevel, ::StringW _reqclass, float _weight, int _destroyable, int _soulbound, int _sellsfor, int _foiltype) {
      static auto ___internal__logger = ::Logger::get().WithContext("::ExtUI::InventoryItem::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<InventoryItem*, creationType>(_itemid, _name, _icon, _model, _prefab, _desc, _maxstackable, _rarity, _type, _slot, _ilevel, _minlevel, _reqclass, _weight, _destroyable, _soulbound, _sellsfor, _foiltype)));
    }
    // public System.Void waitForDescription(System.Action callback)
    // Offset: 0x28D1108
    void waitForDescription(::System::Action* callback);
  }; // ExtUI.InventoryItem
  #pragma pack(pop)
  static check_size<sizeof(InventoryItem), 171 + sizeof(bool)> __ExtUI_InventoryItemSizeCheck;
  static_assert(sizeof(InventoryItem) == 0xAC);
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: ExtUI::InventoryItem::FetchMesh
// Il2CppName: FetchMesh
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (ExtUI::InventoryItem::*)()>(&ExtUI::InventoryItem::FetchMesh)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(ExtUI::InventoryItem*), "FetchMesh", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: ExtUI::InventoryItem::get_mesh
// Il2CppName: get_mesh
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Mesh* (ExtUI::InventoryItem::*)()>(&ExtUI::InventoryItem::get_mesh)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(ExtUI::InventoryItem*), "get_mesh", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: ExtUI::InventoryItem::set_mesh
// Il2CppName: set_mesh
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (ExtUI::InventoryItem::*)(::UnityEngine::Mesh*)>(&ExtUI::InventoryItem::set_mesh)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("UnityEngine", "Mesh")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(ExtUI::InventoryItem*), "set_mesh", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: ExtUI::InventoryItem::FetchInstancePrefab
// Il2CppName: FetchInstancePrefab
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (ExtUI::InventoryItem::*)()>(&ExtUI::InventoryItem::FetchInstancePrefab)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(ExtUI::InventoryItem*), "FetchInstancePrefab", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: ExtUI::InventoryItem::get_instancePrefab
// Il2CppName: get_instancePrefab
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::GameObject* (ExtUI::InventoryItem::*)()>(&ExtUI::InventoryItem::get_instancePrefab)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(ExtUI::InventoryItem*), "get_instancePrefab", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: ExtUI::InventoryItem::set_instancePrefab
// Il2CppName: set_instancePrefab
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (ExtUI::InventoryItem::*)(::UnityEngine::GameObject*)>(&ExtUI::InventoryItem::set_instancePrefab)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(ExtUI::InventoryItem*), "set_instancePrefab", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: ExtUI::InventoryItem::FetchCraftingPrefab
// Il2CppName: FetchCraftingPrefab
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (ExtUI::InventoryItem::*)()>(&ExtUI::InventoryItem::FetchCraftingPrefab)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(ExtUI::InventoryItem*), "FetchCraftingPrefab", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: ExtUI::InventoryItem::get_craftingPrefab
// Il2CppName: get_craftingPrefab
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::GameObject* (ExtUI::InventoryItem::*)()>(&ExtUI::InventoryItem::get_craftingPrefab)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(ExtUI::InventoryItem*), "get_craftingPrefab", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: ExtUI::InventoryItem::set_craftingPrefab
// Il2CppName: set_craftingPrefab
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (ExtUI::InventoryItem::*)(::UnityEngine::GameObject*)>(&ExtUI::InventoryItem::set_craftingPrefab)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(ExtUI::InventoryItem*), "set_craftingPrefab", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: ExtUI::InventoryItem::FetchInstanceTexture
// Il2CppName: FetchInstanceTexture
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (ExtUI::InventoryItem::*)()>(&ExtUI::InventoryItem::FetchInstanceTexture)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(ExtUI::InventoryItem*), "FetchInstanceTexture", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: ExtUI::InventoryItem::get_instanceTexture
// Il2CppName: get_instanceTexture
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Texture* (ExtUI::InventoryItem::*)()>(&ExtUI::InventoryItem::get_instanceTexture)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(ExtUI::InventoryItem*), "get_instanceTexture", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: ExtUI::InventoryItem::set_instanceTexture
// Il2CppName: set_instanceTexture
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (ExtUI::InventoryItem::*)(::UnityEngine::Texture*)>(&ExtUI::InventoryItem::set_instanceTexture)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("UnityEngine", "Texture")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(ExtUI::InventoryItem*), "set_instanceTexture", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: ExtUI::InventoryItem::GetMeshAsync
// Il2CppName: GetMeshAsync
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (ExtUI::InventoryItem::*)(::System::Action_1<::UnityEngine::Mesh*>*)>(&ExtUI::InventoryItem::GetMeshAsync)> {
  static const MethodInfo* get() {
    static auto* callback = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System", "Action`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("UnityEngine", "Mesh")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(ExtUI::InventoryItem*), "GetMeshAsync", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{callback});
  }
};
// Writing MetadataGetter for method: ExtUI::InventoryItem::GetPrefabAsync
// Il2CppName: GetPrefabAsync
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (ExtUI::InventoryItem::*)(::System::Action_1<::UnityEngine::GameObject*>*)>(&ExtUI::InventoryItem::GetPrefabAsync)> {
  static const MethodInfo* get() {
    static auto* callback = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System", "Action`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(ExtUI::InventoryItem*), "GetPrefabAsync", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{callback});
  }
};
// Writing MetadataGetter for method: ExtUI::InventoryItem::GetTextureAsync
// Il2CppName: GetTextureAsync
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (ExtUI::InventoryItem::*)(::System::Action_1<::UnityEngine::Texture*>*)>(&ExtUI::InventoryItem::GetTextureAsync)> {
  static const MethodInfo* get() {
    static auto* callback = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System", "Action`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("UnityEngine", "Texture")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(ExtUI::InventoryItem*), "GetTextureAsync", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{callback});
  }
};
// Writing MetadataGetter for method: ExtUI::InventoryItem::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: ExtUI::InventoryItem::waitForDescription
// Il2CppName: waitForDescription
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (ExtUI::InventoryItem::*)(::System::Action*)>(&ExtUI::InventoryItem::waitForDescription)> {
  static const MethodInfo* get() {
    static auto* callback = &::il2cpp_utils::GetClassFromName("System", "Action")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(ExtUI::InventoryItem*), "waitForDescription", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{callback});
  }
};
