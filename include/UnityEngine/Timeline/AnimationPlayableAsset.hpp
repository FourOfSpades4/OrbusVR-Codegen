// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: UnityEngine.Playables.PlayableAsset
#include "UnityEngine/Playables/PlayableAsset.hpp"
// Including type: UnityEngine.Timeline.ITimelineClipAsset
#include "UnityEngine/Timeline/ITimelineClipAsset.hpp"
// Including type: UnityEngine.Timeline.IPropertyPreview
#include "UnityEngine/Timeline/IPropertyPreview.hpp"
// Including type: UnityEngine.Timeline.IClipInitializer
#include "UnityEngine/Timeline/IClipInitializer.hpp"
// Including type: UnityEngine.ISerializationCallbackReceiver
#include "UnityEngine/ISerializationCallbackReceiver.hpp"
// Including type: UnityEngine.Timeline.MatchTargetFields
#include "UnityEngine/Timeline/MatchTargetFields.hpp"
// Including type: UnityEngine.Timeline.AppliedOffsetMode
#include "UnityEngine/Timeline/AppliedOffsetMode.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
// Completed includes
// Begin forward declares
// Forward declaring namespace: UnityEngine::Timeline
namespace UnityEngine::Timeline {
  // Forward declaring type: ClipCaps
  struct ClipCaps;
  // Forward declaring type: IPropertyCollector
  class IPropertyCollector;
  // Forward declaring type: TimelineClip
  class TimelineClip;
  // Forward declaring type: TrackAsset
  class TrackAsset;
}
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: AnimationClip
  class AnimationClip;
  // Forward declaring type: IExposedPropertyTable
  class IExposedPropertyTable;
  // Forward declaring type: GameObject
  class GameObject;
}
// Forward declaring namespace: UnityEngine::Playables
namespace UnityEngine::Playables {
  // Forward declaring type: Playable
  struct Playable;
  // Forward declaring type: PlayableGraph
  struct PlayableGraph;
  // Forward declaring type: PlayableDirector
  class PlayableDirector;
}
// Forward declaring namespace: System::Collections::Generic
namespace System::Collections::Generic {
  // Forward declaring type: IEnumerable`1<T>
  template<typename T>
  class IEnumerable_1;
}
// Completed forward declares
// Type namespace: UnityEngine.Timeline
namespace UnityEngine::Timeline {
  // Forward declaring type: AnimationPlayableAsset
  class AnimationPlayableAsset;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::UnityEngine::Timeline::AnimationPlayableAsset);
DEFINE_IL2CPP_ARG_TYPE(::UnityEngine::Timeline::AnimationPlayableAsset*, "UnityEngine.Timeline", "AnimationPlayableAsset");
// Type namespace: UnityEngine.Timeline
namespace UnityEngine::Timeline {
  // Size: 0x5C
  #pragma pack(push, 1)
  // Autogenerated type: UnityEngine.Timeline.AnimationPlayableAsset
  // [TokenAttribute] Offset: FFFFFFFF
  // [NotKeyableAttribute] Offset: FFFFFFFF
  class AnimationPlayableAsset : public ::UnityEngine::Playables::PlayableAsset/*, public ::UnityEngine::Timeline::ITimelineClipAsset, public ::UnityEngine::Timeline::IPropertyPreview, public ::UnityEngine::Timeline::IClipInitializer, public ::UnityEngine::ISerializationCallbackReceiver*/ {
    public:
    // Nested type: ::UnityEngine::Timeline::AnimationPlayableAsset::AnimationPlayableAssetUpgrade
    class AnimationPlayableAssetUpgrade;
    // Nested type: ::UnityEngine::Timeline::AnimationPlayableAsset::$$c__Iterator0
    class $$c__Iterator0;
    public:
    // private UnityEngine.AnimationClip m_Clip
    // Size: 0x8
    // Offset: 0x18
    ::UnityEngine::AnimationClip* m_Clip;
    // Field size check
    static_assert(sizeof(::UnityEngine::AnimationClip*) == 0x8);
    // private UnityEngine.Vector3 m_Position
    // Size: 0xC
    // Offset: 0x20
    ::UnityEngine::Vector3 m_Position;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private UnityEngine.Vector3 m_EulerAngles
    // Size: 0xC
    // Offset: 0x2C
    ::UnityEngine::Vector3 m_EulerAngles;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private System.Boolean m_UseTrackMatchFields
    // Size: 0x1
    // Offset: 0x38
    bool m_UseTrackMatchFields;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: m_UseTrackMatchFields and: m_MatchTargetFields
    char __padding3[0x3] = {};
    // private UnityEngine.Timeline.MatchTargetFields m_MatchTargetFields
    // Size: 0x4
    // Offset: 0x3C
    ::UnityEngine::Timeline::MatchTargetFields m_MatchTargetFields;
    // Field size check
    static_assert(sizeof(::UnityEngine::Timeline::MatchTargetFields) == 0x4);
    // private System.Boolean m_RemoveStartOffset
    // Size: 0x1
    // Offset: 0x40
    bool m_RemoveStartOffset;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Boolean m_ApplyFootIK
    // Size: 0x1
    // Offset: 0x41
    bool m_ApplyFootIK;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: m_ApplyFootIK and: appliedOffsetMode
    char __padding6[0x2] = {};
    // [CompilerGeneratedAttribute] Offset: 0xAAD7AC
    // [DebuggerBrowsableAttribute] Offset: 0xAAD7AC
    // private UnityEngine.Timeline.AppliedOffsetMode <appliedOffsetMode>k__BackingField
    // Size: 0x4
    // Offset: 0x44
    ::UnityEngine::Timeline::AppliedOffsetMode appliedOffsetMode;
    // Field size check
    static_assert(sizeof(::UnityEngine::Timeline::AppliedOffsetMode) == 0x4);
    // private System.Int32 m_Version
    // Size: 0x4
    // Offset: 0x48
    int m_Version;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // [ObsoleteAttribute] Offset: 0xAAD820
    // private UnityEngine.Quaternion m_Rotation
    // Size: 0x10
    // Offset: 0x4C
    ::UnityEngine::Quaternion m_Rotation;
    // Field size check
    static_assert(sizeof(::UnityEngine::Quaternion) == 0x10);
    public:
    // Creating interface conversion operator: operator ::UnityEngine::Timeline::ITimelineClipAsset
    operator ::UnityEngine::Timeline::ITimelineClipAsset() noexcept {
      return *reinterpret_cast<::UnityEngine::Timeline::ITimelineClipAsset*>(this);
    }
    // Creating interface conversion operator: operator ::UnityEngine::Timeline::IPropertyPreview
    operator ::UnityEngine::Timeline::IPropertyPreview() noexcept {
      return *reinterpret_cast<::UnityEngine::Timeline::IPropertyPreview*>(this);
    }
    // Creating interface conversion operator: operator ::UnityEngine::Timeline::IClipInitializer
    operator ::UnityEngine::Timeline::IClipInitializer() noexcept {
      return *reinterpret_cast<::UnityEngine::Timeline::IClipInitializer*>(this);
    }
    // Creating interface conversion operator: operator ::UnityEngine::ISerializationCallbackReceiver
    operator ::UnityEngine::ISerializationCallbackReceiver() noexcept {
      return *reinterpret_cast<::UnityEngine::ISerializationCallbackReceiver*>(this);
    }
    // Deleting conversion operator: operator ::System::IntPtr
    constexpr operator ::System::IntPtr() const noexcept = delete;
    // Get static field: static private readonly System.Int32 k_LatestVersion
    static int _get_k_LatestVersion();
    // Set static field: static private readonly System.Int32 k_LatestVersion
    static void _set_k_LatestVersion(int value);
    // Get instance field reference: private UnityEngine.AnimationClip m_Clip
    [[deprecated("Use field access instead!")]] ::UnityEngine::AnimationClip*& dyn_m_Clip();
    // Get instance field reference: private UnityEngine.Vector3 m_Position
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_m_Position();
    // Get instance field reference: private UnityEngine.Vector3 m_EulerAngles
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_m_EulerAngles();
    // Get instance field reference: private System.Boolean m_UseTrackMatchFields
    [[deprecated("Use field access instead!")]] bool& dyn_m_UseTrackMatchFields();
    // Get instance field reference: private UnityEngine.Timeline.MatchTargetFields m_MatchTargetFields
    [[deprecated("Use field access instead!")]] ::UnityEngine::Timeline::MatchTargetFields& dyn_m_MatchTargetFields();
    // Get instance field reference: private System.Boolean m_RemoveStartOffset
    [[deprecated("Use field access instead!")]] bool& dyn_m_RemoveStartOffset();
    // Get instance field reference: private System.Boolean m_ApplyFootIK
    [[deprecated("Use field access instead!")]] bool& dyn_m_ApplyFootIK();
    // Get instance field reference: private UnityEngine.Timeline.AppliedOffsetMode <appliedOffsetMode>k__BackingField
    [[deprecated("Use field access instead!")]] ::UnityEngine::Timeline::AppliedOffsetMode& dyn_$appliedOffsetMode$k__BackingField();
    // Get instance field reference: private System.Int32 m_Version
    [[deprecated("Use field access instead!")]] int& dyn_m_Version();
    // Get instance field reference: private UnityEngine.Quaternion m_Rotation
    [[deprecated("Use field access instead!")]] ::UnityEngine::Quaternion& dyn_m_Rotation();
    // public System.Void .ctor()
    // Offset: 0x1D8BC6C
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static AnimationPlayableAsset* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::Timeline::AnimationPlayableAsset::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<AnimationPlayableAsset*, creationType>()));
    }
    // public UnityEngine.Vector3 get_position()
    // Offset: 0x1D8BD64
    ::UnityEngine::Vector3 get_position();
    // public System.Void set_position(UnityEngine.Vector3 value)
    // Offset: 0x1D8BD70
    void set_position(::UnityEngine::Vector3 value);
    // public UnityEngine.Quaternion get_rotation()
    // Offset: 0x1D8BD7C
    ::UnityEngine::Quaternion get_rotation();
    // public System.Void set_rotation(UnityEngine.Quaternion value)
    // Offset: 0x1D8BE04
    void set_rotation(::UnityEngine::Quaternion value);
    // public UnityEngine.Vector3 get_eulerAngles()
    // Offset: 0x1D8BE44
    ::UnityEngine::Vector3 get_eulerAngles();
    // public System.Void set_eulerAngles(UnityEngine.Vector3 value)
    // Offset: 0x1D8BE50
    void set_eulerAngles(::UnityEngine::Vector3 value);
    // public System.Boolean get_useTrackMatchFields()
    // Offset: 0x1D8BE5C
    bool get_useTrackMatchFields();
    // public System.Void set_useTrackMatchFields(System.Boolean value)
    // Offset: 0x1D8BE64
    void set_useTrackMatchFields(bool value);
    // public UnityEngine.Timeline.MatchTargetFields get_matchTargetFields()
    // Offset: 0x1D8BE70
    ::UnityEngine::Timeline::MatchTargetFields get_matchTargetFields();
    // public System.Void set_matchTargetFields(UnityEngine.Timeline.MatchTargetFields value)
    // Offset: 0x1D8BE78
    void set_matchTargetFields(::UnityEngine::Timeline::MatchTargetFields value);
    // public System.Boolean get_removeStartOffset()
    // Offset: 0x1D8BE80
    bool get_removeStartOffset();
    // public System.Void set_removeStartOffset(System.Boolean value)
    // Offset: 0x1D8BE88
    void set_removeStartOffset(bool value);
    // public System.Boolean get_applyFootIK()
    // Offset: 0x1D8BE94
    bool get_applyFootIK();
    // public System.Void set_applyFootIK(System.Boolean value)
    // Offset: 0x1D8BE9C
    void set_applyFootIK(bool value);
    // System.Boolean get_hasRootTransforms()
    // Offset: 0x1D8BEA8
    bool get_hasRootTransforms();
    // UnityEngine.Timeline.AppliedOffsetMode get_appliedOffsetMode()
    // Offset: 0x1D8C068
    ::UnityEngine::Timeline::AppliedOffsetMode get_appliedOffsetMode();
    // System.Void set_appliedOffsetMode(UnityEngine.Timeline.AppliedOffsetMode value)
    // Offset: 0x1D8C070
    void set_appliedOffsetMode(::UnityEngine::Timeline::AppliedOffsetMode value);
    // public UnityEngine.AnimationClip get_clip()
    // Offset: 0x1D8C078
    ::UnityEngine::AnimationClip* get_clip();
    // public System.Void set_clip(UnityEngine.AnimationClip value)
    // Offset: 0x1D8C080
    void set_clip(::UnityEngine::AnimationClip* value);
    // static UnityEngine.Playables.Playable CreatePlayable(UnityEngine.Playables.PlayableGraph graph, UnityEngine.AnimationClip clip, UnityEngine.Vector3 positionOffset, UnityEngine.Vector3 eulerOffset, System.Boolean removeStartOffset, UnityEngine.Timeline.AppliedOffsetMode mode, System.Boolean applyFootIK)
    // Offset: 0x1D8C4DC
    static ::UnityEngine::Playables::Playable CreatePlayable(::UnityEngine::Playables::PlayableGraph graph, ::UnityEngine::AnimationClip* clip, ::UnityEngine::Vector3 positionOffset, ::UnityEngine::Vector3 eulerOffset, bool removeStartOffset, ::UnityEngine::Timeline::AppliedOffsetMode mode, bool applyFootIK);
    // static private System.Boolean ShouldApplyOffset(UnityEngine.Timeline.AppliedOffsetMode mode, UnityEngine.AnimationClip clip)
    // Offset: 0x1D8C894
    static bool ShouldApplyOffset(::UnityEngine::Timeline::AppliedOffsetMode mode, ::UnityEngine::AnimationClip* clip);
    // static private System.Boolean ShouldApplyScaleRemove(UnityEngine.Timeline.AppliedOffsetMode mode)
    // Offset: 0x1D8C86C
    static bool ShouldApplyScaleRemove(::UnityEngine::Timeline::AppliedOffsetMode mode);
    // public UnityEngine.Timeline.ClipCaps get_clipCaps()
    // Offset: 0x1D8C924
    ::UnityEngine::Timeline::ClipCaps get_clipCaps();
    // public System.Void ResetOffsets()
    // Offset: 0x1D8CA28
    void ResetOffsets();
    // public System.Void GatherProperties(UnityEngine.Playables.PlayableDirector director, UnityEngine.Timeline.IPropertyCollector driver)
    // Offset: 0x1D8CAA8
    void GatherProperties(::UnityEngine::Playables::PlayableDirector* director, ::UnityEngine::Timeline::IPropertyCollector* driver);
    // private System.Void UnityEngine.Timeline.IClipInitializer.OnCreate(UnityEngine.Timeline.TimelineClip newClip, UnityEngine.Timeline.TrackAsset owner, UnityEngine.IExposedPropertyTable resolver)
    // Offset: 0x1D8CB70
    void UnityEngine_Timeline_IClipInitializer_OnCreate(::UnityEngine::Timeline::TimelineClip* newClip, ::UnityEngine::Timeline::TrackAsset* owner, ::UnityEngine::IExposedPropertyTable* resolver);
    // static System.Boolean HasRootTransforms(UnityEngine.AnimationClip clip)
    // Offset: 0x1D8BF58
    static bool HasRootTransforms(::UnityEngine::AnimationClip* clip);
    // private System.Void UnityEngine.ISerializationCallbackReceiver.OnBeforeSerialize()
    // Offset: 0x1D8CC50
    void UnityEngine_ISerializationCallbackReceiver_OnBeforeSerialize();
    // private System.Void UnityEngine.ISerializationCallbackReceiver.OnAfterDeserialize()
    // Offset: 0x1D8CCC0
    void UnityEngine_ISerializationCallbackReceiver_OnAfterDeserialize();
    // private System.Void OnUpgradeFromVersion(System.Int32 oldVersion)
    // Offset: 0x1D8CD60
    void OnUpgradeFromVersion(int oldVersion);
    // static private System.Void .cctor()
    // Offset: 0x1D8CDD0
    static void _cctor();
    // public override System.Double get_duration()
    // Offset: 0x1D8C148
    // Implemented from: UnityEngine.Playables.PlayableAsset
    // Base method: System.Double PlayableAsset::get_duration()
    double get_duration();
    // public override System.Collections.Generic.IEnumerable`1<UnityEngine.Playables.PlayableBinding> get_outputs()
    // Offset: 0x1D8C364
    // Implemented from: UnityEngine.Playables.PlayableAsset
    // Base method: System.Collections.Generic.IEnumerable`1<UnityEngine.Playables.PlayableBinding> PlayableAsset::get_outputs()
    ::System::Collections::Generic::IEnumerable_1<::UnityEngine::Playables::PlayableBinding>* get_outputs();
    // public override UnityEngine.Playables.Playable CreatePlayable(UnityEngine.Playables.PlayableGraph graph, UnityEngine.GameObject go)
    // Offset: 0x1D8C3F8
    // Implemented from: UnityEngine.Playables.PlayableAsset
    // Base method: UnityEngine.Playables.Playable PlayableAsset::CreatePlayable(UnityEngine.Playables.PlayableGraph graph, UnityEngine.GameObject go)
    ::UnityEngine::Playables::Playable CreatePlayable(::UnityEngine::Playables::PlayableGraph graph, ::UnityEngine::GameObject* go);
  }; // UnityEngine.Timeline.AnimationPlayableAsset
  #pragma pack(pop)
  static check_size<sizeof(AnimationPlayableAsset), 76 + sizeof(::UnityEngine::Quaternion)> __UnityEngine_Timeline_AnimationPlayableAssetSizeCheck;
  static_assert(sizeof(AnimationPlayableAsset) == 0x5C);
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: UnityEngine::Timeline::AnimationPlayableAsset::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: UnityEngine::Timeline::AnimationPlayableAsset::get_position
// Il2CppName: get_position
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Vector3 (UnityEngine::Timeline::AnimationPlayableAsset::*)()>(&UnityEngine::Timeline::AnimationPlayableAsset::get_position)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::AnimationPlayableAsset*), "get_position", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::AnimationPlayableAsset::set_position
// Il2CppName: set_position
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::Timeline::AnimationPlayableAsset::*)(::UnityEngine::Vector3)>(&UnityEngine::Timeline::AnimationPlayableAsset::set_position)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::AnimationPlayableAsset*), "set_position", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::AnimationPlayableAsset::get_rotation
// Il2CppName: get_rotation
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Quaternion (UnityEngine::Timeline::AnimationPlayableAsset::*)()>(&UnityEngine::Timeline::AnimationPlayableAsset::get_rotation)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::AnimationPlayableAsset*), "get_rotation", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::AnimationPlayableAsset::set_rotation
// Il2CppName: set_rotation
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::Timeline::AnimationPlayableAsset::*)(::UnityEngine::Quaternion)>(&UnityEngine::Timeline::AnimationPlayableAsset::set_rotation)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("UnityEngine", "Quaternion")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::AnimationPlayableAsset*), "set_rotation", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::AnimationPlayableAsset::get_eulerAngles
// Il2CppName: get_eulerAngles
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Vector3 (UnityEngine::Timeline::AnimationPlayableAsset::*)()>(&UnityEngine::Timeline::AnimationPlayableAsset::get_eulerAngles)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::AnimationPlayableAsset*), "get_eulerAngles", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::AnimationPlayableAsset::set_eulerAngles
// Il2CppName: set_eulerAngles
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::Timeline::AnimationPlayableAsset::*)(::UnityEngine::Vector3)>(&UnityEngine::Timeline::AnimationPlayableAsset::set_eulerAngles)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::AnimationPlayableAsset*), "set_eulerAngles", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::AnimationPlayableAsset::get_useTrackMatchFields
// Il2CppName: get_useTrackMatchFields
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (UnityEngine::Timeline::AnimationPlayableAsset::*)()>(&UnityEngine::Timeline::AnimationPlayableAsset::get_useTrackMatchFields)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::AnimationPlayableAsset*), "get_useTrackMatchFields", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::AnimationPlayableAsset::set_useTrackMatchFields
// Il2CppName: set_useTrackMatchFields
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::Timeline::AnimationPlayableAsset::*)(bool)>(&UnityEngine::Timeline::AnimationPlayableAsset::set_useTrackMatchFields)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::AnimationPlayableAsset*), "set_useTrackMatchFields", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::AnimationPlayableAsset::get_matchTargetFields
// Il2CppName: get_matchTargetFields
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Timeline::MatchTargetFields (UnityEngine::Timeline::AnimationPlayableAsset::*)()>(&UnityEngine::Timeline::AnimationPlayableAsset::get_matchTargetFields)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::AnimationPlayableAsset*), "get_matchTargetFields", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::AnimationPlayableAsset::set_matchTargetFields
// Il2CppName: set_matchTargetFields
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::Timeline::AnimationPlayableAsset::*)(::UnityEngine::Timeline::MatchTargetFields)>(&UnityEngine::Timeline::AnimationPlayableAsset::set_matchTargetFields)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("UnityEngine.Timeline", "MatchTargetFields")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::AnimationPlayableAsset*), "set_matchTargetFields", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::AnimationPlayableAsset::get_removeStartOffset
// Il2CppName: get_removeStartOffset
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (UnityEngine::Timeline::AnimationPlayableAsset::*)()>(&UnityEngine::Timeline::AnimationPlayableAsset::get_removeStartOffset)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::AnimationPlayableAsset*), "get_removeStartOffset", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::AnimationPlayableAsset::set_removeStartOffset
// Il2CppName: set_removeStartOffset
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::Timeline::AnimationPlayableAsset::*)(bool)>(&UnityEngine::Timeline::AnimationPlayableAsset::set_removeStartOffset)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::AnimationPlayableAsset*), "set_removeStartOffset", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::AnimationPlayableAsset::get_applyFootIK
// Il2CppName: get_applyFootIK
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (UnityEngine::Timeline::AnimationPlayableAsset::*)()>(&UnityEngine::Timeline::AnimationPlayableAsset::get_applyFootIK)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::AnimationPlayableAsset*), "get_applyFootIK", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::AnimationPlayableAsset::set_applyFootIK
// Il2CppName: set_applyFootIK
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::Timeline::AnimationPlayableAsset::*)(bool)>(&UnityEngine::Timeline::AnimationPlayableAsset::set_applyFootIK)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::AnimationPlayableAsset*), "set_applyFootIK", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::AnimationPlayableAsset::get_hasRootTransforms
// Il2CppName: get_hasRootTransforms
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (UnityEngine::Timeline::AnimationPlayableAsset::*)()>(&UnityEngine::Timeline::AnimationPlayableAsset::get_hasRootTransforms)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::AnimationPlayableAsset*), "get_hasRootTransforms", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::AnimationPlayableAsset::get_appliedOffsetMode
// Il2CppName: get_appliedOffsetMode
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Timeline::AppliedOffsetMode (UnityEngine::Timeline::AnimationPlayableAsset::*)()>(&UnityEngine::Timeline::AnimationPlayableAsset::get_appliedOffsetMode)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::AnimationPlayableAsset*), "get_appliedOffsetMode", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::AnimationPlayableAsset::set_appliedOffsetMode
// Il2CppName: set_appliedOffsetMode
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::Timeline::AnimationPlayableAsset::*)(::UnityEngine::Timeline::AppliedOffsetMode)>(&UnityEngine::Timeline::AnimationPlayableAsset::set_appliedOffsetMode)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("UnityEngine.Timeline", "AppliedOffsetMode")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::AnimationPlayableAsset*), "set_appliedOffsetMode", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::AnimationPlayableAsset::get_clip
// Il2CppName: get_clip
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::AnimationClip* (UnityEngine::Timeline::AnimationPlayableAsset::*)()>(&UnityEngine::Timeline::AnimationPlayableAsset::get_clip)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::AnimationPlayableAsset*), "get_clip", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::AnimationPlayableAsset::set_clip
// Il2CppName: set_clip
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::Timeline::AnimationPlayableAsset::*)(::UnityEngine::AnimationClip*)>(&UnityEngine::Timeline::AnimationPlayableAsset::set_clip)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("UnityEngine", "AnimationClip")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::AnimationPlayableAsset*), "set_clip", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::AnimationPlayableAsset::CreatePlayable
// Il2CppName: CreatePlayable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Playables::Playable (*)(::UnityEngine::Playables::PlayableGraph, ::UnityEngine::AnimationClip*, ::UnityEngine::Vector3, ::UnityEngine::Vector3, bool, ::UnityEngine::Timeline::AppliedOffsetMode, bool)>(&UnityEngine::Timeline::AnimationPlayableAsset::CreatePlayable)> {
  static const MethodInfo* get() {
    static auto* graph = &::il2cpp_utils::GetClassFromName("UnityEngine.Playables", "PlayableGraph")->byval_arg;
    static auto* clip = &::il2cpp_utils::GetClassFromName("UnityEngine", "AnimationClip")->byval_arg;
    static auto* positionOffset = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* eulerOffset = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* removeStartOffset = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* mode = &::il2cpp_utils::GetClassFromName("UnityEngine.Timeline", "AppliedOffsetMode")->byval_arg;
    static auto* applyFootIK = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::AnimationPlayableAsset*), "CreatePlayable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{graph, clip, positionOffset, eulerOffset, removeStartOffset, mode, applyFootIK});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::AnimationPlayableAsset::ShouldApplyOffset
// Il2CppName: ShouldApplyOffset
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)(::UnityEngine::Timeline::AppliedOffsetMode, ::UnityEngine::AnimationClip*)>(&UnityEngine::Timeline::AnimationPlayableAsset::ShouldApplyOffset)> {
  static const MethodInfo* get() {
    static auto* mode = &::il2cpp_utils::GetClassFromName("UnityEngine.Timeline", "AppliedOffsetMode")->byval_arg;
    static auto* clip = &::il2cpp_utils::GetClassFromName("UnityEngine", "AnimationClip")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::AnimationPlayableAsset*), "ShouldApplyOffset", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{mode, clip});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::AnimationPlayableAsset::ShouldApplyScaleRemove
// Il2CppName: ShouldApplyScaleRemove
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)(::UnityEngine::Timeline::AppliedOffsetMode)>(&UnityEngine::Timeline::AnimationPlayableAsset::ShouldApplyScaleRemove)> {
  static const MethodInfo* get() {
    static auto* mode = &::il2cpp_utils::GetClassFromName("UnityEngine.Timeline", "AppliedOffsetMode")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::AnimationPlayableAsset*), "ShouldApplyScaleRemove", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{mode});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::AnimationPlayableAsset::get_clipCaps
// Il2CppName: get_clipCaps
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Timeline::ClipCaps (UnityEngine::Timeline::AnimationPlayableAsset::*)()>(&UnityEngine::Timeline::AnimationPlayableAsset::get_clipCaps)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::AnimationPlayableAsset*), "get_clipCaps", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::AnimationPlayableAsset::ResetOffsets
// Il2CppName: ResetOffsets
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::Timeline::AnimationPlayableAsset::*)()>(&UnityEngine::Timeline::AnimationPlayableAsset::ResetOffsets)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::AnimationPlayableAsset*), "ResetOffsets", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::AnimationPlayableAsset::GatherProperties
// Il2CppName: GatherProperties
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::Timeline::AnimationPlayableAsset::*)(::UnityEngine::Playables::PlayableDirector*, ::UnityEngine::Timeline::IPropertyCollector*)>(&UnityEngine::Timeline::AnimationPlayableAsset::GatherProperties)> {
  static const MethodInfo* get() {
    static auto* director = &::il2cpp_utils::GetClassFromName("UnityEngine.Playables", "PlayableDirector")->byval_arg;
    static auto* driver = &::il2cpp_utils::GetClassFromName("UnityEngine.Timeline", "IPropertyCollector")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::AnimationPlayableAsset*), "GatherProperties", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{director, driver});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::AnimationPlayableAsset::UnityEngine_Timeline_IClipInitializer_OnCreate
// Il2CppName: UnityEngine.Timeline.IClipInitializer.OnCreate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::Timeline::AnimationPlayableAsset::*)(::UnityEngine::Timeline::TimelineClip*, ::UnityEngine::Timeline::TrackAsset*, ::UnityEngine::IExposedPropertyTable*)>(&UnityEngine::Timeline::AnimationPlayableAsset::UnityEngine_Timeline_IClipInitializer_OnCreate)> {
  static const MethodInfo* get() {
    static auto* newClip = &::il2cpp_utils::GetClassFromName("UnityEngine.Timeline", "TimelineClip")->byval_arg;
    static auto* owner = &::il2cpp_utils::GetClassFromName("UnityEngine.Timeline", "TrackAsset")->byval_arg;
    static auto* resolver = &::il2cpp_utils::GetClassFromName("UnityEngine", "IExposedPropertyTable")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::AnimationPlayableAsset*), "UnityEngine.Timeline.IClipInitializer.OnCreate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{newClip, owner, resolver});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::AnimationPlayableAsset::HasRootTransforms
// Il2CppName: HasRootTransforms
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)(::UnityEngine::AnimationClip*)>(&UnityEngine::Timeline::AnimationPlayableAsset::HasRootTransforms)> {
  static const MethodInfo* get() {
    static auto* clip = &::il2cpp_utils::GetClassFromName("UnityEngine", "AnimationClip")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::AnimationPlayableAsset*), "HasRootTransforms", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{clip});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::AnimationPlayableAsset::UnityEngine_ISerializationCallbackReceiver_OnBeforeSerialize
// Il2CppName: UnityEngine.ISerializationCallbackReceiver.OnBeforeSerialize
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::Timeline::AnimationPlayableAsset::*)()>(&UnityEngine::Timeline::AnimationPlayableAsset::UnityEngine_ISerializationCallbackReceiver_OnBeforeSerialize)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::AnimationPlayableAsset*), "UnityEngine.ISerializationCallbackReceiver.OnBeforeSerialize", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::AnimationPlayableAsset::UnityEngine_ISerializationCallbackReceiver_OnAfterDeserialize
// Il2CppName: UnityEngine.ISerializationCallbackReceiver.OnAfterDeserialize
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::Timeline::AnimationPlayableAsset::*)()>(&UnityEngine::Timeline::AnimationPlayableAsset::UnityEngine_ISerializationCallbackReceiver_OnAfterDeserialize)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::AnimationPlayableAsset*), "UnityEngine.ISerializationCallbackReceiver.OnAfterDeserialize", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::AnimationPlayableAsset::OnUpgradeFromVersion
// Il2CppName: OnUpgradeFromVersion
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::Timeline::AnimationPlayableAsset::*)(int)>(&UnityEngine::Timeline::AnimationPlayableAsset::OnUpgradeFromVersion)> {
  static const MethodInfo* get() {
    static auto* oldVersion = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::AnimationPlayableAsset*), "OnUpgradeFromVersion", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{oldVersion});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::AnimationPlayableAsset::_cctor
// Il2CppName: .cctor
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)()>(&UnityEngine::Timeline::AnimationPlayableAsset::_cctor)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::AnimationPlayableAsset*), ".cctor", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::AnimationPlayableAsset::get_duration
// Il2CppName: get_duration
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<double (UnityEngine::Timeline::AnimationPlayableAsset::*)()>(&UnityEngine::Timeline::AnimationPlayableAsset::get_duration)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::AnimationPlayableAsset*), "get_duration", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::AnimationPlayableAsset::get_outputs
// Il2CppName: get_outputs
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Collections::Generic::IEnumerable_1<::UnityEngine::Playables::PlayableBinding>* (UnityEngine::Timeline::AnimationPlayableAsset::*)()>(&UnityEngine::Timeline::AnimationPlayableAsset::get_outputs)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::AnimationPlayableAsset*), "get_outputs", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::AnimationPlayableAsset::CreatePlayable
// Il2CppName: CreatePlayable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Playables::Playable (UnityEngine::Timeline::AnimationPlayableAsset::*)(::UnityEngine::Playables::PlayableGraph, ::UnityEngine::GameObject*)>(&UnityEngine::Timeline::AnimationPlayableAsset::CreatePlayable)> {
  static const MethodInfo* get() {
    static auto* graph = &::il2cpp_utils::GetClassFromName("UnityEngine.Playables", "PlayableGraph")->byval_arg;
    static auto* go = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::AnimationPlayableAsset*), "CreatePlayable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{graph, go});
  }
};
