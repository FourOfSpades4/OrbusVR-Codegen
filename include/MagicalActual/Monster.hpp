// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: UnityEngine.MonoBehaviour
#include "UnityEngine/MonoBehaviour.hpp"
// Including type: IPooling
#include "GlobalNamespace/IPooling.hpp"
// Including type: UnityEngine.Vector4
#include "UnityEngine/Vector4.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
#include "beatsaber-hook/shared/utils/typedefs-string.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: MagicalActual
namespace MagicalActual {
  // Forward declaring type: OrbusHealthBar
  class OrbusHealthBar;
  // Forward declaring type: NetEntity
  class NetEntity;
  // Forward declaring type: StatusEffect
  class StatusEffect;
  // Forward declaring type: HealthChangedEvent
  class HealthChangedEvent;
  // Forward declaring type: ObjectHighlighter
  class ObjectHighlighter;
  // Forward declaring type: WarriorCollisionBox
  class WarriorCollisionBox;
}
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: Animator
  class Animator;
  // Forward declaring type: AudioClip
  class AudioClip;
  // Forward declaring type: AudioSource
  class AudioSource;
  // Forward declaring type: GameObject
  class GameObject;
  // Forward declaring type: Transform
  class Transform;
  // Skipping declaration: Vector3 because it is already included!
  // Skipping declaration: Quaternion because it is already included!
}
// Forward declaring namespace: System::Collections::Generic
namespace System::Collections::Generic {
  // Forward declaring type: List`1<T>
  template<typename T>
  class List_1;
  // Forward declaring type: Dictionary`2<TKey, TValue>
  template<typename TKey, typename TValue>
  class Dictionary_2;
}
// Forward declaring namespace: GlobalNamespace
namespace GlobalNamespace {
  // Forward declaring type: ProgressBarPro
  class ProgressBarPro;
  // Forward declaring type: SuperTextMesh
  class SuperTextMesh;
  // Forward declaring type: QuickProjectileManager
  class QuickProjectileManager;
}
// Forward declaring namespace: System::Collections
namespace System::Collections {
  // Forward declaring type: IEnumerator
  class IEnumerator;
}
// Completed forward declares
// Type namespace: MagicalActual
namespace MagicalActual {
  // Forward declaring type: Monster
  class Monster;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::MagicalActual::Monster);
DEFINE_IL2CPP_ARG_TYPE(::MagicalActual::Monster*, "MagicalActual", "Monster");
// Type namespace: MagicalActual
namespace MagicalActual {
  // Size: 0x142
  #pragma pack(push, 1)
  // Autogenerated type: MagicalActual.Monster
  // [TokenAttribute] Offset: FFFFFFFF
  class Monster : public ::UnityEngine::MonoBehaviour/*, public ::GlobalNamespace::IPooling*/ {
    public:
    // Nested type: ::MagicalActual::Monster::$Shrink$d__92
    class $Shrink$d__92;
    // Nested type: ::MagicalActual::Monster::$$c__DisplayClass93_0
    class $$c__DisplayClass93_0;
    public:
    // public MagicalActual.OrbusHealthBar healthBar
    // Size: 0x8
    // Offset: 0x18
    ::MagicalActual::OrbusHealthBar* healthBar;
    // Field size check
    static_assert(sizeof(::MagicalActual::OrbusHealthBar*) == 0x8);
    // public UnityEngine.Animator animator
    // Size: 0x8
    // Offset: 0x20
    ::UnityEngine::Animator* animator;
    // Field size check
    static_assert(sizeof(::UnityEngine::Animator*) == 0x8);
    // public System.String OrbusNetComponent
    // Size: 0x8
    // Offset: 0x28
    ::StringW OrbusNetComponent;
    // Field size check
    static_assert(sizeof(::StringW) == 0x8);
    // [CompilerGeneratedAttribute] Offset: 0xAE4818
    // private MagicalActual.NetEntity <JANFCAJMFMP>k__BackingField
    // Size: 0x8
    // Offset: 0x30
    ::MagicalActual::NetEntity* JANFCAJMFMP;
    // Field size check
    static_assert(sizeof(::MagicalActual::NetEntity*) == 0x8);
    // public System.Int32 hitPointsReadOnly
    // Size: 0x4
    // Offset: 0x38
    int hitPointsReadOnly;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Boolean isDead
    // Size: 0x1
    // Offset: 0x3C
    bool isDead;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Boolean isMyPlayer
    // Size: 0x1
    // Offset: 0x3D
    bool isMyPlayer;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: isMyPlayer and: sfxNames
    char __padding6[0x2] = {};
    // public System.Collections.Generic.List`1<System.String> sfxNames
    // Size: 0x8
    // Offset: 0x40
    ::System::Collections::Generic::List_1<::StringW>* sfxNames;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::List_1<::StringW>*) == 0x8);
    // public UnityEngine.AudioClip[] sfxFiles
    // Size: 0x8
    // Offset: 0x48
    ::ArrayW<::UnityEngine::AudioClip*> sfxFiles;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::AudioClip*>) == 0x8);
    // private UnityEngine.AudioSource FPMFLCCJLMB
    // Size: 0x8
    // Offset: 0x50
    ::UnityEngine::AudioSource* FPMFLCCJLMB;
    // Field size check
    static_assert(sizeof(::UnityEngine::AudioSource*) == 0x8);
    // public System.Collections.Generic.List`1<System.String> vfxNames
    // Size: 0x8
    // Offset: 0x58
    ::System::Collections::Generic::List_1<::StringW>* vfxNames;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::List_1<::StringW>*) == 0x8);
    // public UnityEngine.GameObject[] vfxObjs
    // Size: 0x8
    // Offset: 0x60
    ::ArrayW<::UnityEngine::GameObject*> vfxObjs;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::GameObject*>) == 0x8);
    // public System.Collections.Generic.List`1<UnityEngine.Vector4> elementalResistances
    // Size: 0x8
    // Offset: 0x68
    ::System::Collections::Generic::List_1<::UnityEngine::Vector4>* elementalResistances;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::List_1<::UnityEngine::Vector4>*) == 0x8);
    // public System.Collections.Generic.Dictionary`2<System.Single,MagicalActual.StatusEffect> statusEffects
    // Size: 0x8
    // Offset: 0x70
    ::System::Collections::Generic::Dictionary_2<float, ::MagicalActual::StatusEffect*>* statusEffects;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::Dictionary_2<float, ::MagicalActual::StatusEffect*>*) == 0x8);
    // public MagicalActual.NetEntity currentTrackingTargetEntity
    // Size: 0x8
    // Offset: 0x78
    ::MagicalActual::NetEntity* currentTrackingTargetEntity;
    // Field size check
    static_assert(sizeof(::MagicalActual::NetEntity*) == 0x8);
    // public UnityEngine.Transform currentTrackingTargetAvatarTransform
    // Size: 0x8
    // Offset: 0x80
    ::UnityEngine::Transform* currentTrackingTargetAvatarTransform;
    // Field size check
    static_assert(sizeof(::UnityEngine::Transform*) == 0x8);
    // public MagicalActual.HealthChangedEvent onHealthChanged
    // Size: 0x8
    // Offset: 0x88
    ::MagicalActual::HealthChangedEvent* onHealthChanged;
    // Field size check
    static_assert(sizeof(::MagicalActual::HealthChangedEvent*) == 0x8);
    // private UnityEngine.GameObject IKANFIAFBKH
    // Size: 0x8
    // Offset: 0x90
    ::UnityEngine::GameObject* IKANFIAFBKH;
    // Field size check
    static_assert(sizeof(::UnityEngine::GameObject*) == 0x8);
    // private UnityEngine.GameObject GIKDCEOHCGA
    // Size: 0x8
    // Offset: 0x98
    ::UnityEngine::GameObject* GIKDCEOHCGA;
    // Field size check
    static_assert(sizeof(::UnityEngine::GameObject*) == 0x8);
    // private ProgressBarPro ODFMDJNIKNJ
    // Size: 0x8
    // Offset: 0xA0
    ::GlobalNamespace::ProgressBarPro* ODFMDJNIKNJ;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::ProgressBarPro*) == 0x8);
    // private SuperTextMesh BDKCLFBECPK
    // Size: 0x8
    // Offset: 0xA8
    ::GlobalNamespace::SuperTextMesh* BDKCLFBECPK;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::SuperTextMesh*) == 0x8);
    // private ProgressBarPro MEKBPGKBGCF
    // Size: 0x8
    // Offset: 0xB0
    ::GlobalNamespace::ProgressBarPro* MEKBPGKBGCF;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::ProgressBarPro*) == 0x8);
    // private UnityEngine.GameObject BIOMGAOEFGP
    // Size: 0x8
    // Offset: 0xB8
    ::UnityEngine::GameObject* BIOMGAOEFGP;
    // Field size check
    static_assert(sizeof(::UnityEngine::GameObject*) == 0x8);
    // private UnityEngine.GameObject CFLHBNBNAMB
    // Size: 0x8
    // Offset: 0xC0
    ::UnityEngine::GameObject* CFLHBNBNAMB;
    // Field size check
    static_assert(sizeof(::UnityEngine::GameObject*) == 0x8);
    // private System.Single CNAPHEPCBBF
    // Size: 0x4
    // Offset: 0xC8
    float CNAPHEPCBBF;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single KNJJJMBDGLM
    // Size: 0x4
    // Offset: 0xCC
    float KNJJJMBDGLM;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Boolean OJMMNOELIGK
    // Size: 0x1
    // Offset: 0xD0
    bool OJMMNOELIGK;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Boolean hasNavAgent
    // Size: 0x1
    // Offset: 0xD1
    bool hasNavAgent;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: hasNavAgent and: overrideHitPoints
    char __padding27[0x2] = {};
    // public System.Int32 overrideHitPoints
    // Size: 0x4
    // Offset: 0xD4
    int overrideHitPoints;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Boolean isElite
    // Size: 0x1
    // Offset: 0xD8
    bool isElite;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Boolean isBoss
    // Size: 0x1
    // Offset: 0xD9
    bool isBoss;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Boolean isPlayer
    // Size: 0x1
    // Offset: 0xDA
    bool isPlayer;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: isPlayer and: monsterTypes
    char __padding31[0x5] = {};
    // public System.String monsterTypes
    // Size: 0x8
    // Offset: 0xE0
    ::StringW monsterTypes;
    // Field size check
    static_assert(sizeof(::StringW) == 0x8);
    // public System.Boolean dontAllowSwordRush
    // Size: 0x1
    // Offset: 0xE8
    bool dontAllowSwordRush;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Boolean cowerInCombat
    // Size: 0x1
    // Offset: 0xE9
    bool cowerInCombat;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: cowerInCombat and: quickProjectileManager
    char __padding34[0x6] = {};
    // public QuickProjectileManager quickProjectileManager
    // Size: 0x8
    // Offset: 0xF0
    ::GlobalNamespace::QuickProjectileManager* quickProjectileManager;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::QuickProjectileManager*) == 0x8);
    // private System.Single OHJDNHHIFHK
    // Size: 0x4
    // Offset: 0xF8
    float OHJDNHHIFHK;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single ADBBAIDJACG
    // Size: 0x4
    // Offset: 0xFC
    float ADBBAIDJACG;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private MagicalActual.ObjectHighlighter MCBDFEDENMG
    // Size: 0x8
    // Offset: 0x100
    ::MagicalActual::ObjectHighlighter* MCBDFEDENMG;
    // Field size check
    static_assert(sizeof(::MagicalActual::ObjectHighlighter*) == 0x8);
    // private System.Byte JPDILBEOHAL
    // Size: 0x1
    // Offset: 0x108
    uint8_t JPDILBEOHAL;
    // Field size check
    static_assert(sizeof(uint8_t) == 0x1);
    // Padding between fields: JPDILBEOHAL and: OKOHIIPBADD
    char __padding39[0x7] = {};
    // private MagicalActual.WarriorCollisionBox OKOHIIPBADD
    // Size: 0x8
    // Offset: 0x110
    ::MagicalActual::WarriorCollisionBox* OKOHIIPBADD;
    // Field size check
    static_assert(sizeof(::MagicalActual::WarriorCollisionBox*) == 0x8);
    // public System.Int32 hitPoints
    // Size: 0x4
    // Offset: 0x118
    int hitPoints;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Int32 maxHitPoints
    // Size: 0x4
    // Offset: 0x11C
    int maxHitPoints;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Single NIANOECADMH
    // Size: 0x4
    // Offset: 0x120
    float NIANOECADMH;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.UInt16 currentTrackingTargetGuid
    // Size: 0x2
    // Offset: 0x124
    uint16_t currentTrackingTargetGuid;
    // Field size check
    static_assert(sizeof(uint16_t) == 0x2);
    // Padding between fields: currentTrackingTargetGuid and: willLevel
    char __padding44[0x2] = {};
    // public System.Int32 willLevel
    // Size: 0x4
    // Offset: 0x128
    int willLevel;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Boolean inCombat
    // Size: 0x1
    // Offset: 0x12C
    bool inCombat;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: inCombat and: monsterName
    char __padding46[0x3] = {};
    // public System.String monsterName
    // Size: 0x8
    // Offset: 0x130
    ::StringW monsterName;
    // Field size check
    static_assert(sizeof(::StringW) == 0x8);
    // public System.String monsterType
    // Size: 0x8
    // Offset: 0x138
    ::StringW monsterType;
    // Field size check
    static_assert(sizeof(::StringW) == 0x8);
    // [CompilerGeneratedAttribute] Offset: 0xAE4918
    // private System.Boolean <NENDEFCJJIG>k__BackingField
    // Size: 0x1
    // Offset: 0x140
    bool NENDEFCJJIG;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Boolean isBlocking
    // Size: 0x1
    // Offset: 0x141
    bool isBlocking;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    public:
    // Creating interface conversion operator: operator ::GlobalNamespace::IPooling
    operator ::GlobalNamespace::IPooling() noexcept {
      return *reinterpret_cast<::GlobalNamespace::IPooling*>(this);
    }
    // Deleting conversion operator: operator ::System::IntPtr
    constexpr operator ::System::IntPtr() const noexcept = delete;
    // Get instance field reference: public MagicalActual.OrbusHealthBar healthBar
    [[deprecated("Use field access instead!")]] ::MagicalActual::OrbusHealthBar*& dyn_healthBar();
    // Get instance field reference: public UnityEngine.Animator animator
    [[deprecated("Use field access instead!")]] ::UnityEngine::Animator*& dyn_animator();
    // Get instance field reference: public System.String OrbusNetComponent
    [[deprecated("Use field access instead!")]] ::StringW& dyn_OrbusNetComponent();
    // Get instance field reference: private MagicalActual.NetEntity <JANFCAJMFMP>k__BackingField
    [[deprecated("Use field access instead!")]] ::MagicalActual::NetEntity*& dyn_$JANFCAJMFMP$k__BackingField();
    // Get instance field reference: public System.Int32 hitPointsReadOnly
    [[deprecated("Use field access instead!")]] int& dyn_hitPointsReadOnly();
    // Get instance field reference: public System.Boolean isDead
    [[deprecated("Use field access instead!")]] bool& dyn_isDead();
    // Get instance field reference: public System.Boolean isMyPlayer
    [[deprecated("Use field access instead!")]] bool& dyn_isMyPlayer();
    // Get instance field reference: public System.Collections.Generic.List`1<System.String> sfxNames
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::List_1<::StringW>*& dyn_sfxNames();
    // Get instance field reference: public UnityEngine.AudioClip[] sfxFiles
    [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::AudioClip*>& dyn_sfxFiles();
    // Get instance field reference: private UnityEngine.AudioSource FPMFLCCJLMB
    [[deprecated("Use field access instead!")]] ::UnityEngine::AudioSource*& dyn_FPMFLCCJLMB();
    // Get instance field reference: public System.Collections.Generic.List`1<System.String> vfxNames
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::List_1<::StringW>*& dyn_vfxNames();
    // Get instance field reference: public UnityEngine.GameObject[] vfxObjs
    [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::GameObject*>& dyn_vfxObjs();
    // Get instance field reference: public System.Collections.Generic.List`1<UnityEngine.Vector4> elementalResistances
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::List_1<::UnityEngine::Vector4>*& dyn_elementalResistances();
    // Get instance field reference: public System.Collections.Generic.Dictionary`2<System.Single,MagicalActual.StatusEffect> statusEffects
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::Dictionary_2<float, ::MagicalActual::StatusEffect*>*& dyn_statusEffects();
    // Get instance field reference: public MagicalActual.NetEntity currentTrackingTargetEntity
    [[deprecated("Use field access instead!")]] ::MagicalActual::NetEntity*& dyn_currentTrackingTargetEntity();
    // Get instance field reference: public UnityEngine.Transform currentTrackingTargetAvatarTransform
    [[deprecated("Use field access instead!")]] ::UnityEngine::Transform*& dyn_currentTrackingTargetAvatarTransform();
    // Get instance field reference: public MagicalActual.HealthChangedEvent onHealthChanged
    [[deprecated("Use field access instead!")]] ::MagicalActual::HealthChangedEvent*& dyn_onHealthChanged();
    // Get instance field reference: private UnityEngine.GameObject IKANFIAFBKH
    [[deprecated("Use field access instead!")]] ::UnityEngine::GameObject*& dyn_IKANFIAFBKH();
    // Get instance field reference: private UnityEngine.GameObject GIKDCEOHCGA
    [[deprecated("Use field access instead!")]] ::UnityEngine::GameObject*& dyn_GIKDCEOHCGA();
    // Get instance field reference: private ProgressBarPro ODFMDJNIKNJ
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::ProgressBarPro*& dyn_ODFMDJNIKNJ();
    // Get instance field reference: private SuperTextMesh BDKCLFBECPK
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::SuperTextMesh*& dyn_BDKCLFBECPK();
    // Get instance field reference: private ProgressBarPro MEKBPGKBGCF
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::ProgressBarPro*& dyn_MEKBPGKBGCF();
    // Get instance field reference: private UnityEngine.GameObject BIOMGAOEFGP
    [[deprecated("Use field access instead!")]] ::UnityEngine::GameObject*& dyn_BIOMGAOEFGP();
    // Get instance field reference: private UnityEngine.GameObject CFLHBNBNAMB
    [[deprecated("Use field access instead!")]] ::UnityEngine::GameObject*& dyn_CFLHBNBNAMB();
    // Get instance field reference: private System.Single CNAPHEPCBBF
    [[deprecated("Use field access instead!")]] float& dyn_CNAPHEPCBBF();
    // Get instance field reference: private System.Single KNJJJMBDGLM
    [[deprecated("Use field access instead!")]] float& dyn_KNJJJMBDGLM();
    // Get instance field reference: private System.Boolean OJMMNOELIGK
    [[deprecated("Use field access instead!")]] bool& dyn_OJMMNOELIGK();
    // Get instance field reference: public System.Boolean hasNavAgent
    [[deprecated("Use field access instead!")]] bool& dyn_hasNavAgent();
    // Get instance field reference: public System.Int32 overrideHitPoints
    [[deprecated("Use field access instead!")]] int& dyn_overrideHitPoints();
    // Get instance field reference: public System.Boolean isElite
    [[deprecated("Use field access instead!")]] bool& dyn_isElite();
    // Get instance field reference: public System.Boolean isBoss
    [[deprecated("Use field access instead!")]] bool& dyn_isBoss();
    // Get instance field reference: public System.Boolean isPlayer
    [[deprecated("Use field access instead!")]] bool& dyn_isPlayer();
    // Get instance field reference: public System.String monsterTypes
    [[deprecated("Use field access instead!")]] ::StringW& dyn_monsterTypes();
    // Get instance field reference: public System.Boolean dontAllowSwordRush
    [[deprecated("Use field access instead!")]] bool& dyn_dontAllowSwordRush();
    // Get instance field reference: public System.Boolean cowerInCombat
    [[deprecated("Use field access instead!")]] bool& dyn_cowerInCombat();
    // Get instance field reference: public QuickProjectileManager quickProjectileManager
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::QuickProjectileManager*& dyn_quickProjectileManager();
    // Get instance field reference: private System.Single OHJDNHHIFHK
    [[deprecated("Use field access instead!")]] float& dyn_OHJDNHHIFHK();
    // Get instance field reference: private System.Single ADBBAIDJACG
    [[deprecated("Use field access instead!")]] float& dyn_ADBBAIDJACG();
    // Get instance field reference: private MagicalActual.ObjectHighlighter MCBDFEDENMG
    [[deprecated("Use field access instead!")]] ::MagicalActual::ObjectHighlighter*& dyn_MCBDFEDENMG();
    // Get instance field reference: private System.Byte JPDILBEOHAL
    [[deprecated("Use field access instead!")]] uint8_t& dyn_JPDILBEOHAL();
    // Get instance field reference: private MagicalActual.WarriorCollisionBox OKOHIIPBADD
    [[deprecated("Use field access instead!")]] ::MagicalActual::WarriorCollisionBox*& dyn_OKOHIIPBADD();
    // Get instance field reference: public System.Int32 hitPoints
    [[deprecated("Use field access instead!")]] int& dyn_hitPoints();
    // Get instance field reference: public System.Int32 maxHitPoints
    [[deprecated("Use field access instead!")]] int& dyn_maxHitPoints();
    // Get instance field reference: private System.Single NIANOECADMH
    [[deprecated("Use field access instead!")]] float& dyn_NIANOECADMH();
    // Get instance field reference: public System.UInt16 currentTrackingTargetGuid
    [[deprecated("Use field access instead!")]] uint16_t& dyn_currentTrackingTargetGuid();
    // Get instance field reference: public System.Int32 willLevel
    [[deprecated("Use field access instead!")]] int& dyn_willLevel();
    // Get instance field reference: public System.Boolean inCombat
    [[deprecated("Use field access instead!")]] bool& dyn_inCombat();
    // Get instance field reference: public System.String monsterName
    [[deprecated("Use field access instead!")]] ::StringW& dyn_monsterName();
    // Get instance field reference: public System.String monsterType
    [[deprecated("Use field access instead!")]] ::StringW& dyn_monsterType();
    // Get instance field reference: private System.Boolean <NENDEFCJJIG>k__BackingField
    [[deprecated("Use field access instead!")]] bool& dyn_$NENDEFCJJIG$k__BackingField();
    // Get instance field reference: public System.Boolean isBlocking
    [[deprecated("Use field access instead!")]] bool& dyn_isBlocking();
    // private System.Void LFMOHAHLCPJ()
    // Offset: 0x13F8B08
    void LFMOHAHLCPJ();
    // private System.Void KFAPGAPKFHH()
    // Offset: 0x13F8DDC
    void KFAPGAPKFHH();
    // private System.Void JCJCMKPOAKK()
    // Offset: 0x13F8F10
    void JCJCMKPOAKK();
    // private System.Void ENKEGDPKKBJ()
    // Offset: 0x13F961C
    void ENKEGDPKKBJ();
    // private System.Void Start()
    // Offset: 0x13F974C
    void Start();
    // private System.Void OnDestroy()
    // Offset: 0x13FA390
    void OnDestroy();
    // private System.Void FGIFGGNGKPK()
    // Offset: 0x13FA4B0
    void FGIFGGNGKPK();
    // public System.Void orbusNetInit(MagicalActual.NetEntity CMLIHJCOINC)
    // Offset: 0x13FA5B0
    void orbusNetInit(::MagicalActual::NetEntity* CMLIHJCOINC);
    // private System.Void BMJGIIEBJCJ(System.Boolean MMMEIONJJFJ)
    // Offset: 0x13FB334
    void BMJGIIEBJCJ(bool MMMEIONJJFJ);
    // public System.String myLogName()
    // Offset: 0x13FB340
    ::StringW myLogName();
    // private System.Void OnDisable()
    // Offset: 0x13FB5A8
    void OnDisable();
    // private System.Void JEBHPFOHJAL(UnityEngine.AudioSource MMMEIONJJFJ)
    // Offset: 0x13FB660
    void JEBHPFOHJAL(::UnityEngine::AudioSource* MMMEIONJJFJ);
    // public System.Void showSphereTelegraph(UnityEngine.Vector3 INGBFFBEGJC, System.Single GEBMCFKLLOB, System.Single COFEDKKLNEI)
    // Offset: 0x13FB668
    void showSphereTelegraph(::UnityEngine::Vector3 INGBFFBEGJC, float GEBMCFKLLOB, float COFEDKKLNEI);
    // private System.Void FixedUpdate()
    // Offset: 0x13FB814
    void FixedUpdate();
    // public System.Void IDCIAHKKCDP()
    // Offset: 0x13FBC94
    void IDCIAHKKCDP();
    // public System.Void PoolingReset()
    // Offset: 0x13FBCE8
    void PoolingReset();
    // public System.Void Fmod(System.String HACLJDHIHML)
    // Offset: 0x13FBD3C
    void Fmod(::StringW HACLJDHIHML);
    // private System.Void PGJCBHOHBCJ()
    // Offset: 0x13FBE80
    void PGJCBHOHBCJ();
    // public System.Void NKBLCFKFDIC(System.String CHMNHKGOBGC)
    // Offset: 0x13FBEFC
    void NKBLCFKFDIC(::StringW CHMNHKGOBGC);
    // public MagicalActual.ObjectHighlighter get_myObjectHighlighter()
    // Offset: 0x13FC290
    ::MagicalActual::ObjectHighlighter* get_myObjectHighlighter();
    // private System.Void DHKPPAENLLA(MagicalActual.NetEntity MMMEIONJJFJ)
    // Offset: 0x13FB32C
    void DHKPPAENLLA(::MagicalActual::NetEntity* MMMEIONJJFJ);
    // private System.Void UpdateHealthBar()
    // Offset: 0x13F984C
    void UpdateHealthBar();
    // public System.Void JPJDEFOBPPC()
    // Offset: 0x13FC38C
    void JPJDEFOBPPC();
    // public System.Void ABHMDIAJHDA(System.String CHMNHKGOBGC)
    // Offset: 0x13FC390
    void ABHMDIAJHDA(::StringW CHMNHKGOBGC);
    // private System.Void EOFAEIHPEAD(System.Boolean MMMEIONJJFJ)
    // Offset: 0x13FC550
    void EOFAEIHPEAD(bool MMMEIONJJFJ);
    // public System.Void FootR()
    // Offset: 0x13FC55C
    void FootR();
    // private System.Void JNELNIGPBIM()
    // Offset: 0x13FC560
    void JNELNIGPBIM();
    // public System.Void ClearWarriorCollider()
    // Offset: 0x13FCC84
    void ClearWarriorCollider();
    // public System.Boolean get_phasedOut()
    // Offset: 0x13FCC8C
    bool get_phasedOut();
    // private System.Void IONHMCJFOOD(MagicalActual.NetEntity MMMEIONJJFJ)
    // Offset: 0x13FCC94
    void IONHMCJFOOD(::MagicalActual::NetEntity* MMMEIONJJFJ);
    // private System.Void OnEnable()
    // Offset: 0x13FCC9C
    void OnEnable();
    // public System.Void SetWarriorCollider(MagicalActual.WarriorCollisionBox ODKIHKAJMJO)
    // Offset: 0x13FCD54
    void SetWarriorCollider(::MagicalActual::WarriorCollisionBox* ODKIHKAJMJO);
    // private System.Void WillDespawn()
    // Offset: 0x13FCD5C
    void WillDespawn();
    // public UnityEngine.AudioSource get_myAudioSource()
    // Offset: 0x13FC0BC
    ::UnityEngine::AudioSource* get_myAudioSource();
    // private System.Void MKLLMCLIAID()
    // Offset: 0x13FCE80
    void MKLLMCLIAID();
    // public System.Void JDCPGOPJFHO(MagicalActual.WarriorCollisionBox ODKIHKAJMJO)
    // Offset: 0x13FCEFC
    void JDCPGOPJFHO(::MagicalActual::WarriorCollisionBox* ODKIHKAJMJO);
    // private System.Void PBPDIHLIFOH(MagicalActual.ObjectHighlighter MMMEIONJJFJ)
    // Offset: 0x13FCF04
    void PBPDIHLIFOH(::MagicalActual::ObjectHighlighter* MMMEIONJJFJ);
    // private System.Void KDGAIHNIJCM()
    // Offset: 0x13FCF0C
    void KDGAIHNIJCM();
    // private System.Void GLNKEKIACOD()
    // Offset: 0x13FD130
    void GLNKEKIACOD();
    // private System.Void EMLMJJCNBKE(MagicalActual.ObjectHighlighter MMMEIONJJFJ)
    // Offset: 0x13FD1AC
    void EMLMJJCNBKE(::MagicalActual::ObjectHighlighter* MMMEIONJJFJ);
    // public System.Void FootL()
    // Offset: 0x13FD1B4
    void FootL();
    // private System.Void ForceOrbusBarUpdate()
    // Offset: 0x13FD1B8
    void ForceOrbusBarUpdate();
    // public System.Void Hit()
    // Offset: 0x13FD254
    void Hit();
    // private System.Void HEGCCGLPILO(System.Boolean MMMEIONJJFJ)
    // Offset: 0x13F9610
    void HEGCCGLPILO(bool MMMEIONJJFJ);
    // public System.Boolean HasWarriorCollider()
    // Offset: 0x13FD258
    bool HasWarriorCollider();
    // public System.Void triggerSfxNamed(System.String CHMNHKGOBGC)
    // Offset: 0x13F8C20
    void triggerSfxNamed(::StringW CHMNHKGOBGC);
    // private System.Collections.IEnumerator NFJODPDCIFD()
    // Offset: 0x13FD2C8
    ::System::Collections::IEnumerator* NFJODPDCIFD();
    // private System.Void LCAAOEGGADP(System.Single PMEEKODINMK, System.Int32 GJKBIJIGJPC, System.Single DKBDCMNLIOM, System.Single DBPEBMAJAEF)
    // Offset: 0x13FD33C
    void LCAAOEGGADP(float PMEEKODINMK, int GJKBIJIGJPC, float DKBDCMNLIOM, float DBPEBMAJAEF);
    // private System.Void AAPOOHKKLCE(System.Single PMEEKODINMK, System.Int32 GJKBIJIGJPC, System.Single DKBDCMNLIOM, System.Single DBPEBMAJAEF)
    // Offset: 0x13FD5B0
    void AAPOOHKKLCE(float PMEEKODINMK, int GJKBIJIGJPC, float DKBDCMNLIOM, float DBPEBMAJAEF);
    // private System.Void MDAIGLLBOHA()
    // Offset: 0x13FD830
    void MDAIGLLBOHA();
    // public System.Boolean HasStatusEffect(System.Int32 GJKBIJIGJPC)
    // Offset: 0x13FD8E8
    bool HasStatusEffect(int GJKBIJIGJPC);
    // private System.Void AMGJNJLJIFO()
    // Offset: 0x13FDA58
    void AMGJNJLJIFO();
    // private System.Void GHCIHJEFEJB(UnityEngine.AudioSource MMMEIONJJFJ)
    // Offset: 0x13FDEDC
    void GHCIHJEFEJB(::UnityEngine::AudioSource* MMMEIONJJFJ);
    // public System.Void showTelegraph(UnityEngine.Vector3 INGBFFBEGJC, UnityEngine.Vector3 HIJNLFBCAOK, System.Single COFEDKKLNEI, UnityEngine.Quaternion PALGPCJAMIL)
    // Offset: 0x13FDEE4
    void showTelegraph(::UnityEngine::Vector3 INGBFFBEGJC, ::UnityEngine::Vector3 HIJNLFBCAOK, float COFEDKKLNEI, ::UnityEngine::Quaternion PALGPCJAMIL);
    // private System.Void Awake()
    // Offset: 0x13FE034
    void Awake();
    // private System.Void PBDAIPCLFHB()
    // Offset: 0x13F9968
    void PBDAIPCLFHB();
    // private System.Void OCBIBLOCDGA()
    // Offset: 0x13FE7A4
    void OCBIBLOCDGA();
    // public MagicalActual.NetEntity get_myEntity()
    // Offset: 0x13FB5A0
    ::MagicalActual::NetEntity* get_myEntity();
    // private System.Void KMOACCGFKBM()
    // Offset: 0x13FE8D8
    void KMOACCGFKBM();
    // public System.Void .ctor()
    // Offset: 0x13FE954
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static Monster* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::MagicalActual::Monster::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<Monster*, creationType>()));
    }
  }; // MagicalActual.Monster
  #pragma pack(pop)
  static check_size<sizeof(Monster), 321 + sizeof(bool)> __MagicalActual_MonsterSizeCheck;
  static_assert(sizeof(Monster) == 0x142);
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: MagicalActual::Monster::LFMOHAHLCPJ
// Il2CppName: LFMOHAHLCPJ
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)()>(&MagicalActual::Monster::LFMOHAHLCPJ)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "LFMOHAHLCPJ", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::KFAPGAPKFHH
// Il2CppName: KFAPGAPKFHH
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)()>(&MagicalActual::Monster::KFAPGAPKFHH)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "KFAPGAPKFHH", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::JCJCMKPOAKK
// Il2CppName: JCJCMKPOAKK
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)()>(&MagicalActual::Monster::JCJCMKPOAKK)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "JCJCMKPOAKK", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::ENKEGDPKKBJ
// Il2CppName: ENKEGDPKKBJ
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)()>(&MagicalActual::Monster::ENKEGDPKKBJ)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "ENKEGDPKKBJ", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::Start
// Il2CppName: Start
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)()>(&MagicalActual::Monster::Start)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "Start", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::OnDestroy
// Il2CppName: OnDestroy
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)()>(&MagicalActual::Monster::OnDestroy)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "OnDestroy", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::FGIFGGNGKPK
// Il2CppName: FGIFGGNGKPK
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)()>(&MagicalActual::Monster::FGIFGGNGKPK)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "FGIFGGNGKPK", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::orbusNetInit
// Il2CppName: orbusNetInit
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)(::MagicalActual::NetEntity*)>(&MagicalActual::Monster::orbusNetInit)> {
  static const MethodInfo* get() {
    static auto* CMLIHJCOINC = &::il2cpp_utils::GetClassFromName("MagicalActual", "NetEntity")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "orbusNetInit", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{CMLIHJCOINC});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::BMJGIIEBJCJ
// Il2CppName: BMJGIIEBJCJ
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)(bool)>(&MagicalActual::Monster::BMJGIIEBJCJ)> {
  static const MethodInfo* get() {
    static auto* MMMEIONJJFJ = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "BMJGIIEBJCJ", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{MMMEIONJJFJ});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::myLogName
// Il2CppName: myLogName
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::StringW (MagicalActual::Monster::*)()>(&MagicalActual::Monster::myLogName)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "myLogName", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::OnDisable
// Il2CppName: OnDisable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)()>(&MagicalActual::Monster::OnDisable)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "OnDisable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::JEBHPFOHJAL
// Il2CppName: JEBHPFOHJAL
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)(::UnityEngine::AudioSource*)>(&MagicalActual::Monster::JEBHPFOHJAL)> {
  static const MethodInfo* get() {
    static auto* MMMEIONJJFJ = &::il2cpp_utils::GetClassFromName("UnityEngine", "AudioSource")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "JEBHPFOHJAL", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{MMMEIONJJFJ});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::showSphereTelegraph
// Il2CppName: showSphereTelegraph
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)(::UnityEngine::Vector3, float, float)>(&MagicalActual::Monster::showSphereTelegraph)> {
  static const MethodInfo* get() {
    static auto* INGBFFBEGJC = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* GEBMCFKLLOB = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* COFEDKKLNEI = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "showSphereTelegraph", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{INGBFFBEGJC, GEBMCFKLLOB, COFEDKKLNEI});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::FixedUpdate
// Il2CppName: FixedUpdate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)()>(&MagicalActual::Monster::FixedUpdate)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "FixedUpdate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::IDCIAHKKCDP
// Il2CppName: IDCIAHKKCDP
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)()>(&MagicalActual::Monster::IDCIAHKKCDP)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "IDCIAHKKCDP", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::PoolingReset
// Il2CppName: PoolingReset
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)()>(&MagicalActual::Monster::PoolingReset)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "PoolingReset", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::Fmod
// Il2CppName: Fmod
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)(::StringW)>(&MagicalActual::Monster::Fmod)> {
  static const MethodInfo* get() {
    static auto* HACLJDHIHML = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "Fmod", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{HACLJDHIHML});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::PGJCBHOHBCJ
// Il2CppName: PGJCBHOHBCJ
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)()>(&MagicalActual::Monster::PGJCBHOHBCJ)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "PGJCBHOHBCJ", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::NKBLCFKFDIC
// Il2CppName: NKBLCFKFDIC
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)(::StringW)>(&MagicalActual::Monster::NKBLCFKFDIC)> {
  static const MethodInfo* get() {
    static auto* CHMNHKGOBGC = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "NKBLCFKFDIC", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{CHMNHKGOBGC});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::get_myObjectHighlighter
// Il2CppName: get_myObjectHighlighter
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::MagicalActual::ObjectHighlighter* (MagicalActual::Monster::*)()>(&MagicalActual::Monster::get_myObjectHighlighter)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "get_myObjectHighlighter", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::DHKPPAENLLA
// Il2CppName: DHKPPAENLLA
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)(::MagicalActual::NetEntity*)>(&MagicalActual::Monster::DHKPPAENLLA)> {
  static const MethodInfo* get() {
    static auto* MMMEIONJJFJ = &::il2cpp_utils::GetClassFromName("MagicalActual", "NetEntity")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "DHKPPAENLLA", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{MMMEIONJJFJ});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::UpdateHealthBar
// Il2CppName: UpdateHealthBar
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)()>(&MagicalActual::Monster::UpdateHealthBar)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "UpdateHealthBar", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::JPJDEFOBPPC
// Il2CppName: JPJDEFOBPPC
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)()>(&MagicalActual::Monster::JPJDEFOBPPC)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "JPJDEFOBPPC", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::ABHMDIAJHDA
// Il2CppName: ABHMDIAJHDA
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)(::StringW)>(&MagicalActual::Monster::ABHMDIAJHDA)> {
  static const MethodInfo* get() {
    static auto* CHMNHKGOBGC = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "ABHMDIAJHDA", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{CHMNHKGOBGC});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::EOFAEIHPEAD
// Il2CppName: EOFAEIHPEAD
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)(bool)>(&MagicalActual::Monster::EOFAEIHPEAD)> {
  static const MethodInfo* get() {
    static auto* MMMEIONJJFJ = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "EOFAEIHPEAD", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{MMMEIONJJFJ});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::FootR
// Il2CppName: FootR
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)()>(&MagicalActual::Monster::FootR)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "FootR", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::JNELNIGPBIM
// Il2CppName: JNELNIGPBIM
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)()>(&MagicalActual::Monster::JNELNIGPBIM)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "JNELNIGPBIM", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::ClearWarriorCollider
// Il2CppName: ClearWarriorCollider
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)()>(&MagicalActual::Monster::ClearWarriorCollider)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "ClearWarriorCollider", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::get_phasedOut
// Il2CppName: get_phasedOut
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (MagicalActual::Monster::*)()>(&MagicalActual::Monster::get_phasedOut)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "get_phasedOut", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::IONHMCJFOOD
// Il2CppName: IONHMCJFOOD
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)(::MagicalActual::NetEntity*)>(&MagicalActual::Monster::IONHMCJFOOD)> {
  static const MethodInfo* get() {
    static auto* MMMEIONJJFJ = &::il2cpp_utils::GetClassFromName("MagicalActual", "NetEntity")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "IONHMCJFOOD", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{MMMEIONJJFJ});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::OnEnable
// Il2CppName: OnEnable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)()>(&MagicalActual::Monster::OnEnable)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "OnEnable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::SetWarriorCollider
// Il2CppName: SetWarriorCollider
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)(::MagicalActual::WarriorCollisionBox*)>(&MagicalActual::Monster::SetWarriorCollider)> {
  static const MethodInfo* get() {
    static auto* ODKIHKAJMJO = &::il2cpp_utils::GetClassFromName("MagicalActual", "WarriorCollisionBox")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "SetWarriorCollider", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{ODKIHKAJMJO});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::WillDespawn
// Il2CppName: WillDespawn
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)()>(&MagicalActual::Monster::WillDespawn)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "WillDespawn", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::get_myAudioSource
// Il2CppName: get_myAudioSource
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::AudioSource* (MagicalActual::Monster::*)()>(&MagicalActual::Monster::get_myAudioSource)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "get_myAudioSource", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::MKLLMCLIAID
// Il2CppName: MKLLMCLIAID
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)()>(&MagicalActual::Monster::MKLLMCLIAID)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "MKLLMCLIAID", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::JDCPGOPJFHO
// Il2CppName: JDCPGOPJFHO
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)(::MagicalActual::WarriorCollisionBox*)>(&MagicalActual::Monster::JDCPGOPJFHO)> {
  static const MethodInfo* get() {
    static auto* ODKIHKAJMJO = &::il2cpp_utils::GetClassFromName("MagicalActual", "WarriorCollisionBox")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "JDCPGOPJFHO", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{ODKIHKAJMJO});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::PBPDIHLIFOH
// Il2CppName: PBPDIHLIFOH
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)(::MagicalActual::ObjectHighlighter*)>(&MagicalActual::Monster::PBPDIHLIFOH)> {
  static const MethodInfo* get() {
    static auto* MMMEIONJJFJ = &::il2cpp_utils::GetClassFromName("MagicalActual", "ObjectHighlighter")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "PBPDIHLIFOH", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{MMMEIONJJFJ});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::KDGAIHNIJCM
// Il2CppName: KDGAIHNIJCM
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)()>(&MagicalActual::Monster::KDGAIHNIJCM)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "KDGAIHNIJCM", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::GLNKEKIACOD
// Il2CppName: GLNKEKIACOD
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)()>(&MagicalActual::Monster::GLNKEKIACOD)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "GLNKEKIACOD", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::EMLMJJCNBKE
// Il2CppName: EMLMJJCNBKE
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)(::MagicalActual::ObjectHighlighter*)>(&MagicalActual::Monster::EMLMJJCNBKE)> {
  static const MethodInfo* get() {
    static auto* MMMEIONJJFJ = &::il2cpp_utils::GetClassFromName("MagicalActual", "ObjectHighlighter")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "EMLMJJCNBKE", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{MMMEIONJJFJ});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::FootL
// Il2CppName: FootL
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)()>(&MagicalActual::Monster::FootL)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "FootL", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::ForceOrbusBarUpdate
// Il2CppName: ForceOrbusBarUpdate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)()>(&MagicalActual::Monster::ForceOrbusBarUpdate)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "ForceOrbusBarUpdate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::Hit
// Il2CppName: Hit
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)()>(&MagicalActual::Monster::Hit)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "Hit", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::HEGCCGLPILO
// Il2CppName: HEGCCGLPILO
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)(bool)>(&MagicalActual::Monster::HEGCCGLPILO)> {
  static const MethodInfo* get() {
    static auto* MMMEIONJJFJ = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "HEGCCGLPILO", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{MMMEIONJJFJ});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::HasWarriorCollider
// Il2CppName: HasWarriorCollider
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (MagicalActual::Monster::*)()>(&MagicalActual::Monster::HasWarriorCollider)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "HasWarriorCollider", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::triggerSfxNamed
// Il2CppName: triggerSfxNamed
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)(::StringW)>(&MagicalActual::Monster::triggerSfxNamed)> {
  static const MethodInfo* get() {
    static auto* CHMNHKGOBGC = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "triggerSfxNamed", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{CHMNHKGOBGC});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::NFJODPDCIFD
// Il2CppName: NFJODPDCIFD
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Collections::IEnumerator* (MagicalActual::Monster::*)()>(&MagicalActual::Monster::NFJODPDCIFD)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "NFJODPDCIFD", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::LCAAOEGGADP
// Il2CppName: LCAAOEGGADP
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)(float, int, float, float)>(&MagicalActual::Monster::LCAAOEGGADP)> {
  static const MethodInfo* get() {
    static auto* PMEEKODINMK = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* GJKBIJIGJPC = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* DKBDCMNLIOM = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* DBPEBMAJAEF = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "LCAAOEGGADP", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{PMEEKODINMK, GJKBIJIGJPC, DKBDCMNLIOM, DBPEBMAJAEF});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::AAPOOHKKLCE
// Il2CppName: AAPOOHKKLCE
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)(float, int, float, float)>(&MagicalActual::Monster::AAPOOHKKLCE)> {
  static const MethodInfo* get() {
    static auto* PMEEKODINMK = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* GJKBIJIGJPC = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* DKBDCMNLIOM = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* DBPEBMAJAEF = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "AAPOOHKKLCE", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{PMEEKODINMK, GJKBIJIGJPC, DKBDCMNLIOM, DBPEBMAJAEF});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::MDAIGLLBOHA
// Il2CppName: MDAIGLLBOHA
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)()>(&MagicalActual::Monster::MDAIGLLBOHA)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "MDAIGLLBOHA", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::HasStatusEffect
// Il2CppName: HasStatusEffect
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (MagicalActual::Monster::*)(int)>(&MagicalActual::Monster::HasStatusEffect)> {
  static const MethodInfo* get() {
    static auto* GJKBIJIGJPC = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "HasStatusEffect", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{GJKBIJIGJPC});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::AMGJNJLJIFO
// Il2CppName: AMGJNJLJIFO
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)()>(&MagicalActual::Monster::AMGJNJLJIFO)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "AMGJNJLJIFO", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::GHCIHJEFEJB
// Il2CppName: GHCIHJEFEJB
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)(::UnityEngine::AudioSource*)>(&MagicalActual::Monster::GHCIHJEFEJB)> {
  static const MethodInfo* get() {
    static auto* MMMEIONJJFJ = &::il2cpp_utils::GetClassFromName("UnityEngine", "AudioSource")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "GHCIHJEFEJB", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{MMMEIONJJFJ});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::showTelegraph
// Il2CppName: showTelegraph
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)(::UnityEngine::Vector3, ::UnityEngine::Vector3, float, ::UnityEngine::Quaternion)>(&MagicalActual::Monster::showTelegraph)> {
  static const MethodInfo* get() {
    static auto* INGBFFBEGJC = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* HIJNLFBCAOK = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* COFEDKKLNEI = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* PALGPCJAMIL = &::il2cpp_utils::GetClassFromName("UnityEngine", "Quaternion")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "showTelegraph", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{INGBFFBEGJC, HIJNLFBCAOK, COFEDKKLNEI, PALGPCJAMIL});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::Awake
// Il2CppName: Awake
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)()>(&MagicalActual::Monster::Awake)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "Awake", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::PBDAIPCLFHB
// Il2CppName: PBDAIPCLFHB
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)()>(&MagicalActual::Monster::PBDAIPCLFHB)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "PBDAIPCLFHB", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::OCBIBLOCDGA
// Il2CppName: OCBIBLOCDGA
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)()>(&MagicalActual::Monster::OCBIBLOCDGA)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "OCBIBLOCDGA", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::get_myEntity
// Il2CppName: get_myEntity
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::MagicalActual::NetEntity* (MagicalActual::Monster::*)()>(&MagicalActual::Monster::get_myEntity)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "get_myEntity", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::KMOACCGFKBM
// Il2CppName: KMOACCGFKBM
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (MagicalActual::Monster::*)()>(&MagicalActual::Monster::KMOACCGFKBM)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(MagicalActual::Monster*), "KMOACCGFKBM", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: MagicalActual::Monster::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
