// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: UnityEngine.MonoBehaviour
#include "UnityEngine/MonoBehaviour.hpp"
// Including type: UnityEngine.LayerMask
#include "UnityEngine/LayerMask.hpp"
// Including type: UnityEngine.RaycastHit
#include "UnityEngine/RaycastHit.hpp"
// Including type: Pegasus.TreeManager/TreeStruct
#include "Pegasus/TreeManager.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: Transform
  class Transform;
  // Forward declaring type: Collider
  class Collider;
  // Forward declaring type: Terrain
  class Terrain;
}
// Forward declaring namespace: System::Collections::Generic
namespace System::Collections::Generic {
  // Forward declaring type: List`1<T>
  template<typename T>
  class List_1;
  // Forward declaring type: Dictionary`2<TKey, TValue>
  template<typename TKey, typename TValue>
  class Dictionary_2;
}
// Forward declaring namespace: Pegasus
namespace Pegasus {
  // Skipping declaration: TreeManager because it is already included!
}
// Completed forward declares
// Type namespace: Pegasus
namespace Pegasus {
  // Forward declaring type: PegasusFollow
  class PegasusFollow;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::Pegasus::PegasusFollow);
DEFINE_IL2CPP_ARG_TYPE(::Pegasus::PegasusFollow*, "Pegasus", "PegasusFollow");
// Type namespace: Pegasus
namespace Pegasus {
  // Size: 0xB4
  #pragma pack(push, 1)
  // Autogenerated type: Pegasus.PegasusFollow
  // [TokenAttribute] Offset: FFFFFFFF
  class PegasusFollow : public ::UnityEngine::MonoBehaviour {
    public:
    public:
    // public UnityEngine.Transform m_target
    // Size: 0x8
    // Offset: 0x18
    ::UnityEngine::Transform* m_target;
    // Field size check
    static_assert(sizeof(::UnityEngine::Transform*) == 0x8);
    // [HeaderAttribute] Offset: 0xADF2E0
    // [TooltipAttribute] Offset: 0xADF2E0
    // public System.Boolean m_alwaysShowGizmos
    // Size: 0x1
    // Offset: 0x20
    bool m_alwaysShowGizmos;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // [TooltipAttribute] Offset: 0xADF340
    // public System.Boolean m_groundToTerrain
    // Size: 0x1
    // Offset: 0x21
    bool m_groundToTerrain;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // [TooltipAttribute] Offset: 0xADF378
    // public System.Boolean m_rotateToTerrain
    // Size: 0x1
    // Offset: 0x22
    bool m_rotateToTerrain;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // [TooltipAttribute] Offset: 0xADF3B0
    // public System.Boolean m_avoidTreeCollisions
    // Size: 0x1
    // Offset: 0x23
    bool m_avoidTreeCollisions;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // [TooltipAttribute] Offset: 0xADF3E8
    // public System.Boolean m_avoidObjectCollisions
    // Size: 0x1
    // Offset: 0x24
    bool m_avoidObjectCollisions;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: m_avoidObjectCollisions and: m_collisionRange
    char __padding5[0x3] = {};
    // [TooltipAttribute] Offset: 0xADF420
    // [RangeAttribute] Offset: 0xADF420
    // public System.Single m_collisionRange
    // Size: 0x4
    // Offset: 0x28
    float m_collisionRange;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // [TooltipAttribute] Offset: 0xADF474
    // public UnityEngine.LayerMask m_objectCollisionLayer
    // Size: 0x4
    // Offset: 0x2C
    ::UnityEngine::LayerMask m_objectCollisionLayer;
    // Field size check
    static_assert(sizeof(::UnityEngine::LayerMask) == 0x4);
    // private System.Int32 m_currentCollisionCount
    // Size: 0x4
    // Offset: 0x30
    int m_currentCollisionCount;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // Padding between fields: m_currentCollisionCount and: m_currentCollisionHitArray
    char __padding8[0x4] = {};
    // private UnityEngine.RaycastHit[] m_currentCollisionHitArray
    // Size: 0x8
    // Offset: 0x38
    ::ArrayW<::UnityEngine::RaycastHit> m_currentCollisionHitArray;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::RaycastHit>) == 0x8);
    // private System.Int32 m_currentTreeCollisionCount
    // Size: 0x4
    // Offset: 0x40
    int m_currentTreeCollisionCount;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // Padding between fields: m_currentTreeCollisionCount and: m_currentTreeCollisionHitArray
    char __padding10[0x4] = {};
    // private System.Collections.Generic.List`1<Pegasus.TreeManager/TreeStruct> m_currentTreeCollisionHitArray
    // Size: 0x8
    // Offset: 0x48
    ::System::Collections::Generic::List_1<::Pegasus::TreeManager::TreeStruct>* m_currentTreeCollisionHitArray;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::List_1<::Pegasus::TreeManager::TreeStruct>*) == 0x8);
    // private Pegasus.TreeManager m_terrainTreeManager
    // Size: 0x8
    // Offset: 0x50
    ::Pegasus::TreeManager* m_terrainTreeManager;
    // Field size check
    static_assert(sizeof(::Pegasus::TreeManager*) == 0x8);
    // private System.Collections.Generic.Dictionary`2<System.Int32,UnityEngine.Collider> m_myColliders
    // Size: 0x8
    // Offset: 0x58
    ::System::Collections::Generic::Dictionary_2<int, ::UnityEngine::Collider*>* m_myColliders;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::Dictionary_2<int, ::UnityEngine::Collider*>*) == 0x8);
    // [HeaderAttribute] Offset: 0xADF4AC
    // [TooltipAttribute] Offset: 0xADF4AC
    // public System.Single m_walkSpeed
    // Size: 0x4
    // Offset: 0x60
    float m_walkSpeed;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // [TooltipAttribute] Offset: 0xADF50C
    // public System.Single m_runSpeed
    // Size: 0x4
    // Offset: 0x64
    float m_runSpeed;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // [TooltipAttribute] Offset: 0xADF544
    // [HeaderAttribute] Offset: 0xADF544
    // public System.Single m_stopDistanceMin
    // Size: 0x4
    // Offset: 0x68
    float m_stopDistanceMin;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // [TooltipAttribute] Offset: 0xADF5A4
    // public System.Single m_stopDistanceMax
    // Size: 0x4
    // Offset: 0x6C
    float m_stopDistanceMax;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single m_currentStopDistance
    // Size: 0x4
    // Offset: 0x70
    float m_currentStopDistance;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Boolean m_updateStopDistance
    // Size: 0x1
    // Offset: 0x74
    bool m_updateStopDistance;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: m_updateStopDistance and: m_runIfFurtherThan
    char __padding19[0x3] = {};
    // [TooltipAttribute] Offset: 0xADF5DC
    // public System.Single m_runIfFurtherThan
    // Size: 0x4
    // Offset: 0x78
    float m_runIfFurtherThan;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // [HeaderAttribute] Offset: 0xADF614
    // [RangeAttribute] Offset: 0xADF614
    // [TooltipAttribute] Offset: 0xADF614
    // public System.Single m_turnChange
    // Size: 0x4
    // Offset: 0x7C
    float m_turnChange;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // [TooltipAttribute] Offset: 0xADF690
    // [RangeAttribute] Offset: 0xADF690
    // public System.Single m_movementChange
    // Size: 0x4
    // Offset: 0x80
    float m_movementChange;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // [HeaderAttribute] Offset: 0xADF6E8
    // [RangeAttribute] Offset: 0xADF6E8
    // [TooltipAttribute] Offset: 0xADF6E8
    // public System.Single m_deviationRate
    // Size: 0x4
    // Offset: 0x84
    float m_deviationRate;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // [TooltipAttribute] Offset: 0xADF760
    // public System.Single m_maxDeviationX
    // Size: 0x4
    // Offset: 0x88
    float m_maxDeviationX;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // [TooltipAttribute] Offset: 0xADF798
    // public System.Single m_maxDeviationY
    // Size: 0x4
    // Offset: 0x8C
    float m_maxDeviationY;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // [TooltipAttribute] Offset: 0xADF7D0
    // public System.Single m_maxDeviationZ
    // Size: 0x4
    // Offset: 0x90
    float m_maxDeviationZ;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private UnityEngine.Vector3 m_targetPosition
    // Size: 0xC
    // Offset: 0x94
    ::UnityEngine::Vector3 m_targetPosition;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private System.Single m_distanceToTarget
    // Size: 0x4
    // Offset: 0xA0
    float m_distanceToTarget;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single m_currentMovementDistance
    // Size: 0x4
    // Offset: 0xA4
    float m_currentMovementDistance;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private UnityEngine.Vector3 m_currentVelocity
    // Size: 0xC
    // Offset: 0xA8
    ::UnityEngine::Vector3 m_currentVelocity;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    public:
    // Deleting conversion operator: operator ::System::IntPtr
    constexpr operator ::System::IntPtr() const noexcept = delete;
    // Get instance field reference: public UnityEngine.Transform m_target
    [[deprecated("Use field access instead!")]] ::UnityEngine::Transform*& dyn_m_target();
    // Get instance field reference: public System.Boolean m_alwaysShowGizmos
    [[deprecated("Use field access instead!")]] bool& dyn_m_alwaysShowGizmos();
    // Get instance field reference: public System.Boolean m_groundToTerrain
    [[deprecated("Use field access instead!")]] bool& dyn_m_groundToTerrain();
    // Get instance field reference: public System.Boolean m_rotateToTerrain
    [[deprecated("Use field access instead!")]] bool& dyn_m_rotateToTerrain();
    // Get instance field reference: public System.Boolean m_avoidTreeCollisions
    [[deprecated("Use field access instead!")]] bool& dyn_m_avoidTreeCollisions();
    // Get instance field reference: public System.Boolean m_avoidObjectCollisions
    [[deprecated("Use field access instead!")]] bool& dyn_m_avoidObjectCollisions();
    // Get instance field reference: public System.Single m_collisionRange
    [[deprecated("Use field access instead!")]] float& dyn_m_collisionRange();
    // Get instance field reference: public UnityEngine.LayerMask m_objectCollisionLayer
    [[deprecated("Use field access instead!")]] ::UnityEngine::LayerMask& dyn_m_objectCollisionLayer();
    // Get instance field reference: private System.Int32 m_currentCollisionCount
    [[deprecated("Use field access instead!")]] int& dyn_m_currentCollisionCount();
    // Get instance field reference: private UnityEngine.RaycastHit[] m_currentCollisionHitArray
    [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::RaycastHit>& dyn_m_currentCollisionHitArray();
    // Get instance field reference: private System.Int32 m_currentTreeCollisionCount
    [[deprecated("Use field access instead!")]] int& dyn_m_currentTreeCollisionCount();
    // Get instance field reference: private System.Collections.Generic.List`1<Pegasus.TreeManager/TreeStruct> m_currentTreeCollisionHitArray
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::List_1<::Pegasus::TreeManager::TreeStruct>*& dyn_m_currentTreeCollisionHitArray();
    // Get instance field reference: private Pegasus.TreeManager m_terrainTreeManager
    [[deprecated("Use field access instead!")]] ::Pegasus::TreeManager*& dyn_m_terrainTreeManager();
    // Get instance field reference: private System.Collections.Generic.Dictionary`2<System.Int32,UnityEngine.Collider> m_myColliders
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::Dictionary_2<int, ::UnityEngine::Collider*>*& dyn_m_myColliders();
    // Get instance field reference: public System.Single m_walkSpeed
    [[deprecated("Use field access instead!")]] float& dyn_m_walkSpeed();
    // Get instance field reference: public System.Single m_runSpeed
    [[deprecated("Use field access instead!")]] float& dyn_m_runSpeed();
    // Get instance field reference: public System.Single m_stopDistanceMin
    [[deprecated("Use field access instead!")]] float& dyn_m_stopDistanceMin();
    // Get instance field reference: public System.Single m_stopDistanceMax
    [[deprecated("Use field access instead!")]] float& dyn_m_stopDistanceMax();
    // Get instance field reference: private System.Single m_currentStopDistance
    [[deprecated("Use field access instead!")]] float& dyn_m_currentStopDistance();
    // Get instance field reference: private System.Boolean m_updateStopDistance
    [[deprecated("Use field access instead!")]] bool& dyn_m_updateStopDistance();
    // Get instance field reference: public System.Single m_runIfFurtherThan
    [[deprecated("Use field access instead!")]] float& dyn_m_runIfFurtherThan();
    // Get instance field reference: public System.Single m_turnChange
    [[deprecated("Use field access instead!")]] float& dyn_m_turnChange();
    // Get instance field reference: public System.Single m_movementChange
    [[deprecated("Use field access instead!")]] float& dyn_m_movementChange();
    // Get instance field reference: public System.Single m_deviationRate
    [[deprecated("Use field access instead!")]] float& dyn_m_deviationRate();
    // Get instance field reference: public System.Single m_maxDeviationX
    [[deprecated("Use field access instead!")]] float& dyn_m_maxDeviationX();
    // Get instance field reference: public System.Single m_maxDeviationY
    [[deprecated("Use field access instead!")]] float& dyn_m_maxDeviationY();
    // Get instance field reference: public System.Single m_maxDeviationZ
    [[deprecated("Use field access instead!")]] float& dyn_m_maxDeviationZ();
    // Get instance field reference: private UnityEngine.Vector3 m_targetPosition
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_m_targetPosition();
    // Get instance field reference: private System.Single m_distanceToTarget
    [[deprecated("Use field access instead!")]] float& dyn_m_distanceToTarget();
    // Get instance field reference: private System.Single m_currentMovementDistance
    [[deprecated("Use field access instead!")]] float& dyn_m_currentMovementDistance();
    // Get instance field reference: private UnityEngine.Vector3 m_currentVelocity
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_m_currentVelocity();
    // private System.Void Start()
    // Offset: 0xE43054
    void Start();
    // private System.Void Update()
    // Offset: 0xE43BD0
    void Update();
    // private System.Void LateUpdate()
    // Offset: 0xE44894
    void LateUpdate();
    // private UnityEngine.Vector3 GetTargetPositionWithNoise(UnityEngine.Vector3 targetPosition)
    // Offset: 0xE44178
    ::UnityEngine::Vector3 GetTargetPositionWithNoise(::UnityEngine::Vector3 targetPosition);
    // private UnityEngine.Vector3 GetTargetPositionWithCollisions(UnityEngine.Vector3 targetPosition)
    // Offset: 0xE442B4
    ::UnityEngine::Vector3 GetTargetPositionWithCollisions(::UnityEngine::Vector3 targetPosition);
    // private UnityEngine.Terrain GetTerrain(UnityEngine.Vector3 locationWU)
    // Offset: 0xE44E3C
    ::UnityEngine::Terrain* GetTerrain(::UnityEngine::Vector3 locationWU);
    // private System.Void OnDrawGizmos()
    // Offset: 0xE4522C
    void OnDrawGizmos();
    // private System.Void OnDrawGizmosSelected()
    // Offset: 0xE45518
    void OnDrawGizmosSelected();
    // private System.Void DrawGizmos(System.Boolean isSelected)
    // Offset: 0xE45234
    void DrawGizmos(bool isSelected);
    // public System.Void .ctor()
    // Offset: 0xE45520
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static PegasusFollow* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::Pegasus::PegasusFollow::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<PegasusFollow*, creationType>()));
    }
  }; // Pegasus.PegasusFollow
  #pragma pack(pop)
  static check_size<sizeof(PegasusFollow), 168 + sizeof(::UnityEngine::Vector3)> __Pegasus_PegasusFollowSizeCheck;
  static_assert(sizeof(PegasusFollow) == 0xB4);
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: Pegasus::PegasusFollow::Start
// Il2CppName: Start
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pegasus::PegasusFollow::*)()>(&Pegasus::PegasusFollow::Start)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pegasus::PegasusFollow*), "Start", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pegasus::PegasusFollow::Update
// Il2CppName: Update
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pegasus::PegasusFollow::*)()>(&Pegasus::PegasusFollow::Update)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pegasus::PegasusFollow*), "Update", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pegasus::PegasusFollow::LateUpdate
// Il2CppName: LateUpdate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pegasus::PegasusFollow::*)()>(&Pegasus::PegasusFollow::LateUpdate)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pegasus::PegasusFollow*), "LateUpdate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pegasus::PegasusFollow::GetTargetPositionWithNoise
// Il2CppName: GetTargetPositionWithNoise
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Vector3 (Pegasus::PegasusFollow::*)(::UnityEngine::Vector3)>(&Pegasus::PegasusFollow::GetTargetPositionWithNoise)> {
  static const MethodInfo* get() {
    static auto* targetPosition = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Pegasus::PegasusFollow*), "GetTargetPositionWithNoise", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{targetPosition});
  }
};
// Writing MetadataGetter for method: Pegasus::PegasusFollow::GetTargetPositionWithCollisions
// Il2CppName: GetTargetPositionWithCollisions
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Vector3 (Pegasus::PegasusFollow::*)(::UnityEngine::Vector3)>(&Pegasus::PegasusFollow::GetTargetPositionWithCollisions)> {
  static const MethodInfo* get() {
    static auto* targetPosition = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Pegasus::PegasusFollow*), "GetTargetPositionWithCollisions", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{targetPosition});
  }
};
// Writing MetadataGetter for method: Pegasus::PegasusFollow::GetTerrain
// Il2CppName: GetTerrain
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Terrain* (Pegasus::PegasusFollow::*)(::UnityEngine::Vector3)>(&Pegasus::PegasusFollow::GetTerrain)> {
  static const MethodInfo* get() {
    static auto* locationWU = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Pegasus::PegasusFollow*), "GetTerrain", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{locationWU});
  }
};
// Writing MetadataGetter for method: Pegasus::PegasusFollow::OnDrawGizmos
// Il2CppName: OnDrawGizmos
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pegasus::PegasusFollow::*)()>(&Pegasus::PegasusFollow::OnDrawGizmos)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pegasus::PegasusFollow*), "OnDrawGizmos", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pegasus::PegasusFollow::OnDrawGizmosSelected
// Il2CppName: OnDrawGizmosSelected
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pegasus::PegasusFollow::*)()>(&Pegasus::PegasusFollow::OnDrawGizmosSelected)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pegasus::PegasusFollow*), "OnDrawGizmosSelected", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pegasus::PegasusFollow::DrawGizmos
// Il2CppName: DrawGizmos
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pegasus::PegasusFollow::*)(bool)>(&Pegasus::PegasusFollow::DrawGizmos)> {
  static const MethodInfo* get() {
    static auto* isSelected = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Pegasus::PegasusFollow*), "DrawGizmos", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{isSelected});
  }
};
// Writing MetadataGetter for method: Pegasus::PegasusFollow::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
