// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: Blaze.UVBlock
#include "Blaze/UVBlock.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
// Completed includes
// Begin forward declares
// Forward declaring namespace: Blaze
namespace Blaze {
  // Forward declaring type: AtlasEntity
  class AtlasEntity;
  // Forward declaring type: TextureAtlas
  class TextureAtlas;
}
// Completed forward declares
// Type namespace: Blaze
namespace Blaze {
  // Forward declaring type: AtlasLocation
  class AtlasLocation;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::Blaze::AtlasLocation);
DEFINE_IL2CPP_ARG_TYPE(::Blaze::AtlasLocation*, "Blaze", "AtlasLocation");
// Type namespace: Blaze
namespace Blaze {
  // Size: 0x74
  #pragma pack(push, 1)
  // Autogenerated type: Blaze.AtlasLocation
  // [TokenAttribute] Offset: FFFFFFFF
  class AtlasLocation : public ::Blaze::UVBlock {
    public:
    public:
    // public System.Int32 UsageCount
    // Size: 0x4
    // Offset: 0x20
    int UsageCount;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // Padding between fields: UsageCount and: EmptyAfter
    char __padding0[0x4] = {};
    // public Blaze.AtlasLocation EmptyAfter
    // Size: 0x8
    // Offset: 0x28
    ::Blaze::AtlasLocation* EmptyAfter;
    // Field size check
    static_assert(sizeof(::Blaze::AtlasLocation*) == 0x8);
    // public Blaze.AtlasLocation EmptyBefore
    // Size: 0x8
    // Offset: 0x30
    ::Blaze::AtlasLocation* EmptyBefore;
    // Field size check
    static_assert(sizeof(::Blaze::AtlasLocation*) == 0x8);
    // public System.Int32 X
    // Size: 0x4
    // Offset: 0x38
    int X;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Int32 Y
    // Size: 0x4
    // Offset: 0x3C
    int Y;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Int32 Area
    // Size: 0x4
    // Offset: 0x40
    int Area;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Int32 Width
    // Size: 0x4
    // Offset: 0x44
    int Width;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Int32 Height
    // Size: 0x4
    // Offset: 0x48
    int Height;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Boolean Empty
    // Size: 0x1
    // Offset: 0x4C
    bool Empty;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: Empty and: Image
    char __padding8[0x3] = {};
    // public Blaze.AtlasEntity Image
    // Size: 0x8
    // Offset: 0x50
    ::Blaze::AtlasEntity* Image;
    // Field size check
    static_assert(sizeof(::Blaze::AtlasEntity*) == 0x8);
    // public System.Int32 AtlasID
    // Size: 0x4
    // Offset: 0x58
    int AtlasID;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // Padding between fields: AtlasID and: Atlas
    char __padding10[0x4] = {};
    // public Blaze.TextureAtlas Atlas
    // Size: 0x8
    // Offset: 0x60
    ::Blaze::TextureAtlas* Atlas;
    // Field size check
    static_assert(sizeof(::Blaze::TextureAtlas*) == 0x8);
    // public System.Single InvertedSizeX
    // Size: 0x4
    // Offset: 0x68
    float InvertedSizeX;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single InvertedSizeY
    // Size: 0x4
    // Offset: 0x6C
    float InvertedSizeY;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Int32 Spacing
    // Size: 0x4
    // Offset: 0x70
    int Spacing;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    public:
    // Get instance field reference: public System.Int32 UsageCount
    [[deprecated("Use field access instead!")]] int& dyn_UsageCount();
    // Get instance field reference: public Blaze.AtlasLocation EmptyAfter
    [[deprecated("Use field access instead!")]] ::Blaze::AtlasLocation*& dyn_EmptyAfter();
    // Get instance field reference: public Blaze.AtlasLocation EmptyBefore
    [[deprecated("Use field access instead!")]] ::Blaze::AtlasLocation*& dyn_EmptyBefore();
    // Get instance field reference: public System.Int32 X
    [[deprecated("Use field access instead!")]] int& dyn_X();
    // Get instance field reference: public System.Int32 Y
    [[deprecated("Use field access instead!")]] int& dyn_Y();
    // Get instance field reference: public System.Int32 Area
    [[deprecated("Use field access instead!")]] int& dyn_Area();
    // Get instance field reference: public System.Int32 Width
    [[deprecated("Use field access instead!")]] int& dyn_Width();
    // Get instance field reference: public System.Int32 Height
    [[deprecated("Use field access instead!")]] int& dyn_Height();
    // Get instance field reference: public System.Boolean Empty
    [[deprecated("Use field access instead!")]] bool& dyn_Empty();
    // Get instance field reference: public Blaze.AtlasEntity Image
    [[deprecated("Use field access instead!")]] ::Blaze::AtlasEntity*& dyn_Image();
    // Get instance field reference: public System.Int32 AtlasID
    [[deprecated("Use field access instead!")]] int& dyn_AtlasID();
    // Get instance field reference: public Blaze.TextureAtlas Atlas
    [[deprecated("Use field access instead!")]] ::Blaze::TextureAtlas*& dyn_Atlas();
    // Get instance field reference: public System.Single InvertedSizeX
    [[deprecated("Use field access instead!")]] float& dyn_InvertedSizeX();
    // Get instance field reference: public System.Single InvertedSizeY
    [[deprecated("Use field access instead!")]] float& dyn_InvertedSizeY();
    // Get instance field reference: public System.Int32 Spacing
    [[deprecated("Use field access instead!")]] int& dyn_Spacing();
    // public System.Void .ctor(Blaze.TextureAtlas atlas, System.Int32 x, System.Int32 y, System.Int32 width, System.Int32 height)
    // Offset: 0x12B49D8
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static AtlasLocation* New_ctor(::Blaze::TextureAtlas* atlas, int x, int y, int width, int height) {
      static auto ___internal__logger = ::Logger::get().WithContext("::Blaze::AtlasLocation::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<AtlasLocation*, creationType>(atlas, x, y, width, height)));
    }
    // public System.Void .ctor(System.Int32 x, System.Int32 y, System.Int32 width, System.Int32 height, System.Single imageWidth, System.Single imageHeight)
    // Offset: 0x12B4A34
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static AtlasLocation* New_ctor(int x, int y, int width, int height, float imageWidth, float imageHeight) {
      static auto ___internal__logger = ::Logger::get().WithContext("::Blaze::AtlasLocation::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<AtlasLocation*, creationType>(x, y, width, height, imageWidth, imageHeight)));
    }
    // public System.Void PreventDeallocation()
    // Offset: 0x12B4AE4
    void PreventDeallocation();
    // public System.Boolean DecreaseUsage()
    // Offset: 0x12B4AF0
    bool DecreaseUsage();
    // public System.Void Deselect()
    // Offset: 0x12B4B2C
    void Deselect();
    // public System.Void AddToEmptySet()
    // Offset: 0x12B4C38
    void AddToEmptySet();
    // public System.Int32 FitFactor(System.Int32 width, System.Int32 height, System.Int32 area)
    // Offset: 0x12B4D54
    int FitFactor(int width, int height, int area);
    // public System.Void Select(Blaze.AtlasEntity image, System.Int32 width, System.Int32 height, System.Int32 spacing)
    // Offset: 0x12B4D84
    void Select(::Blaze::AtlasEntity* image, int width, int height, int spacing);
    // public System.Void OptimiseSelect(Blaze.AtlasLocation location)
    // Offset: 0x12B51DC
    void OptimiseSelect(::Blaze::AtlasLocation* location);
    // private System.Void BakeUV()
    // Offset: 0x12B5054
    void BakeUV();
    // public System.Single GetU(System.Single atPixel)
    // Offset: 0x12B53EC
    float GetU(float atPixel);
    // public System.Single GetV(System.Single atPixel)
    // Offset: 0x12B5454
    float GetV(float atPixel);
    // public System.Int32 BottomLeftPixel()
    // Offset: 0x12B54BC
    int BottomLeftPixel();
    // public System.Int32 RowPixelDelta()
    // Offset: 0x12B54F4
    int RowPixelDelta();
    // public System.Int32 AtlasIndex(System.Int32 x, System.Int32 y)
    // Offset: 0x12B552C
    int AtlasIndex(int x, int y);
    // public System.Void Flush()
    // Offset: 0x12B50C0
    void Flush();
    // public System.Void AtlasChanged()
    // Offset: 0x12B55A4
    void AtlasChanged();
    // public override System.Boolean get_Shared()
    // Offset: 0x12B4ADC
    // Implemented from: Blaze.UVBlock
    // Base method: System.Boolean UVBlock::get_Shared()
    bool get_Shared();
  }; // Blaze.AtlasLocation
  #pragma pack(pop)
  static check_size<sizeof(AtlasLocation), 112 + sizeof(int)> __Blaze_AtlasLocationSizeCheck;
  static_assert(sizeof(AtlasLocation) == 0x74);
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: Blaze::AtlasLocation::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: Blaze::AtlasLocation::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: Blaze::AtlasLocation::PreventDeallocation
// Il2CppName: PreventDeallocation
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Blaze::AtlasLocation::*)()>(&Blaze::AtlasLocation::PreventDeallocation)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Blaze::AtlasLocation*), "PreventDeallocation", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Blaze::AtlasLocation::DecreaseUsage
// Il2CppName: DecreaseUsage
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Blaze::AtlasLocation::*)()>(&Blaze::AtlasLocation::DecreaseUsage)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Blaze::AtlasLocation*), "DecreaseUsage", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Blaze::AtlasLocation::Deselect
// Il2CppName: Deselect
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Blaze::AtlasLocation::*)()>(&Blaze::AtlasLocation::Deselect)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Blaze::AtlasLocation*), "Deselect", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Blaze::AtlasLocation::AddToEmptySet
// Il2CppName: AddToEmptySet
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Blaze::AtlasLocation::*)()>(&Blaze::AtlasLocation::AddToEmptySet)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Blaze::AtlasLocation*), "AddToEmptySet", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Blaze::AtlasLocation::FitFactor
// Il2CppName: FitFactor
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (Blaze::AtlasLocation::*)(int, int, int)>(&Blaze::AtlasLocation::FitFactor)> {
  static const MethodInfo* get() {
    static auto* width = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* height = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* area = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Blaze::AtlasLocation*), "FitFactor", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{width, height, area});
  }
};
// Writing MetadataGetter for method: Blaze::AtlasLocation::Select
// Il2CppName: Select
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Blaze::AtlasLocation::*)(::Blaze::AtlasEntity*, int, int, int)>(&Blaze::AtlasLocation::Select)> {
  static const MethodInfo* get() {
    static auto* image = &::il2cpp_utils::GetClassFromName("Blaze", "AtlasEntity")->byval_arg;
    static auto* width = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* height = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* spacing = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Blaze::AtlasLocation*), "Select", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{image, width, height, spacing});
  }
};
// Writing MetadataGetter for method: Blaze::AtlasLocation::OptimiseSelect
// Il2CppName: OptimiseSelect
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Blaze::AtlasLocation::*)(::Blaze::AtlasLocation*)>(&Blaze::AtlasLocation::OptimiseSelect)> {
  static const MethodInfo* get() {
    static auto* location = &::il2cpp_utils::GetClassFromName("Blaze", "AtlasLocation")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Blaze::AtlasLocation*), "OptimiseSelect", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{location});
  }
};
// Writing MetadataGetter for method: Blaze::AtlasLocation::BakeUV
// Il2CppName: BakeUV
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Blaze::AtlasLocation::*)()>(&Blaze::AtlasLocation::BakeUV)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Blaze::AtlasLocation*), "BakeUV", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Blaze::AtlasLocation::GetU
// Il2CppName: GetU
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<float (Blaze::AtlasLocation::*)(float)>(&Blaze::AtlasLocation::GetU)> {
  static const MethodInfo* get() {
    static auto* atPixel = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Blaze::AtlasLocation*), "GetU", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{atPixel});
  }
};
// Writing MetadataGetter for method: Blaze::AtlasLocation::GetV
// Il2CppName: GetV
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<float (Blaze::AtlasLocation::*)(float)>(&Blaze::AtlasLocation::GetV)> {
  static const MethodInfo* get() {
    static auto* atPixel = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Blaze::AtlasLocation*), "GetV", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{atPixel});
  }
};
// Writing MetadataGetter for method: Blaze::AtlasLocation::BottomLeftPixel
// Il2CppName: BottomLeftPixel
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (Blaze::AtlasLocation::*)()>(&Blaze::AtlasLocation::BottomLeftPixel)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Blaze::AtlasLocation*), "BottomLeftPixel", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Blaze::AtlasLocation::RowPixelDelta
// Il2CppName: RowPixelDelta
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (Blaze::AtlasLocation::*)()>(&Blaze::AtlasLocation::RowPixelDelta)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Blaze::AtlasLocation*), "RowPixelDelta", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Blaze::AtlasLocation::AtlasIndex
// Il2CppName: AtlasIndex
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (Blaze::AtlasLocation::*)(int, int)>(&Blaze::AtlasLocation::AtlasIndex)> {
  static const MethodInfo* get() {
    static auto* x = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* y = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Blaze::AtlasLocation*), "AtlasIndex", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{x, y});
  }
};
// Writing MetadataGetter for method: Blaze::AtlasLocation::Flush
// Il2CppName: Flush
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Blaze::AtlasLocation::*)()>(&Blaze::AtlasLocation::Flush)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Blaze::AtlasLocation*), "Flush", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Blaze::AtlasLocation::AtlasChanged
// Il2CppName: AtlasChanged
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Blaze::AtlasLocation::*)()>(&Blaze::AtlasLocation::AtlasChanged)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Blaze::AtlasLocation*), "AtlasChanged", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Blaze::AtlasLocation::get_Shared
// Il2CppName: get_Shared
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Blaze::AtlasLocation::*)()>(&Blaze::AtlasLocation::get_Shared)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Blaze::AtlasLocation*), "get_Shared", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
