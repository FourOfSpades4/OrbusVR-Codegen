// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: Blaze.PointReceiver
#include "Blaze/PointReceiver.hpp"
// Including type: UnityEngine.Vector3
#include "UnityEngine/Vector3.hpp"
// Including type: UnityEngine.Color32
#include "UnityEngine/Color32.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: Mesh
  class Mesh;
  // Forward declaring type: GameObject
  class GameObject;
  // Forward declaring type: Material
  class Material;
}
// Forward declaring namespace: InfiniText
namespace InfiniText {
  // Forward declaring type: MoveFromPoint
  class MoveFromPoint;
}
// Forward declaring namespace: Blaze
namespace Blaze {
  // Forward declaring type: Triangulator
  class Triangulator;
  // Forward declaring type: TriangulationVertex
  class TriangulationVertex;
  // Forward declaring type: VectorPath
  class VectorPath;
}
// Completed forward declares
// Type namespace: InfiniText
namespace InfiniText {
  // Forward declaring type: MeshBuffer
  class MeshBuffer;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::InfiniText::MeshBuffer);
DEFINE_IL2CPP_ARG_TYPE(::InfiniText::MeshBuffer*, "InfiniText", "MeshBuffer");
// Type namespace: InfiniText
namespace InfiniText {
  // Size: 0xB8
  #pragma pack(push, 1)
  // Autogenerated type: InfiniText.MeshBuffer
  // [TokenAttribute] Offset: FFFFFFFF
  class MeshBuffer : public ::Il2CppObject/*, public ::Blaze::PointReceiver*/ {
    public:
    public:
    // public System.Single XScaleFactor
    // Size: 0x4
    // Offset: 0x10
    float XScaleFactor;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single YScaleFactor
    // Size: 0x4
    // Offset: 0x14
    float YScaleFactor;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single XOffset
    // Size: 0x4
    // Offset: 0x18
    float XOffset;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single YOffset
    // Size: 0x4
    // Offset: 0x1C
    float YOffset;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Boolean CloseBeforeThis
    // Size: 0x1
    // Offset: 0x20
    bool CloseBeforeThis;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: CloseBeforeThis and: Mesh
    char __padding4[0x7] = {};
    // public UnityEngine.Mesh Mesh
    // Size: 0x8
    // Offset: 0x28
    ::UnityEngine::Mesh* Mesh;
    // Field size check
    static_assert(sizeof(::UnityEngine::Mesh*) == 0x8);
    // private System.Boolean IsClosing
    // Size: 0x1
    // Offset: 0x30
    bool IsClosing;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: IsClosing and: CloseX
    char __padding6[0x3] = {};
    // private System.Single CloseX
    // Size: 0x4
    // Offset: 0x34
    float CloseX;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single CloseY
    // Size: 0x4
    // Offset: 0x38
    float CloseY;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single PreviousX
    // Size: 0x4
    // Offset: 0x3C
    float PreviousX;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single PreviousY
    // Size: 0x4
    // Offset: 0x40
    float PreviousY;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Int32 TotalVertices
    // Size: 0x4
    // Offset: 0x44
    int TotalVertices;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public UnityEngine.Vector3[] Vertices
    // Size: 0x8
    // Offset: 0x48
    ::ArrayW<::UnityEngine::Vector3> Vertices;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::Vector3>) == 0x8);
    // public UnityEngine.Color32[] Colours
    // Size: 0x8
    // Offset: 0x50
    ::ArrayW<::UnityEngine::Color32> Colours;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::Color32>) == 0x8);
    // public System.Int32[] Triangles
    // Size: 0x8
    // Offset: 0x58
    ::ArrayW<int> Triangles;
    // Field size check
    static_assert(sizeof(::ArrayW<int>) == 0x8);
    // private System.Single PreviousInnerSpread
    // Size: 0x4
    // Offset: 0x60
    float PreviousInnerSpread;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single PreviousOuterSpread
    // Size: 0x4
    // Offset: 0x64
    float PreviousOuterSpread;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Int32 CurrentVertex
    // Size: 0x4
    // Offset: 0x68
    int CurrentVertex;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Int32 CurrentTriangle
    // Size: 0x4
    // Offset: 0x6C
    int CurrentTriangle;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 StartIndex
    // Size: 0x4
    // Offset: 0x70
    int StartIndex;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // Padding between fields: StartIndex and: NextInPool
    char __padding19[0x4] = {};
    // public InfiniText.MeshBuffer NextInPool
    // Size: 0x8
    // Offset: 0x78
    ::InfiniText::MeshBuffer* NextInPool;
    // Field size check
    static_assert(sizeof(::InfiniText::MeshBuffer*) == 0x8);
    // UnityEngine.GameObject Gameobject
    // Size: 0x8
    // Offset: 0x80
    ::UnityEngine::GameObject* Gameobject;
    // Field size check
    static_assert(sizeof(::UnityEngine::GameObject*) == 0x8);
    // private System.Boolean Moved
    // Size: 0x1
    // Offset: 0x88
    bool Moved;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: Moved and: LatestMoveFrom
    char __padding22[0x7] = {};
    // private InfiniText.MoveFromPoint LatestMoveFrom
    // Size: 0x8
    // Offset: 0x90
    ::InfiniText::MoveFromPoint* LatestMoveFrom;
    // Field size check
    static_assert(sizeof(::InfiniText::MoveFromPoint*) == 0x8);
    // private System.Single CurrentAccuracy
    // Size: 0x4
    // Offset: 0x98
    float CurrentAccuracy;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Boolean Winding
    // Size: 0x1
    // Offset: 0x9C
    bool Winding;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: Winding and: Triangulator
    char __padding25[0x3] = {};
    // private Blaze.Triangulator Triangulator
    // Size: 0x8
    // Offset: 0xA0
    ::Blaze::Triangulator* Triangulator;
    // Field size check
    static_assert(sizeof(::Blaze::Triangulator*) == 0x8);
    // private Blaze.TriangulationVertex FirstInContour
    // Size: 0x8
    // Offset: 0xA8
    ::Blaze::TriangulationVertex* FirstInContour;
    // Field size check
    static_assert(sizeof(::Blaze::TriangulationVertex*) == 0x8);
    // private Blaze.TriangulationVertex LastInContour
    // Size: 0x8
    // Offset: 0xB0
    ::Blaze::TriangulationVertex* LastInContour;
    // Field size check
    static_assert(sizeof(::Blaze::TriangulationVertex*) == 0x8);
    public:
    // Creating interface conversion operator: operator ::Blaze::PointReceiver
    operator ::Blaze::PointReceiver() noexcept {
      return *reinterpret_cast<::Blaze::PointReceiver*>(this);
    }
    // Get static field: static private readonly UnityEngine.Color32 MidGrey
    static ::UnityEngine::Color32 _get_MidGrey();
    // Set static field: static private readonly UnityEngine.Color32 MidGrey
    static void _set_MidGrey(::UnityEngine::Color32 value);
    // Get static field: static private readonly UnityEngine.Color32 White
    static ::UnityEngine::Color32 _get_White();
    // Set static field: static private readonly UnityEngine.Color32 White
    static void _set_White(::UnityEngine::Color32 value);
    // Get static field: static private readonly UnityEngine.Color32 Black
    static ::UnityEngine::Color32 _get_Black();
    // Set static field: static private readonly UnityEngine.Color32 Black
    static void _set_Black(::UnityEngine::Color32 value);
    // Get static field: static public UnityEngine.Material SharedMaterial
    static ::UnityEngine::Material* _get_SharedMaterial();
    // Set static field: static public UnityEngine.Material SharedMaterial
    static void _set_SharedMaterial(::UnityEngine::Material* value);
    // Get instance field reference: public System.Single XScaleFactor
    [[deprecated("Use field access instead!")]] float& dyn_XScaleFactor();
    // Get instance field reference: public System.Single YScaleFactor
    [[deprecated("Use field access instead!")]] float& dyn_YScaleFactor();
    // Get instance field reference: public System.Single XOffset
    [[deprecated("Use field access instead!")]] float& dyn_XOffset();
    // Get instance field reference: public System.Single YOffset
    [[deprecated("Use field access instead!")]] float& dyn_YOffset();
    // Get instance field reference: private System.Boolean CloseBeforeThis
    [[deprecated("Use field access instead!")]] bool& dyn_CloseBeforeThis();
    // Get instance field reference: public UnityEngine.Mesh Mesh
    [[deprecated("Use field access instead!")]] ::UnityEngine::Mesh*& dyn_Mesh();
    // Get instance field reference: private System.Boolean IsClosing
    [[deprecated("Use field access instead!")]] bool& dyn_IsClosing();
    // Get instance field reference: private System.Single CloseX
    [[deprecated("Use field access instead!")]] float& dyn_CloseX();
    // Get instance field reference: private System.Single CloseY
    [[deprecated("Use field access instead!")]] float& dyn_CloseY();
    // Get instance field reference: private System.Single PreviousX
    [[deprecated("Use field access instead!")]] float& dyn_PreviousX();
    // Get instance field reference: private System.Single PreviousY
    [[deprecated("Use field access instead!")]] float& dyn_PreviousY();
    // Get instance field reference: public System.Int32 TotalVertices
    [[deprecated("Use field access instead!")]] int& dyn_TotalVertices();
    // Get instance field reference: public UnityEngine.Vector3[] Vertices
    [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::Vector3>& dyn_Vertices();
    // Get instance field reference: public UnityEngine.Color32[] Colours
    [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::Color32>& dyn_Colours();
    // Get instance field reference: public System.Int32[] Triangles
    [[deprecated("Use field access instead!")]] ::ArrayW<int>& dyn_Triangles();
    // Get instance field reference: private System.Single PreviousInnerSpread
    [[deprecated("Use field access instead!")]] float& dyn_PreviousInnerSpread();
    // Get instance field reference: private System.Single PreviousOuterSpread
    [[deprecated("Use field access instead!")]] float& dyn_PreviousOuterSpread();
    // Get instance field reference: public System.Int32 CurrentVertex
    [[deprecated("Use field access instead!")]] int& dyn_CurrentVertex();
    // Get instance field reference: public System.Int32 CurrentTriangle
    [[deprecated("Use field access instead!")]] int& dyn_CurrentTriangle();
    // Get instance field reference: private System.Int32 StartIndex
    [[deprecated("Use field access instead!")]] int& dyn_StartIndex();
    // Get instance field reference: public InfiniText.MeshBuffer NextInPool
    [[deprecated("Use field access instead!")]] ::InfiniText::MeshBuffer*& dyn_NextInPool();
    // Get instance field reference: UnityEngine.GameObject Gameobject
    [[deprecated("Use field access instead!")]] ::UnityEngine::GameObject*& dyn_Gameobject();
    // Get instance field reference: private System.Boolean Moved
    [[deprecated("Use field access instead!")]] bool& dyn_Moved();
    // Get instance field reference: private InfiniText.MoveFromPoint LatestMoveFrom
    [[deprecated("Use field access instead!")]] ::InfiniText::MoveFromPoint*& dyn_LatestMoveFrom();
    // Get instance field reference: private System.Single CurrentAccuracy
    [[deprecated("Use field access instead!")]] float& dyn_CurrentAccuracy();
    // Get instance field reference: private System.Boolean Winding
    [[deprecated("Use field access instead!")]] bool& dyn_Winding();
    // Get instance field reference: private Blaze.Triangulator Triangulator
    [[deprecated("Use field access instead!")]] ::Blaze::Triangulator*& dyn_Triangulator();
    // Get instance field reference: private Blaze.TriangulationVertex FirstInContour
    [[deprecated("Use field access instead!")]] ::Blaze::TriangulationVertex*& dyn_FirstInContour();
    // Get instance field reference: private Blaze.TriangulationVertex LastInContour
    [[deprecated("Use field access instead!")]] ::Blaze::TriangulationVertex*& dyn_LastInContour();
    // public System.Void .ctor()
    // Offset: 0x14AD94C
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static MeshBuffer* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::InfiniText::MeshBuffer::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<MeshBuffer*, creationType>()));
    }
    // public System.Void CreateGameObject()
    // Offset: 0x14ADAA4
    void CreateGameObject();
    // public System.Void AddMesh(Blaze.VectorPath path, System.Single xOffset, System.Single yOffset, Blaze.Triangulator triangulator)
    // Offset: 0x14A7BC8
    void AddMesh(::Blaze::VectorPath* path, float xOffset, float yOffset, ::Blaze::Triangulator* triangulator);
    // public System.Void AddPoint(System.Single x, System.Single y)
    // Offset: 0x14ADE38
    void AddPoint(float x, float y);
    // public System.Void MoveTo(System.Single x, System.Single y)
    // Offset: 0x14AEF18
    void MoveTo(float x, float y);
    // public System.Single get_SampleDistance()
    // Offset: 0x14AF3AC
    float get_SampleDistance();
    // public System.Void set_SampleDistance(System.Single value)
    // Offset: 0x14AF3B4
    void set_SampleDistance(float value);
    // public System.Single get_ExtrudeBy()
    // Offset: 0x14AF3B8
    float get_ExtrudeBy();
    // public System.Void set_ExtrudeBy(System.Single value)
    // Offset: 0x14AF3C0
    void set_ExtrudeBy(float value);
    // public System.Void SetActive(System.Boolean active)
    // Offset: 0x14AF3C4
    void SetActive(bool active);
    // public System.Void RequireSize(System.Int32 verts, System.Int32 tris)
    // Offset: 0x14A7AA8
    void RequireSize(int verts, int tris);
    // public System.Void Flush()
    // Offset: 0x14AF3FC
    void Flush();
    // static private System.Void .cctor()
    // Offset: 0x14AF4E4
    static void _cctor();
  }; // InfiniText.MeshBuffer
  #pragma pack(pop)
  static check_size<sizeof(MeshBuffer), 176 + sizeof(::Blaze::TriangulationVertex*)> __InfiniText_MeshBufferSizeCheck;
  static_assert(sizeof(MeshBuffer) == 0xB8);
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: InfiniText::MeshBuffer::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: InfiniText::MeshBuffer::CreateGameObject
// Il2CppName: CreateGameObject
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (InfiniText::MeshBuffer::*)()>(&InfiniText::MeshBuffer::CreateGameObject)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(InfiniText::MeshBuffer*), "CreateGameObject", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: InfiniText::MeshBuffer::AddMesh
// Il2CppName: AddMesh
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (InfiniText::MeshBuffer::*)(::Blaze::VectorPath*, float, float, ::Blaze::Triangulator*)>(&InfiniText::MeshBuffer::AddMesh)> {
  static const MethodInfo* get() {
    static auto* path = &::il2cpp_utils::GetClassFromName("Blaze", "VectorPath")->byval_arg;
    static auto* xOffset = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* yOffset = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* triangulator = &::il2cpp_utils::GetClassFromName("Blaze", "Triangulator")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(InfiniText::MeshBuffer*), "AddMesh", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{path, xOffset, yOffset, triangulator});
  }
};
// Writing MetadataGetter for method: InfiniText::MeshBuffer::AddPoint
// Il2CppName: AddPoint
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (InfiniText::MeshBuffer::*)(float, float)>(&InfiniText::MeshBuffer::AddPoint)> {
  static const MethodInfo* get() {
    static auto* x = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* y = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(InfiniText::MeshBuffer*), "AddPoint", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{x, y});
  }
};
// Writing MetadataGetter for method: InfiniText::MeshBuffer::MoveTo
// Il2CppName: MoveTo
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (InfiniText::MeshBuffer::*)(float, float)>(&InfiniText::MeshBuffer::MoveTo)> {
  static const MethodInfo* get() {
    static auto* x = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* y = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(InfiniText::MeshBuffer*), "MoveTo", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{x, y});
  }
};
// Writing MetadataGetter for method: InfiniText::MeshBuffer::get_SampleDistance
// Il2CppName: get_SampleDistance
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<float (InfiniText::MeshBuffer::*)()>(&InfiniText::MeshBuffer::get_SampleDistance)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(InfiniText::MeshBuffer*), "get_SampleDistance", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: InfiniText::MeshBuffer::set_SampleDistance
// Il2CppName: set_SampleDistance
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (InfiniText::MeshBuffer::*)(float)>(&InfiniText::MeshBuffer::set_SampleDistance)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(InfiniText::MeshBuffer*), "set_SampleDistance", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: InfiniText::MeshBuffer::get_ExtrudeBy
// Il2CppName: get_ExtrudeBy
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<float (InfiniText::MeshBuffer::*)()>(&InfiniText::MeshBuffer::get_ExtrudeBy)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(InfiniText::MeshBuffer*), "get_ExtrudeBy", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: InfiniText::MeshBuffer::set_ExtrudeBy
// Il2CppName: set_ExtrudeBy
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (InfiniText::MeshBuffer::*)(float)>(&InfiniText::MeshBuffer::set_ExtrudeBy)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(InfiniText::MeshBuffer*), "set_ExtrudeBy", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: InfiniText::MeshBuffer::SetActive
// Il2CppName: SetActive
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (InfiniText::MeshBuffer::*)(bool)>(&InfiniText::MeshBuffer::SetActive)> {
  static const MethodInfo* get() {
    static auto* active = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(InfiniText::MeshBuffer*), "SetActive", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{active});
  }
};
// Writing MetadataGetter for method: InfiniText::MeshBuffer::RequireSize
// Il2CppName: RequireSize
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (InfiniText::MeshBuffer::*)(int, int)>(&InfiniText::MeshBuffer::RequireSize)> {
  static const MethodInfo* get() {
    static auto* verts = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* tris = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(InfiniText::MeshBuffer*), "RequireSize", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{verts, tris});
  }
};
// Writing MetadataGetter for method: InfiniText::MeshBuffer::Flush
// Il2CppName: Flush
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (InfiniText::MeshBuffer::*)()>(&InfiniText::MeshBuffer::Flush)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(InfiniText::MeshBuffer*), "Flush", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: InfiniText::MeshBuffer::_cctor
// Il2CppName: .cctor
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)()>(&InfiniText::MeshBuffer::_cctor)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(InfiniText::MeshBuffer*), ".cctor", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
