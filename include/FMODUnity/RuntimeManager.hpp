// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: UnityEngine.MonoBehaviour
#include "UnityEngine/MonoBehaviour.hpp"
// Including type: FMODUnity.FMODPlatform
#include "FMODUnity/FMODPlatform.hpp"
// Including type: FMOD.Studio.System
#include "FMOD/Studio/System.hpp"
// Including type: FMOD.System
#include "FMOD/System.hpp"
// Including type: FMOD.DSP
#include "FMOD/DSP.hpp"
// Including type: System.Guid
#include "System/Guid.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
#include "beatsaber-hook/shared/utils/typedefs-string.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: System::Collections::Generic
namespace System::Collections::Generic {
  // Forward declaring type: List`1<T>
  template<typename T>
  class List_1;
  // Forward declaring type: Dictionary`2<TKey, TValue>
  template<typename TKey, typename TValue>
  class Dictionary_2;
}
// Forward declaring namespace: FMODUnity
namespace FMODUnity {
  // Forward declaring type: SystemNotInitializedException
  class SystemNotInitializedException;
  // Skipping declaration: LoadedBank because it is already included!
  // Forward declaring type: Settings
  class Settings;
}
// Forward declaring namespace: FMOD
namespace FMOD {
  // Forward declaring type: RESULT
  struct RESULT;
  // Forward declaring type: DEBUG_FLAGS
  struct DEBUG_FLAGS;
  // Forward declaring type: StringWrapper
  struct StringWrapper;
}
// Forward declaring namespace: FMOD::Studio
namespace FMOD::Studio {
  // Skipping declaration: EventInstance because it is already included!
  // Skipping declaration: Bus because it is already included!
  // Skipping declaration: VCA because it is already included!
}
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: Transform
  class Transform;
  // Forward declaring type: Rigidbody
  class Rigidbody;
  // Forward declaring type: Rigidbody2D
  class Rigidbody2D;
  // Forward declaring type: TextAsset
  class TextAsset;
  // Skipping declaration: Vector3 because it is already included!
  // Forward declaring type: GameObject
  class GameObject;
}
// Completed forward declares
// Type namespace: FMODUnity
namespace FMODUnity {
  // Forward declaring type: RuntimeManager
  class RuntimeManager;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::FMODUnity::RuntimeManager);
DEFINE_IL2CPP_ARG_TYPE(::FMODUnity::RuntimeManager*, "FMODUnity", "RuntimeManager");
// Type namespace: FMODUnity
namespace FMODUnity {
  // Size: 0x74
  #pragma pack(push, 1)
  // Autogenerated type: FMODUnity.RuntimeManager
  // [TokenAttribute] Offset: FFFFFFFF
  // [AddComponentMenu] Offset: AC2084
  class RuntimeManager : public ::UnityEngine::MonoBehaviour {
    public:
    // Nested type: ::FMODUnity::RuntimeManager::LoadedBank
    struct LoadedBank;
    // Nested type: ::FMODUnity::RuntimeManager::GuidComparer
    class GuidComparer;
    // Nested type: ::FMODUnity::RuntimeManager::AttachedInstance
    class AttachedInstance;
    // Size: 0xC
    #pragma pack(push, 1)
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: FMODUnity.RuntimeManager/LoadedBank
    // [TokenAttribute] Offset: FFFFFFFF
    struct LoadedBank/*, public ::System::ValueType*/ {
      public:
      public:
      // public FMOD.Studio.Bank Bank
      // Size: 0x8
      // Offset: 0x0
      ::FMOD::Studio::Bank Bank;
      // Field size check
      static_assert(sizeof(::FMOD::Studio::Bank) == 0x8);
      // public System.Int32 RefCount
      // Size: 0x4
      // Offset: 0x8
      int RefCount;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      public:
      // Creating value type constructor for type: LoadedBank
      constexpr LoadedBank(::FMOD::Studio::Bank Bank_ = {}, int RefCount_ = {}) noexcept : Bank{Bank_}, RefCount{RefCount_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Get instance field reference: public FMOD.Studio.Bank Bank
      [[deprecated("Use field access instead!")]] ::FMOD::Studio::Bank& dyn_Bank();
      // Get instance field reference: public System.Int32 RefCount
      [[deprecated("Use field access instead!")]] int& dyn_RefCount();
    }; // FMODUnity.RuntimeManager/LoadedBank
    #pragma pack(pop)
    static check_size<sizeof(RuntimeManager::LoadedBank), 8 + sizeof(int)> __FMODUnity_RuntimeManager_LoadedBankSizeCheck;
    static_assert(sizeof(RuntimeManager::LoadedBank) == 0xC);
    public:
    // private FMODUnity.FMODPlatform fmodPlatform
    // Size: 0x4
    // Offset: 0x18
    ::FMODUnity::FMODPlatform fmodPlatform;
    // Field size check
    static_assert(sizeof(::FMODUnity::FMODPlatform) == 0x4);
    // Padding between fields: fmodPlatform and: studioSystem
    char __padding0[0x4] = {};
    // private FMOD.Studio.System studioSystem
    // Size: 0x8
    // Offset: 0x20
    ::FMOD::Studio::System studioSystem;
    // Field size check
    static_assert(sizeof(::FMOD::Studio::System) == 0x8);
    // private FMOD.System lowlevelSystem
    // Size: 0x8
    // Offset: 0x28
    ::FMOD::System lowlevelSystem;
    // Field size check
    static_assert(sizeof(::FMOD::System) == 0x8);
    // private FMOD.DSP mixerHead
    // Size: 0x8
    // Offset: 0x30
    ::FMOD::DSP mixerHead;
    // Field size check
    static_assert(sizeof(::FMOD::DSP) == 0x8);
    // private System.Int64[] cachedPointers
    // Size: 0x8
    // Offset: 0x38
    ::ArrayW<int64_t> cachedPointers;
    // Field size check
    static_assert(sizeof(::ArrayW<int64_t>) == 0x8);
    // private System.Collections.Generic.Dictionary`2<System.String,FMODUnity.RuntimeManager/LoadedBank> loadedBanks
    // Size: 0x8
    // Offset: 0x40
    ::System::Collections::Generic::Dictionary_2<::StringW, ::FMODUnity::RuntimeManager::LoadedBank>* loadedBanks;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::Dictionary_2<::StringW, ::FMODUnity::RuntimeManager::LoadedBank>*) == 0x8);
    // private System.Collections.Generic.Dictionary`2<System.String,System.UInt32> loadedPlugins
    // Size: 0x8
    // Offset: 0x48
    ::System::Collections::Generic::Dictionary_2<::StringW, uint>* loadedPlugins;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::Dictionary_2<::StringW, uint>*) == 0x8);
    // private System.Collections.Generic.Dictionary`2<System.Guid,FMOD.Studio.EventDescription> cachedDescriptions
    // Size: 0x8
    // Offset: 0x50
    ::System::Collections::Generic::Dictionary_2<::System::Guid, ::FMOD::Studio::EventDescription>* cachedDescriptions;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::Dictionary_2<::System::Guid, ::FMOD::Studio::EventDescription>*) == 0x8);
    // private System.Collections.Generic.List`1<FMODUnity.RuntimeManager/AttachedInstance> attachedInstances
    // Size: 0x8
    // Offset: 0x58
    ::System::Collections::Generic::List_1<::FMODUnity::RuntimeManager::AttachedInstance*>* attachedInstances;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::List_1<::FMODUnity::RuntimeManager::AttachedInstance*>*) == 0x8);
    // private System.Boolean listenerWarningIssued
    // Size: 0x1
    // Offset: 0x60
    bool listenerWarningIssued;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: listenerWarningIssued and: lastDebugText
    char __padding9[0x7] = {};
    // private System.String lastDebugText
    // Size: 0x8
    // Offset: 0x68
    ::StringW lastDebugText;
    // Field size check
    static_assert(sizeof(::StringW) == 0x8);
    // private System.Single lastDebugUpdate
    // Size: 0x4
    // Offset: 0x70
    float lastDebugUpdate;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    public:
    // Deleting conversion operator: operator ::System::IntPtr
    constexpr operator ::System::IntPtr() const noexcept = delete;
    // Get static field: static private FMODUnity.SystemNotInitializedException initException
    static ::FMODUnity::SystemNotInitializedException* _get_initException();
    // Set static field: static private FMODUnity.SystemNotInitializedException initException
    static void _set_initException(::FMODUnity::SystemNotInitializedException* value);
    // Get static field: static private FMODUnity.RuntimeManager instance
    static ::FMODUnity::RuntimeManager* _get_instance();
    // Set static field: static private FMODUnity.RuntimeManager instance
    static void _set_instance(::FMODUnity::RuntimeManager* value);
    // Get static field: static private System.Boolean isQuitting
    static bool _get_isQuitting();
    // Set static field: static private System.Boolean isQuitting
    static void _set_isQuitting(bool value);
    // Get static field: static public System.Boolean[] HasListener
    static ::ArrayW<bool> _get_HasListener();
    // Set static field: static public System.Boolean[] HasListener
    static void _set_HasListener(::ArrayW<bool> value);
    // Get instance field reference: private FMODUnity.FMODPlatform fmodPlatform
    [[deprecated("Use field access instead!")]] ::FMODUnity::FMODPlatform& dyn_fmodPlatform();
    // Get instance field reference: private FMOD.Studio.System studioSystem
    [[deprecated("Use field access instead!")]] ::FMOD::Studio::System& dyn_studioSystem();
    // Get instance field reference: private FMOD.System lowlevelSystem
    [[deprecated("Use field access instead!")]] ::FMOD::System& dyn_lowlevelSystem();
    // Get instance field reference: private FMOD.DSP mixerHead
    [[deprecated("Use field access instead!")]] ::FMOD::DSP& dyn_mixerHead();
    // Get instance field reference: private System.Int64[] cachedPointers
    [[deprecated("Use field access instead!")]] ::ArrayW<int64_t>& dyn_cachedPointers();
    // Get instance field reference: private System.Collections.Generic.Dictionary`2<System.String,FMODUnity.RuntimeManager/LoadedBank> loadedBanks
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::Dictionary_2<::StringW, ::FMODUnity::RuntimeManager::LoadedBank>*& dyn_loadedBanks();
    // Get instance field reference: private System.Collections.Generic.Dictionary`2<System.String,System.UInt32> loadedPlugins
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::Dictionary_2<::StringW, uint>*& dyn_loadedPlugins();
    // Get instance field reference: private System.Collections.Generic.Dictionary`2<System.Guid,FMOD.Studio.EventDescription> cachedDescriptions
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::Dictionary_2<::System::Guid, ::FMOD::Studio::EventDescription>*& dyn_cachedDescriptions();
    // Get instance field reference: private System.Collections.Generic.List`1<FMODUnity.RuntimeManager/AttachedInstance> attachedInstances
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::List_1<::FMODUnity::RuntimeManager::AttachedInstance*>*& dyn_attachedInstances();
    // Get instance field reference: private System.Boolean listenerWarningIssued
    [[deprecated("Use field access instead!")]] bool& dyn_listenerWarningIssued();
    // Get instance field reference: private System.String lastDebugText
    [[deprecated("Use field access instead!")]] ::StringW& dyn_lastDebugText();
    // Get instance field reference: private System.Single lastDebugUpdate
    [[deprecated("Use field access instead!")]] float& dyn_lastDebugUpdate();
    // static private FMOD.RESULT DEBUG_CALLBACK(FMOD.DEBUG_FLAGS flags, FMOD.StringWrapper file, System.Int32 line, FMOD.StringWrapper func, FMOD.StringWrapper message)
    // Offset: 0x15D5440
    static ::FMOD::RESULT DEBUG_CALLBACK(::FMOD::DEBUG_FLAGS flags, ::FMOD::StringWrapper file, int line, ::FMOD::StringWrapper func, ::FMOD::StringWrapper message);
    // static private FMODUnity.RuntimeManager get_Instance()
    // Offset: 0x15D5604
    static ::FMODUnity::RuntimeManager* get_Instance();
    // static public FMOD.Studio.System get_StudioSystem()
    // Offset: 0x15D675C
    static ::FMOD::Studio::System get_StudioSystem();
    // static public FMOD.System get_LowlevelSystem()
    // Offset: 0x15D67CC
    static ::FMOD::System get_LowlevelSystem();
    // private System.Void CheckInitResult(FMOD.RESULT result, System.String cause)
    // Offset: 0x15D683C
    void CheckInitResult(::FMOD::RESULT result, ::StringW cause);
    // private FMOD.RESULT Initialize()
    // Offset: 0x15D60A4
    ::FMOD::RESULT Initialize();
    // private System.Void Update()
    // Offset: 0x15D7458
    void Update();
    // static public System.Void AttachInstanceToGameObject(FMOD.Studio.EventInstance instance, UnityEngine.Transform transform, UnityEngine.Rigidbody rigidBody)
    // Offset: 0x15D3F40
    static void AttachInstanceToGameObject(::FMOD::Studio::EventInstance instance, ::UnityEngine::Transform* transform, ::UnityEngine::Rigidbody* rigidBody);
    // static public System.Void AttachInstanceToGameObject(FMOD.Studio.EventInstance instance, UnityEngine.Transform transform, UnityEngine.Rigidbody2D rigidBody2D)
    // Offset: 0x15D4038
    static void AttachInstanceToGameObject(::FMOD::Studio::EventInstance instance, ::UnityEngine::Transform* transform, ::UnityEngine::Rigidbody2D* rigidBody2D);
    // static public System.Void DetachInstanceFromGameObject(FMOD.Studio.EventInstance instance)
    // Offset: 0x15D7B68
    static void DetachInstanceFromGameObject(::FMOD::Studio::EventInstance instance);
    // private System.Void DrawDebugOverlay(System.Int32 windowID)
    // Offset: 0x15D7CA4
    void DrawDebugOverlay(int windowID);
    // private System.Void OnDisable()
    // Offset: 0x15D81AC
    void OnDisable();
    // private System.Void OnDestroy()
    // Offset: 0x15D824C
    void OnDestroy();
    // private System.Void OnApplicationPause(System.Boolean pauseStatus)
    // Offset: 0x15D8310
    void OnApplicationPause(bool pauseStatus);
    // private System.Void loadedBankRegister(FMODUnity.RuntimeManager/LoadedBank loadedBank, System.String bankPath, System.String bankName, System.Boolean loadSamples, FMOD.RESULT loadResult)
    // Offset: 0x15D8478
    void loadedBankRegister(::FMODUnity::RuntimeManager::LoadedBank loadedBank, ::StringW bankPath, ::StringW bankName, bool loadSamples, ::FMOD::RESULT loadResult);
    // static public System.Void LoadBank(System.String bankName, System.Boolean loadSamples)
    // Offset: 0x15D8628
    static void LoadBank(::StringW bankName, bool loadSamples);
    // static public System.Void LoadBank(UnityEngine.TextAsset asset, System.Boolean loadSamples)
    // Offset: 0x15D8BC0
    static void LoadBank(::UnityEngine::TextAsset* asset, bool loadSamples);
    // private System.Void LoadBanks(FMODUnity.Settings fmodSettings)
    // Offset: 0x15D70C0
    void LoadBanks(::FMODUnity::Settings* fmodSettings);
    // static public System.Void UnloadBank(System.String bankName)
    // Offset: 0x15D8EFC
    static void UnloadBank(::StringW bankName);
    // static public System.Boolean AnyBankLoading()
    // Offset: 0x15D907C
    static bool AnyBankLoading();
    // static public System.Void WaitForAllLoads()
    // Offset: 0x15D8E8C
    static void WaitForAllLoads();
    // static public System.Guid PathToGUID(System.String path)
    // Offset: 0x15D9208
    static ::System::Guid PathToGUID(::StringW path);
    // static public FMOD.Studio.EventInstance CreateInstance(System.String path)
    // Offset: 0x15D3E2C
    static ::FMOD::Studio::EventInstance CreateInstance(::StringW path);
    // static public FMOD.Studio.EventInstance CreateInstance(System.Guid guid)
    // Offset: 0x15D9340
    static ::FMOD::Studio::EventInstance CreateInstance(::System::Guid guid);
    // static public System.Void PlayOneShot(System.String path, UnityEngine.Vector3 position)
    // Offset: 0x15D9644
    static void PlayOneShot(::StringW path, ::UnityEngine::Vector3 position);
    // static public System.Void PlayOneShot(System.Guid guid, UnityEngine.Vector3 position)
    // Offset: 0x15D97A4
    static void PlayOneShot(::System::Guid guid, ::UnityEngine::Vector3 position);
    // static public System.Void PlayOneShotAttached(System.String path, UnityEngine.GameObject gameObject)
    // Offset: 0x15D9884
    static void PlayOneShotAttached(::StringW path, ::UnityEngine::GameObject* gameObject);
    // static public System.Void PlayOneShotAttached(System.Guid guid, UnityEngine.GameObject gameObject)
    // Offset: 0x15D99C8
    static void PlayOneShotAttached(::System::Guid guid, ::UnityEngine::GameObject* gameObject);
    // static public FMOD.Studio.EventDescription GetEventDescription(System.String path)
    // Offset: 0x15D9ACC
    static ::FMOD::Studio::EventDescription GetEventDescription(::StringW path);
    // static public FMOD.Studio.EventDescription GetEventDescription(System.Guid guid)
    // Offset: 0x15D93DC
    static ::FMOD::Studio::EventDescription GetEventDescription(::System::Guid guid);
    // static public System.Void SetListenerLocation(UnityEngine.GameObject gameObject, UnityEngine.Rigidbody rigidBody)
    // Offset: 0x15D9BE0
    static void SetListenerLocation(::UnityEngine::GameObject* gameObject, ::UnityEngine::Rigidbody* rigidBody);
    // static public System.Void SetListenerLocation(UnityEngine.GameObject gameObject, UnityEngine.Rigidbody2D rigidBody2D)
    // Offset: 0x15D9DC0
    static void SetListenerLocation(::UnityEngine::GameObject* gameObject, ::UnityEngine::Rigidbody2D* rigidBody2D);
    // static public System.Void SetListenerLocation(UnityEngine.Transform transform)
    // Offset: 0x15D9FC8
    static void SetListenerLocation(::UnityEngine::Transform* transform);
    // static public System.Void SetListenerLocation(System.Int32 listenerIndex, UnityEngine.GameObject gameObject, UnityEngine.Rigidbody rigidBody)
    // Offset: 0x15DA124
    static void SetListenerLocation(int listenerIndex, ::UnityEngine::GameObject* gameObject, ::UnityEngine::Rigidbody* rigidBody);
    // static public System.Void SetListenerLocation(System.Int32 listenerIndex, UnityEngine.GameObject gameObject, UnityEngine.Rigidbody2D rigidBody2D)
    // Offset: 0x15DA1CC
    static void SetListenerLocation(int listenerIndex, ::UnityEngine::GameObject* gameObject, ::UnityEngine::Rigidbody2D* rigidBody2D);
    // static public System.Void SetListenerLocation(System.Int32 listenerIndex, UnityEngine.Transform transform)
    // Offset: 0x15DA274
    static void SetListenerLocation(int listenerIndex, ::UnityEngine::Transform* transform);
    // static public FMOD.Studio.Bus GetBus(System.String path)
    // Offset: 0x15DA314
    static ::FMOD::Studio::Bus GetBus(::StringW path);
    // static public FMOD.Studio.VCA GetVCA(System.String path)
    // Offset: 0x15DA3D8
    static ::FMOD::Studio::VCA GetVCA(::StringW path);
    // static public System.Void PauseAllEvents(System.Boolean paused)
    // Offset: 0x15D83B8
    static void PauseAllEvents(bool paused);
    // static public System.Void MuteAllEvents(System.Boolean muted)
    // Offset: 0x15DA5E0
    static void MuteAllEvents(bool muted);
    // static public System.Boolean get_IsInitialized()
    // Offset: 0x15DA6A0
    static bool get_IsInitialized();
    // static public System.Boolean get_HasBanksLoaded()
    // Offset: 0x15DA548
    static bool get_HasBanksLoaded();
    // static public System.Boolean HasBankLoaded(System.String loadedBank)
    // Offset: 0x15DA784
    static bool HasBankLoaded(::StringW loadedBank);
    // private System.Void LoadPlugins(FMODUnity.Settings fmodSettings)
    // Offset: 0x15D6EDC
    void LoadPlugins(::FMODUnity::Settings* fmodSettings);
    // private System.Void SetThreadAffinity()
    // Offset: 0x15D6E44
    void SetThreadAffinity();
    // public System.Void .ctor()
    // Offset: 0x15DA924
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static RuntimeManager* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::FMODUnity::RuntimeManager::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<RuntimeManager*, creationType>()));
    }
    // static private System.Void .cctor()
    // Offset: 0x15DAA58
    static void _cctor();
  }; // FMODUnity.RuntimeManager
  #pragma pack(pop)
  static check_size<sizeof(RuntimeManager), 112 + sizeof(float)> __FMODUnity_RuntimeManagerSizeCheck;
  static_assert(sizeof(RuntimeManager) == 0x74);
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::FMODUnity::RuntimeManager::LoadedBank, "FMODUnity", "RuntimeManager/LoadedBank");
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: FMODUnity::RuntimeManager::DEBUG_CALLBACK
// Il2CppName: DEBUG_CALLBACK
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::FMOD::RESULT (*)(::FMOD::DEBUG_FLAGS, ::FMOD::StringWrapper, int, ::FMOD::StringWrapper, ::FMOD::StringWrapper)>(&FMODUnity::RuntimeManager::DEBUG_CALLBACK)> {
  static const MethodInfo* get() {
    static auto* flags = &::il2cpp_utils::GetClassFromName("FMOD", "DEBUG_FLAGS")->byval_arg;
    static auto* file = &::il2cpp_utils::GetClassFromName("FMOD", "StringWrapper")->byval_arg;
    static auto* line = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* func = &::il2cpp_utils::GetClassFromName("FMOD", "StringWrapper")->byval_arg;
    static auto* message = &::il2cpp_utils::GetClassFromName("FMOD", "StringWrapper")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(FMODUnity::RuntimeManager*), "DEBUG_CALLBACK", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{flags, file, line, func, message});
  }
};
// Writing MetadataGetter for method: FMODUnity::RuntimeManager::get_Instance
// Il2CppName: get_Instance
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::FMODUnity::RuntimeManager* (*)()>(&FMODUnity::RuntimeManager::get_Instance)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(FMODUnity::RuntimeManager*), "get_Instance", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: FMODUnity::RuntimeManager::get_StudioSystem
// Il2CppName: get_StudioSystem
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::FMOD::Studio::System (*)()>(&FMODUnity::RuntimeManager::get_StudioSystem)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(FMODUnity::RuntimeManager*), "get_StudioSystem", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: FMODUnity::RuntimeManager::get_LowlevelSystem
// Il2CppName: get_LowlevelSystem
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::FMOD::System (*)()>(&FMODUnity::RuntimeManager::get_LowlevelSystem)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(FMODUnity::RuntimeManager*), "get_LowlevelSystem", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: FMODUnity::RuntimeManager::CheckInitResult
// Il2CppName: CheckInitResult
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (FMODUnity::RuntimeManager::*)(::FMOD::RESULT, ::StringW)>(&FMODUnity::RuntimeManager::CheckInitResult)> {
  static const MethodInfo* get() {
    static auto* result = &::il2cpp_utils::GetClassFromName("FMOD", "RESULT")->byval_arg;
    static auto* cause = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(FMODUnity::RuntimeManager*), "CheckInitResult", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{result, cause});
  }
};
// Writing MetadataGetter for method: FMODUnity::RuntimeManager::Initialize
// Il2CppName: Initialize
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::FMOD::RESULT (FMODUnity::RuntimeManager::*)()>(&FMODUnity::RuntimeManager::Initialize)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(FMODUnity::RuntimeManager*), "Initialize", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: FMODUnity::RuntimeManager::Update
// Il2CppName: Update
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (FMODUnity::RuntimeManager::*)()>(&FMODUnity::RuntimeManager::Update)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(FMODUnity::RuntimeManager*), "Update", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: FMODUnity::RuntimeManager::AttachInstanceToGameObject
// Il2CppName: AttachInstanceToGameObject
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(::FMOD::Studio::EventInstance, ::UnityEngine::Transform*, ::UnityEngine::Rigidbody*)>(&FMODUnity::RuntimeManager::AttachInstanceToGameObject)> {
  static const MethodInfo* get() {
    static auto* instance = &::il2cpp_utils::GetClassFromName("FMOD.Studio", "EventInstance")->byval_arg;
    static auto* transform = &::il2cpp_utils::GetClassFromName("UnityEngine", "Transform")->byval_arg;
    static auto* rigidBody = &::il2cpp_utils::GetClassFromName("UnityEngine", "Rigidbody")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(FMODUnity::RuntimeManager*), "AttachInstanceToGameObject", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{instance, transform, rigidBody});
  }
};
// Writing MetadataGetter for method: FMODUnity::RuntimeManager::AttachInstanceToGameObject
// Il2CppName: AttachInstanceToGameObject
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(::FMOD::Studio::EventInstance, ::UnityEngine::Transform*, ::UnityEngine::Rigidbody2D*)>(&FMODUnity::RuntimeManager::AttachInstanceToGameObject)> {
  static const MethodInfo* get() {
    static auto* instance = &::il2cpp_utils::GetClassFromName("FMOD.Studio", "EventInstance")->byval_arg;
    static auto* transform = &::il2cpp_utils::GetClassFromName("UnityEngine", "Transform")->byval_arg;
    static auto* rigidBody2D = &::il2cpp_utils::GetClassFromName("UnityEngine", "Rigidbody2D")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(FMODUnity::RuntimeManager*), "AttachInstanceToGameObject", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{instance, transform, rigidBody2D});
  }
};
// Writing MetadataGetter for method: FMODUnity::RuntimeManager::DetachInstanceFromGameObject
// Il2CppName: DetachInstanceFromGameObject
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(::FMOD::Studio::EventInstance)>(&FMODUnity::RuntimeManager::DetachInstanceFromGameObject)> {
  static const MethodInfo* get() {
    static auto* instance = &::il2cpp_utils::GetClassFromName("FMOD.Studio", "EventInstance")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(FMODUnity::RuntimeManager*), "DetachInstanceFromGameObject", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{instance});
  }
};
// Writing MetadataGetter for method: FMODUnity::RuntimeManager::DrawDebugOverlay
// Il2CppName: DrawDebugOverlay
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (FMODUnity::RuntimeManager::*)(int)>(&FMODUnity::RuntimeManager::DrawDebugOverlay)> {
  static const MethodInfo* get() {
    static auto* windowID = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(FMODUnity::RuntimeManager*), "DrawDebugOverlay", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{windowID});
  }
};
// Writing MetadataGetter for method: FMODUnity::RuntimeManager::OnDisable
// Il2CppName: OnDisable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (FMODUnity::RuntimeManager::*)()>(&FMODUnity::RuntimeManager::OnDisable)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(FMODUnity::RuntimeManager*), "OnDisable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: FMODUnity::RuntimeManager::OnDestroy
// Il2CppName: OnDestroy
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (FMODUnity::RuntimeManager::*)()>(&FMODUnity::RuntimeManager::OnDestroy)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(FMODUnity::RuntimeManager*), "OnDestroy", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: FMODUnity::RuntimeManager::OnApplicationPause
// Il2CppName: OnApplicationPause
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (FMODUnity::RuntimeManager::*)(bool)>(&FMODUnity::RuntimeManager::OnApplicationPause)> {
  static const MethodInfo* get() {
    static auto* pauseStatus = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(FMODUnity::RuntimeManager*), "OnApplicationPause", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{pauseStatus});
  }
};
// Writing MetadataGetter for method: FMODUnity::RuntimeManager::loadedBankRegister
// Il2CppName: loadedBankRegister
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (FMODUnity::RuntimeManager::*)(::FMODUnity::RuntimeManager::LoadedBank, ::StringW, ::StringW, bool, ::FMOD::RESULT)>(&FMODUnity::RuntimeManager::loadedBankRegister)> {
  static const MethodInfo* get() {
    static auto* loadedBank = &::il2cpp_utils::GetClassFromName("FMODUnity", "RuntimeManager/LoadedBank")->byval_arg;
    static auto* bankPath = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* bankName = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* loadSamples = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* loadResult = &::il2cpp_utils::GetClassFromName("FMOD", "RESULT")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(FMODUnity::RuntimeManager*), "loadedBankRegister", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{loadedBank, bankPath, bankName, loadSamples, loadResult});
  }
};
// Writing MetadataGetter for method: FMODUnity::RuntimeManager::LoadBank
// Il2CppName: LoadBank
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(::StringW, bool)>(&FMODUnity::RuntimeManager::LoadBank)> {
  static const MethodInfo* get() {
    static auto* bankName = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* loadSamples = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(FMODUnity::RuntimeManager*), "LoadBank", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{bankName, loadSamples});
  }
};
// Writing MetadataGetter for method: FMODUnity::RuntimeManager::LoadBank
// Il2CppName: LoadBank
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(::UnityEngine::TextAsset*, bool)>(&FMODUnity::RuntimeManager::LoadBank)> {
  static const MethodInfo* get() {
    static auto* asset = &::il2cpp_utils::GetClassFromName("UnityEngine", "TextAsset")->byval_arg;
    static auto* loadSamples = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(FMODUnity::RuntimeManager*), "LoadBank", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{asset, loadSamples});
  }
};
// Writing MetadataGetter for method: FMODUnity::RuntimeManager::LoadBanks
// Il2CppName: LoadBanks
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (FMODUnity::RuntimeManager::*)(::FMODUnity::Settings*)>(&FMODUnity::RuntimeManager::LoadBanks)> {
  static const MethodInfo* get() {
    static auto* fmodSettings = &::il2cpp_utils::GetClassFromName("FMODUnity", "Settings")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(FMODUnity::RuntimeManager*), "LoadBanks", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{fmodSettings});
  }
};
// Writing MetadataGetter for method: FMODUnity::RuntimeManager::UnloadBank
// Il2CppName: UnloadBank
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(::StringW)>(&FMODUnity::RuntimeManager::UnloadBank)> {
  static const MethodInfo* get() {
    static auto* bankName = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(FMODUnity::RuntimeManager*), "UnloadBank", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{bankName});
  }
};
// Writing MetadataGetter for method: FMODUnity::RuntimeManager::AnyBankLoading
// Il2CppName: AnyBankLoading
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)()>(&FMODUnity::RuntimeManager::AnyBankLoading)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(FMODUnity::RuntimeManager*), "AnyBankLoading", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: FMODUnity::RuntimeManager::WaitForAllLoads
// Il2CppName: WaitForAllLoads
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)()>(&FMODUnity::RuntimeManager::WaitForAllLoads)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(FMODUnity::RuntimeManager*), "WaitForAllLoads", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: FMODUnity::RuntimeManager::PathToGUID
// Il2CppName: PathToGUID
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Guid (*)(::StringW)>(&FMODUnity::RuntimeManager::PathToGUID)> {
  static const MethodInfo* get() {
    static auto* path = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(FMODUnity::RuntimeManager*), "PathToGUID", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{path});
  }
};
// Writing MetadataGetter for method: FMODUnity::RuntimeManager::CreateInstance
// Il2CppName: CreateInstance
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::FMOD::Studio::EventInstance (*)(::StringW)>(&FMODUnity::RuntimeManager::CreateInstance)> {
  static const MethodInfo* get() {
    static auto* path = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(FMODUnity::RuntimeManager*), "CreateInstance", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{path});
  }
};
// Writing MetadataGetter for method: FMODUnity::RuntimeManager::CreateInstance
// Il2CppName: CreateInstance
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::FMOD::Studio::EventInstance (*)(::System::Guid)>(&FMODUnity::RuntimeManager::CreateInstance)> {
  static const MethodInfo* get() {
    static auto* guid = &::il2cpp_utils::GetClassFromName("System", "Guid")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(FMODUnity::RuntimeManager*), "CreateInstance", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{guid});
  }
};
// Writing MetadataGetter for method: FMODUnity::RuntimeManager::PlayOneShot
// Il2CppName: PlayOneShot
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(::StringW, ::UnityEngine::Vector3)>(&FMODUnity::RuntimeManager::PlayOneShot)> {
  static const MethodInfo* get() {
    static auto* path = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* position = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(FMODUnity::RuntimeManager*), "PlayOneShot", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{path, position});
  }
};
// Writing MetadataGetter for method: FMODUnity::RuntimeManager::PlayOneShot
// Il2CppName: PlayOneShot
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(::System::Guid, ::UnityEngine::Vector3)>(&FMODUnity::RuntimeManager::PlayOneShot)> {
  static const MethodInfo* get() {
    static auto* guid = &::il2cpp_utils::GetClassFromName("System", "Guid")->byval_arg;
    static auto* position = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(FMODUnity::RuntimeManager*), "PlayOneShot", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{guid, position});
  }
};
// Writing MetadataGetter for method: FMODUnity::RuntimeManager::PlayOneShotAttached
// Il2CppName: PlayOneShotAttached
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(::StringW, ::UnityEngine::GameObject*)>(&FMODUnity::RuntimeManager::PlayOneShotAttached)> {
  static const MethodInfo* get() {
    static auto* path = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* gameObject = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(FMODUnity::RuntimeManager*), "PlayOneShotAttached", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{path, gameObject});
  }
};
// Writing MetadataGetter for method: FMODUnity::RuntimeManager::PlayOneShotAttached
// Il2CppName: PlayOneShotAttached
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(::System::Guid, ::UnityEngine::GameObject*)>(&FMODUnity::RuntimeManager::PlayOneShotAttached)> {
  static const MethodInfo* get() {
    static auto* guid = &::il2cpp_utils::GetClassFromName("System", "Guid")->byval_arg;
    static auto* gameObject = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(FMODUnity::RuntimeManager*), "PlayOneShotAttached", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{guid, gameObject});
  }
};
// Writing MetadataGetter for method: FMODUnity::RuntimeManager::GetEventDescription
// Il2CppName: GetEventDescription
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::FMOD::Studio::EventDescription (*)(::StringW)>(&FMODUnity::RuntimeManager::GetEventDescription)> {
  static const MethodInfo* get() {
    static auto* path = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(FMODUnity::RuntimeManager*), "GetEventDescription", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{path});
  }
};
// Writing MetadataGetter for method: FMODUnity::RuntimeManager::GetEventDescription
// Il2CppName: GetEventDescription
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::FMOD::Studio::EventDescription (*)(::System::Guid)>(&FMODUnity::RuntimeManager::GetEventDescription)> {
  static const MethodInfo* get() {
    static auto* guid = &::il2cpp_utils::GetClassFromName("System", "Guid")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(FMODUnity::RuntimeManager*), "GetEventDescription", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{guid});
  }
};
// Writing MetadataGetter for method: FMODUnity::RuntimeManager::SetListenerLocation
// Il2CppName: SetListenerLocation
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(::UnityEngine::GameObject*, ::UnityEngine::Rigidbody*)>(&FMODUnity::RuntimeManager::SetListenerLocation)> {
  static const MethodInfo* get() {
    static auto* gameObject = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    static auto* rigidBody = &::il2cpp_utils::GetClassFromName("UnityEngine", "Rigidbody")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(FMODUnity::RuntimeManager*), "SetListenerLocation", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{gameObject, rigidBody});
  }
};
// Writing MetadataGetter for method: FMODUnity::RuntimeManager::SetListenerLocation
// Il2CppName: SetListenerLocation
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(::UnityEngine::GameObject*, ::UnityEngine::Rigidbody2D*)>(&FMODUnity::RuntimeManager::SetListenerLocation)> {
  static const MethodInfo* get() {
    static auto* gameObject = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    static auto* rigidBody2D = &::il2cpp_utils::GetClassFromName("UnityEngine", "Rigidbody2D")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(FMODUnity::RuntimeManager*), "SetListenerLocation", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{gameObject, rigidBody2D});
  }
};
// Writing MetadataGetter for method: FMODUnity::RuntimeManager::SetListenerLocation
// Il2CppName: SetListenerLocation
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(::UnityEngine::Transform*)>(&FMODUnity::RuntimeManager::SetListenerLocation)> {
  static const MethodInfo* get() {
    static auto* transform = &::il2cpp_utils::GetClassFromName("UnityEngine", "Transform")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(FMODUnity::RuntimeManager*), "SetListenerLocation", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{transform});
  }
};
// Writing MetadataGetter for method: FMODUnity::RuntimeManager::SetListenerLocation
// Il2CppName: SetListenerLocation
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(int, ::UnityEngine::GameObject*, ::UnityEngine::Rigidbody*)>(&FMODUnity::RuntimeManager::SetListenerLocation)> {
  static const MethodInfo* get() {
    static auto* listenerIndex = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* gameObject = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    static auto* rigidBody = &::il2cpp_utils::GetClassFromName("UnityEngine", "Rigidbody")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(FMODUnity::RuntimeManager*), "SetListenerLocation", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{listenerIndex, gameObject, rigidBody});
  }
};
// Writing MetadataGetter for method: FMODUnity::RuntimeManager::SetListenerLocation
// Il2CppName: SetListenerLocation
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(int, ::UnityEngine::GameObject*, ::UnityEngine::Rigidbody2D*)>(&FMODUnity::RuntimeManager::SetListenerLocation)> {
  static const MethodInfo* get() {
    static auto* listenerIndex = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* gameObject = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    static auto* rigidBody2D = &::il2cpp_utils::GetClassFromName("UnityEngine", "Rigidbody2D")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(FMODUnity::RuntimeManager*), "SetListenerLocation", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{listenerIndex, gameObject, rigidBody2D});
  }
};
// Writing MetadataGetter for method: FMODUnity::RuntimeManager::SetListenerLocation
// Il2CppName: SetListenerLocation
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(int, ::UnityEngine::Transform*)>(&FMODUnity::RuntimeManager::SetListenerLocation)> {
  static const MethodInfo* get() {
    static auto* listenerIndex = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* transform = &::il2cpp_utils::GetClassFromName("UnityEngine", "Transform")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(FMODUnity::RuntimeManager*), "SetListenerLocation", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{listenerIndex, transform});
  }
};
// Writing MetadataGetter for method: FMODUnity::RuntimeManager::GetBus
// Il2CppName: GetBus
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::FMOD::Studio::Bus (*)(::StringW)>(&FMODUnity::RuntimeManager::GetBus)> {
  static const MethodInfo* get() {
    static auto* path = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(FMODUnity::RuntimeManager*), "GetBus", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{path});
  }
};
// Writing MetadataGetter for method: FMODUnity::RuntimeManager::GetVCA
// Il2CppName: GetVCA
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::FMOD::Studio::VCA (*)(::StringW)>(&FMODUnity::RuntimeManager::GetVCA)> {
  static const MethodInfo* get() {
    static auto* path = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(FMODUnity::RuntimeManager*), "GetVCA", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{path});
  }
};
// Writing MetadataGetter for method: FMODUnity::RuntimeManager::PauseAllEvents
// Il2CppName: PauseAllEvents
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(bool)>(&FMODUnity::RuntimeManager::PauseAllEvents)> {
  static const MethodInfo* get() {
    static auto* paused = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(FMODUnity::RuntimeManager*), "PauseAllEvents", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{paused});
  }
};
// Writing MetadataGetter for method: FMODUnity::RuntimeManager::MuteAllEvents
// Il2CppName: MuteAllEvents
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(bool)>(&FMODUnity::RuntimeManager::MuteAllEvents)> {
  static const MethodInfo* get() {
    static auto* muted = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(FMODUnity::RuntimeManager*), "MuteAllEvents", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{muted});
  }
};
// Writing MetadataGetter for method: FMODUnity::RuntimeManager::get_IsInitialized
// Il2CppName: get_IsInitialized
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)()>(&FMODUnity::RuntimeManager::get_IsInitialized)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(FMODUnity::RuntimeManager*), "get_IsInitialized", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: FMODUnity::RuntimeManager::get_HasBanksLoaded
// Il2CppName: get_HasBanksLoaded
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)()>(&FMODUnity::RuntimeManager::get_HasBanksLoaded)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(FMODUnity::RuntimeManager*), "get_HasBanksLoaded", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: FMODUnity::RuntimeManager::HasBankLoaded
// Il2CppName: HasBankLoaded
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)(::StringW)>(&FMODUnity::RuntimeManager::HasBankLoaded)> {
  static const MethodInfo* get() {
    static auto* loadedBank = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(FMODUnity::RuntimeManager*), "HasBankLoaded", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{loadedBank});
  }
};
// Writing MetadataGetter for method: FMODUnity::RuntimeManager::LoadPlugins
// Il2CppName: LoadPlugins
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (FMODUnity::RuntimeManager::*)(::FMODUnity::Settings*)>(&FMODUnity::RuntimeManager::LoadPlugins)> {
  static const MethodInfo* get() {
    static auto* fmodSettings = &::il2cpp_utils::GetClassFromName("FMODUnity", "Settings")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(FMODUnity::RuntimeManager*), "LoadPlugins", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{fmodSettings});
  }
};
// Writing MetadataGetter for method: FMODUnity::RuntimeManager::SetThreadAffinity
// Il2CppName: SetThreadAffinity
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (FMODUnity::RuntimeManager::*)()>(&FMODUnity::RuntimeManager::SetThreadAffinity)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(FMODUnity::RuntimeManager*), "SetThreadAffinity", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: FMODUnity::RuntimeManager::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: FMODUnity::RuntimeManager::_cctor
// Il2CppName: .cctor
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)()>(&FMODUnity::RuntimeManager::_cctor)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(FMODUnity::RuntimeManager*), ".cctor", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
