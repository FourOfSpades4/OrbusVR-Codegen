// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: UnityEngine.MonoBehaviour
#include "UnityEngine/MonoBehaviour.hpp"
// Including type: UnityEngine.LayerMask
#include "UnityEngine/LayerMask.hpp"
// Including type: SteamVR_Controller
#include "GlobalNamespace/SteamVR_Controller.hpp"
// Including type: SteamVR_Events
#include "GlobalNamespace/SteamVR_Events.hpp"
// Including type: System.Int32
#include "System/Int32.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
#include "beatsaber-hook/shared/utils/typedefs-string.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: Transform
  class Transform;
  // Forward declaring type: Camera
  class Camera;
  // Forward declaring type: GameObject
  class GameObject;
  // Forward declaring type: TextMesh
  class TextMesh;
  // Forward declaring type: Collider
  class Collider;
  // Skipping declaration: Vector3 because it is already included!
}
// Forward declaring namespace: System::Collections::ObjectModel
namespace System::Collections::ObjectModel {
  // Forward declaring type: ReadOnlyCollection`1<T>
  template<typename T>
  class ReadOnlyCollection_1;
}
// Forward declaring namespace: Valve::VR::InteractionSystem
namespace Valve::VR::InteractionSystem {
  // Forward declaring type: Interactable
  class Interactable;
  // Forward declaring type: Player
  class Player;
  // Skipping declaration: HandType because it is already included!
  // Skipping declaration: AttachmentFlags because it is already included!
}
// Forward declaring namespace: System::Collections::Generic
namespace System::Collections::Generic {
  // Forward declaring type: List`1<T>
  template<typename T>
  class List_1;
}
// Forward declaring namespace: System::Collections
namespace System::Collections {
  // Forward declaring type: IEnumerator
  class IEnumerator;
}
// Completed forward declares
// Type namespace: Valve.VR.InteractionSystem
namespace Valve::VR::InteractionSystem {
  // Forward declaring type: Hand
  class Hand;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::Valve::VR::InteractionSystem::Hand);
DEFINE_IL2CPP_ARG_TYPE(::Valve::VR::InteractionSystem::Hand*, "Valve.VR.InteractionSystem", "Hand");
// Type namespace: Valve.VR.InteractionSystem
namespace Valve::VR::InteractionSystem {
  // Size: 0xC0
  #pragma pack(push, 1)
  // Autogenerated type: Valve.VR.InteractionSystem.Hand
  // [TokenAttribute] Offset: FFFFFFFF
  class Hand : public ::UnityEngine::MonoBehaviour {
    public:
    // Nested type: ::Valve::VR::InteractionSystem::Hand::HandType
    struct HandType;
    // Nested type: ::Valve::VR::InteractionSystem::Hand::AttachmentFlags
    struct AttachmentFlags;
    // Nested type: ::Valve::VR::InteractionSystem::Hand::AttachedObject
    struct AttachedObject;
    // Nested type: ::Valve::VR::InteractionSystem::Hand::$$c__DisplayClass42_0
    class $$c__DisplayClass42_0;
    // Nested type: ::Valve::VR::InteractionSystem::Hand::$$c
    class $$c;
    // Nested type: ::Valve::VR::InteractionSystem::Hand::$Start$d__47
    class $Start$d__47;
    // Nested type: ::Valve::VR::InteractionSystem::Hand::$$c__DisplayClass48_0
    class $$c__DisplayClass48_0;
    // Size: 0x4
    #pragma pack(push, 1)
    // Autogenerated type: Valve.VR.InteractionSystem.Hand/HandType
    // [TokenAttribute] Offset: FFFFFFFF
    struct HandType/*, public ::System::Enum*/ {
      public:
      public:
      // public System.Int32 value__
      // Size: 0x4
      // Offset: 0x0
      int value;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      public:
      // Creating value type constructor for type: HandType
      constexpr HandType(int value_ = {}) noexcept : value{value_} {}
      // Creating interface conversion operator: operator ::System::Enum
      operator ::System::Enum() noexcept {
        return *reinterpret_cast<::System::Enum*>(this);
      }
      // Creating conversion operator: operator int
      constexpr operator int() const noexcept {
        return value;
      }
      // static field const value: static public Valve.VR.InteractionSystem.Hand/HandType Left
      static constexpr const int Left = 0;
      // Get static field: static public Valve.VR.InteractionSystem.Hand/HandType Left
      static ::Valve::VR::InteractionSystem::Hand::HandType _get_Left();
      // Set static field: static public Valve.VR.InteractionSystem.Hand/HandType Left
      static void _set_Left(::Valve::VR::InteractionSystem::Hand::HandType value);
      // static field const value: static public Valve.VR.InteractionSystem.Hand/HandType Right
      static constexpr const int Right = 1;
      // Get static field: static public Valve.VR.InteractionSystem.Hand/HandType Right
      static ::Valve::VR::InteractionSystem::Hand::HandType _get_Right();
      // Set static field: static public Valve.VR.InteractionSystem.Hand/HandType Right
      static void _set_Right(::Valve::VR::InteractionSystem::Hand::HandType value);
      // static field const value: static public Valve.VR.InteractionSystem.Hand/HandType Any
      static constexpr const int Any = 2;
      // Get static field: static public Valve.VR.InteractionSystem.Hand/HandType Any
      static ::Valve::VR::InteractionSystem::Hand::HandType _get_Any();
      // Set static field: static public Valve.VR.InteractionSystem.Hand/HandType Any
      static void _set_Any(::Valve::VR::InteractionSystem::Hand::HandType value);
      // Get instance field reference: public System.Int32 value__
      [[deprecated("Use field access instead!")]] int& dyn_value__();
    }; // Valve.VR.InteractionSystem.Hand/HandType
    #pragma pack(pop)
    static check_size<sizeof(Hand::HandType), 0 + sizeof(int)> __Valve_VR_InteractionSystem_Hand_HandTypeSizeCheck;
    static_assert(sizeof(Hand::HandType) == 0x4);
    // Size: 0x4
    #pragma pack(push, 1)
    // Autogenerated type: Valve.VR.InteractionSystem.Hand/AttachmentFlags
    // [TokenAttribute] Offset: FFFFFFFF
    // [FlagsAttribute] Offset: FFFFFFFF
    struct AttachmentFlags/*, public ::System::Enum*/ {
      public:
      public:
      // public System.Int32 value__
      // Size: 0x4
      // Offset: 0x0
      int value;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      public:
      // Creating value type constructor for type: AttachmentFlags
      constexpr AttachmentFlags(int value_ = {}) noexcept : value{value_} {}
      // Creating interface conversion operator: operator ::System::Enum
      operator ::System::Enum() noexcept {
        return *reinterpret_cast<::System::Enum*>(this);
      }
      // Creating conversion operator: operator int
      constexpr operator int() const noexcept {
        return value;
      }
      // static field const value: static public Valve.VR.InteractionSystem.Hand/AttachmentFlags SnapOnAttach
      static constexpr const int SnapOnAttach = 1;
      // Get static field: static public Valve.VR.InteractionSystem.Hand/AttachmentFlags SnapOnAttach
      static ::Valve::VR::InteractionSystem::Hand::AttachmentFlags _get_SnapOnAttach();
      // Set static field: static public Valve.VR.InteractionSystem.Hand/AttachmentFlags SnapOnAttach
      static void _set_SnapOnAttach(::Valve::VR::InteractionSystem::Hand::AttachmentFlags value);
      // static field const value: static public Valve.VR.InteractionSystem.Hand/AttachmentFlags DetachOthers
      static constexpr const int DetachOthers = 2;
      // Get static field: static public Valve.VR.InteractionSystem.Hand/AttachmentFlags DetachOthers
      static ::Valve::VR::InteractionSystem::Hand::AttachmentFlags _get_DetachOthers();
      // Set static field: static public Valve.VR.InteractionSystem.Hand/AttachmentFlags DetachOthers
      static void _set_DetachOthers(::Valve::VR::InteractionSystem::Hand::AttachmentFlags value);
      // static field const value: static public Valve.VR.InteractionSystem.Hand/AttachmentFlags DetachFromOtherHand
      static constexpr const int DetachFromOtherHand = 4;
      // Get static field: static public Valve.VR.InteractionSystem.Hand/AttachmentFlags DetachFromOtherHand
      static ::Valve::VR::InteractionSystem::Hand::AttachmentFlags _get_DetachFromOtherHand();
      // Set static field: static public Valve.VR.InteractionSystem.Hand/AttachmentFlags DetachFromOtherHand
      static void _set_DetachFromOtherHand(::Valve::VR::InteractionSystem::Hand::AttachmentFlags value);
      // static field const value: static public Valve.VR.InteractionSystem.Hand/AttachmentFlags ParentToHand
      static constexpr const int ParentToHand = 8;
      // Get static field: static public Valve.VR.InteractionSystem.Hand/AttachmentFlags ParentToHand
      static ::Valve::VR::InteractionSystem::Hand::AttachmentFlags _get_ParentToHand();
      // Set static field: static public Valve.VR.InteractionSystem.Hand/AttachmentFlags ParentToHand
      static void _set_ParentToHand(::Valve::VR::InteractionSystem::Hand::AttachmentFlags value);
      // Get instance field reference: public System.Int32 value__
      [[deprecated("Use field access instead!")]] int& dyn_value__();
    }; // Valve.VR.InteractionSystem.Hand/AttachmentFlags
    #pragma pack(pop)
    static check_size<sizeof(Hand::AttachmentFlags), 0 + sizeof(int)> __Valve_VR_InteractionSystem_Hand_AttachmentFlagsSizeCheck;
    static_assert(sizeof(Hand::AttachmentFlags) == 0x4);
    // Size: 0x11
    #pragma pack(push, 1)
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: Valve.VR.InteractionSystem.Hand/AttachedObject
    // [TokenAttribute] Offset: FFFFFFFF
    struct AttachedObject/*, public ::System::ValueType*/ {
      public:
      public:
      // public UnityEngine.GameObject attachedObject
      // Size: 0x8
      // Offset: 0x0
      ::UnityEngine::GameObject* attachedObject;
      // Field size check
      static_assert(sizeof(::UnityEngine::GameObject*) == 0x8);
      // public UnityEngine.GameObject originalParent
      // Size: 0x8
      // Offset: 0x8
      ::UnityEngine::GameObject* originalParent;
      // Field size check
      static_assert(sizeof(::UnityEngine::GameObject*) == 0x8);
      // public System.Boolean isParentedToHand
      // Size: 0x1
      // Offset: 0x10
      bool isParentedToHand;
      // Field size check
      static_assert(sizeof(bool) == 0x1);
      public:
      // Creating value type constructor for type: AttachedObject
      constexpr AttachedObject(::UnityEngine::GameObject* attachedObject_ = {}, ::UnityEngine::GameObject* originalParent_ = {}, bool isParentedToHand_ = {}) noexcept : attachedObject{attachedObject_}, originalParent{originalParent_}, isParentedToHand{isParentedToHand_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Get instance field reference: public UnityEngine.GameObject attachedObject
      [[deprecated("Use field access instead!")]] ::UnityEngine::GameObject*& dyn_attachedObject();
      // Get instance field reference: public UnityEngine.GameObject originalParent
      [[deprecated("Use field access instead!")]] ::UnityEngine::GameObject*& dyn_originalParent();
      // Get instance field reference: public System.Boolean isParentedToHand
      [[deprecated("Use field access instead!")]] bool& dyn_isParentedToHand();
    }; // Valve.VR.InteractionSystem.Hand/AttachedObject
    #pragma pack(pop)
    static check_size<sizeof(Hand::AttachedObject), 16 + sizeof(bool)> __Valve_VR_InteractionSystem_Hand_AttachedObjectSizeCheck;
    static_assert(sizeof(Hand::AttachedObject) == 0x11);
    public:
    // public Valve.VR.InteractionSystem.Hand otherHand
    // Size: 0x8
    // Offset: 0x18
    ::Valve::VR::InteractionSystem::Hand* otherHand;
    // Field size check
    static_assert(sizeof(::Valve::VR::InteractionSystem::Hand*) == 0x8);
    // public Valve.VR.InteractionSystem.Hand/HandType startingHandType
    // Size: 0x4
    // Offset: 0x20
    ::Valve::VR::InteractionSystem::Hand::HandType startingHandType;
    // Field size check
    static_assert(sizeof(::Valve::VR::InteractionSystem::Hand::HandType) == 0x4);
    // Padding between fields: startingHandType and: hoverSphereTransform
    char __padding1[0x4] = {};
    // public UnityEngine.Transform hoverSphereTransform
    // Size: 0x8
    // Offset: 0x28
    ::UnityEngine::Transform* hoverSphereTransform;
    // Field size check
    static_assert(sizeof(::UnityEngine::Transform*) == 0x8);
    // public System.Single hoverSphereRadius
    // Size: 0x4
    // Offset: 0x30
    float hoverSphereRadius;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public UnityEngine.LayerMask hoverLayerMask
    // Size: 0x4
    // Offset: 0x34
    ::UnityEngine::LayerMask hoverLayerMask;
    // Field size check
    static_assert(sizeof(::UnityEngine::LayerMask) == 0x4);
    // public System.Single hoverUpdateInterval
    // Size: 0x4
    // Offset: 0x38
    float hoverUpdateInterval;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // Padding between fields: hoverUpdateInterval and: noSteamVRFallbackCamera
    char __padding5[0x4] = {};
    // public UnityEngine.Camera noSteamVRFallbackCamera
    // Size: 0x8
    // Offset: 0x40
    ::UnityEngine::Camera* noSteamVRFallbackCamera;
    // Field size check
    static_assert(sizeof(::UnityEngine::Camera*) == 0x8);
    // public System.Single noSteamVRFallbackMaxDistanceNoItem
    // Size: 0x4
    // Offset: 0x48
    float noSteamVRFallbackMaxDistanceNoItem;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single noSteamVRFallbackMaxDistanceWithItem
    // Size: 0x4
    // Offset: 0x4C
    float noSteamVRFallbackMaxDistanceWithItem;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single noSteamVRFallbackInteractorDistance
    // Size: 0x4
    // Offset: 0x50
    float noSteamVRFallbackInteractorDistance;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // Padding between fields: noSteamVRFallbackInteractorDistance and: controller
    char __padding9[0x4] = {};
    // public SteamVR_Controller/Device controller
    // Size: 0x8
    // Offset: 0x58
    ::GlobalNamespace::SteamVR_Controller::Device* controller;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::SteamVR_Controller::Device*) == 0x8);
    // public UnityEngine.GameObject controllerPrefab
    // Size: 0x8
    // Offset: 0x60
    ::UnityEngine::GameObject* controllerPrefab;
    // Field size check
    static_assert(sizeof(::UnityEngine::GameObject*) == 0x8);
    // private UnityEngine.GameObject controllerObject
    // Size: 0x8
    // Offset: 0x68
    ::UnityEngine::GameObject* controllerObject;
    // Field size check
    static_assert(sizeof(::UnityEngine::GameObject*) == 0x8);
    // public System.Boolean showDebugText
    // Size: 0x1
    // Offset: 0x70
    bool showDebugText;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Boolean spewDebugText
    // Size: 0x1
    // Offset: 0x71
    bool spewDebugText;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: spewDebugText and: attachedObjects
    char __padding14[0x6] = {};
    // private System.Collections.Generic.List`1<Valve.VR.InteractionSystem.Hand/AttachedObject> attachedObjects
    // Size: 0x8
    // Offset: 0x78
    ::System::Collections::Generic::List_1<::Valve::VR::InteractionSystem::Hand::AttachedObject>* attachedObjects;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::List_1<::Valve::VR::InteractionSystem::Hand::AttachedObject>*) == 0x8);
    // [CompilerGeneratedAttribute] Offset: 0xADDCB0
    // private System.Boolean <hoverLocked>k__BackingField
    // Size: 0x1
    // Offset: 0x80
    bool hoverLocked;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: hoverLocked and: hoveringInteractable
    char __padding16[0x7] = {};
    // private Valve.VR.InteractionSystem.Interactable _hoveringInteractable
    // Size: 0x8
    // Offset: 0x88
    ::Valve::VR::InteractionSystem::Interactable* hoveringInteractable;
    // Field size check
    static_assert(sizeof(::Valve::VR::InteractionSystem::Interactable*) == 0x8);
    // private UnityEngine.TextMesh debugText
    // Size: 0x8
    // Offset: 0x90
    ::UnityEngine::TextMesh* debugText;
    // Field size check
    static_assert(sizeof(::UnityEngine::TextMesh*) == 0x8);
    // private System.Int32 prevOverlappingColliders
    // Size: 0x4
    // Offset: 0x98
    int prevOverlappingColliders;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // Padding between fields: prevOverlappingColliders and: overlappingColliders
    char __padding19[0x4] = {};
    // private UnityEngine.Collider[] overlappingColliders
    // Size: 0x8
    // Offset: 0xA0
    ::ArrayW<::UnityEngine::Collider*> overlappingColliders;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::Collider*>) == 0x8);
    // private Valve.VR.InteractionSystem.Player playerInstance
    // Size: 0x8
    // Offset: 0xA8
    ::Valve::VR::InteractionSystem::Player* playerInstance;
    // Field size check
    static_assert(sizeof(::Valve::VR::InteractionSystem::Player*) == 0x8);
    // private UnityEngine.GameObject applicationLostFocusObject
    // Size: 0x8
    // Offset: 0xB0
    ::UnityEngine::GameObject* applicationLostFocusObject;
    // Field size check
    static_assert(sizeof(::UnityEngine::GameObject*) == 0x8);
    // private SteamVR_Events/Action inputFocusAction
    // Size: 0x8
    // Offset: 0xB8
    ::GlobalNamespace::SteamVR_Events::Action* inputFocusAction;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::SteamVR_Events::Action*) == 0x8);
    public:
    // Deleting conversion operator: operator ::System::IntPtr
    constexpr operator ::System::IntPtr() const noexcept = delete;
    // static field const value: static public Valve.VR.InteractionSystem.Hand/AttachmentFlags defaultAttachmentFlags
    static constexpr const int defaultAttachmentFlags = 15;
    // Get static field: static public Valve.VR.InteractionSystem.Hand/AttachmentFlags defaultAttachmentFlags
    static ::Valve::VR::InteractionSystem::Hand::AttachmentFlags _get_defaultAttachmentFlags();
    // Set static field: static public Valve.VR.InteractionSystem.Hand/AttachmentFlags defaultAttachmentFlags
    static void _set_defaultAttachmentFlags(::Valve::VR::InteractionSystem::Hand::AttachmentFlags value);
    // static field const value: static private System.Int32 ColliderArraySize
    static constexpr const int ColliderArraySize = 16;
    // Get static field: static private System.Int32 ColliderArraySize
    static int _get_ColliderArraySize();
    // Set static field: static private System.Int32 ColliderArraySize
    static void _set_ColliderArraySize(int value);
    // Get instance field reference: public Valve.VR.InteractionSystem.Hand otherHand
    [[deprecated("Use field access instead!")]] ::Valve::VR::InteractionSystem::Hand*& dyn_otherHand();
    // Get instance field reference: public Valve.VR.InteractionSystem.Hand/HandType startingHandType
    [[deprecated("Use field access instead!")]] ::Valve::VR::InteractionSystem::Hand::HandType& dyn_startingHandType();
    // Get instance field reference: public UnityEngine.Transform hoverSphereTransform
    [[deprecated("Use field access instead!")]] ::UnityEngine::Transform*& dyn_hoverSphereTransform();
    // Get instance field reference: public System.Single hoverSphereRadius
    [[deprecated("Use field access instead!")]] float& dyn_hoverSphereRadius();
    // Get instance field reference: public UnityEngine.LayerMask hoverLayerMask
    [[deprecated("Use field access instead!")]] ::UnityEngine::LayerMask& dyn_hoverLayerMask();
    // Get instance field reference: public System.Single hoverUpdateInterval
    [[deprecated("Use field access instead!")]] float& dyn_hoverUpdateInterval();
    // Get instance field reference: public UnityEngine.Camera noSteamVRFallbackCamera
    [[deprecated("Use field access instead!")]] ::UnityEngine::Camera*& dyn_noSteamVRFallbackCamera();
    // Get instance field reference: public System.Single noSteamVRFallbackMaxDistanceNoItem
    [[deprecated("Use field access instead!")]] float& dyn_noSteamVRFallbackMaxDistanceNoItem();
    // Get instance field reference: public System.Single noSteamVRFallbackMaxDistanceWithItem
    [[deprecated("Use field access instead!")]] float& dyn_noSteamVRFallbackMaxDistanceWithItem();
    // Get instance field reference: private System.Single noSteamVRFallbackInteractorDistance
    [[deprecated("Use field access instead!")]] float& dyn_noSteamVRFallbackInteractorDistance();
    // Get instance field reference: public SteamVR_Controller/Device controller
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::SteamVR_Controller::Device*& dyn_controller();
    // Get instance field reference: public UnityEngine.GameObject controllerPrefab
    [[deprecated("Use field access instead!")]] ::UnityEngine::GameObject*& dyn_controllerPrefab();
    // Get instance field reference: private UnityEngine.GameObject controllerObject
    [[deprecated("Use field access instead!")]] ::UnityEngine::GameObject*& dyn_controllerObject();
    // Get instance field reference: public System.Boolean showDebugText
    [[deprecated("Use field access instead!")]] bool& dyn_showDebugText();
    // Get instance field reference: public System.Boolean spewDebugText
    [[deprecated("Use field access instead!")]] bool& dyn_spewDebugText();
    // Get instance field reference: private System.Collections.Generic.List`1<Valve.VR.InteractionSystem.Hand/AttachedObject> attachedObjects
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::List_1<::Valve::VR::InteractionSystem::Hand::AttachedObject>*& dyn_attachedObjects();
    // Get instance field reference: private System.Boolean <hoverLocked>k__BackingField
    [[deprecated("Use field access instead!")]] bool& dyn_$hoverLocked$k__BackingField();
    // Get instance field reference: private Valve.VR.InteractionSystem.Interactable _hoveringInteractable
    [[deprecated("Use field access instead!")]] ::Valve::VR::InteractionSystem::Interactable*& dyn__hoveringInteractable();
    // Get instance field reference: private UnityEngine.TextMesh debugText
    [[deprecated("Use field access instead!")]] ::UnityEngine::TextMesh*& dyn_debugText();
    // Get instance field reference: private System.Int32 prevOverlappingColliders
    [[deprecated("Use field access instead!")]] int& dyn_prevOverlappingColliders();
    // Get instance field reference: private UnityEngine.Collider[] overlappingColliders
    [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::Collider*>& dyn_overlappingColliders();
    // Get instance field reference: private Valve.VR.InteractionSystem.Player playerInstance
    [[deprecated("Use field access instead!")]] ::Valve::VR::InteractionSystem::Player*& dyn_playerInstance();
    // Get instance field reference: private UnityEngine.GameObject applicationLostFocusObject
    [[deprecated("Use field access instead!")]] ::UnityEngine::GameObject*& dyn_applicationLostFocusObject();
    // Get instance field reference: private SteamVR_Events/Action inputFocusAction
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::SteamVR_Events::Action*& dyn_inputFocusAction();
    // public System.Collections.ObjectModel.ReadOnlyCollection`1<Valve.VR.InteractionSystem.Hand/AttachedObject> get_AttachedObjects()
    // Offset: 0x116736C
    ::System::Collections::ObjectModel::ReadOnlyCollection_1<::Valve::VR::InteractionSystem::Hand::AttachedObject>* get_AttachedObjects();
    // public System.Boolean get_hoverLocked()
    // Offset: 0x11673CC
    bool get_hoverLocked();
    // private System.Void set_hoverLocked(System.Boolean value)
    // Offset: 0x11673D4
    void set_hoverLocked(bool value);
    // public Valve.VR.InteractionSystem.Interactable get_hoveringInteractable()
    // Offset: 0x115CF90
    ::Valve::VR::InteractionSystem::Interactable* get_hoveringInteractable();
    // public System.Void set_hoveringInteractable(Valve.VR.InteractionSystem.Interactable value)
    // Offset: 0x11673E0
    void set_hoveringInteractable(::Valve::VR::InteractionSystem::Interactable* value);
    // public UnityEngine.GameObject get_currentAttachedObject()
    // Offset: 0x1167724
    ::UnityEngine::GameObject* get_currentAttachedObject();
    // public UnityEngine.Transform GetAttachmentTransform(System.String attachmentPoint)
    // Offset: 0x1167910
    ::UnityEngine::Transform* GetAttachmentTransform(::StringW attachmentPoint);
    // public Valve.VR.InteractionSystem.Hand/HandType GuessCurrentHandType()
    // Offset: 0x11679E8
    ::Valve::VR::InteractionSystem::Hand::HandType GuessCurrentHandType();
    // public System.Void AttachObject(UnityEngine.GameObject objectToAttach, Valve.VR.InteractionSystem.Hand/AttachmentFlags flags, System.String attachmentPoint)
    // Offset: 0x115E9A4
    void AttachObject(::UnityEngine::GameObject* objectToAttach, ::Valve::VR::InteractionSystem::Hand::AttachmentFlags flags, ::StringW attachmentPoint);
    // public System.Void DetachObject(UnityEngine.GameObject objectToDetach, System.Boolean restoreOriginalParent)
    // Offset: 0x115EE40
    void DetachObject(::UnityEngine::GameObject* objectToDetach, bool restoreOriginalParent);
    // public UnityEngine.Vector3 GetTrackedObjectVelocity()
    // Offset: 0x11682B0
    ::UnityEngine::Vector3 GetTrackedObjectVelocity();
    // public UnityEngine.Vector3 GetTrackedObjectAngularVelocity()
    // Offset: 0x11683B0
    ::UnityEngine::Vector3 GetTrackedObjectAngularVelocity();
    // private System.Void CleanUpAttachedObjectStack()
    // Offset: 0x116780C
    void CleanUpAttachedObjectStack();
    // private System.Void Awake()
    // Offset: 0x11684B0
    void Awake();
    // private System.Collections.IEnumerator Start()
    // Offset: 0x1168634
    ::System::Collections::IEnumerator* Start();
    // private System.Void UpdateHovering()
    // Offset: 0x1167B30
    void UpdateHovering();
    // private System.Void UpdateNoSteamVRFallback()
    // Offset: 0x11686DC
    void UpdateNoSteamVRFallback();
    // private System.Void UpdateDebugText()
    // Offset: 0x1168B10
    void UpdateDebugText();
    // private System.Void OnEnable()
    // Offset: 0x1169248
    void OnEnable();
    // private System.Void OnDisable()
    // Offset: 0x1169368
    void OnDisable();
    // private System.Void Update()
    // Offset: 0x11693AC
    void Update();
    // private System.Void LateUpdate()
    // Offset: 0x11694D0
    void LateUpdate();
    // private System.Void OnInputFocus(System.Boolean hasFocus)
    // Offset: 0x1169594
    void OnInputFocus(bool hasFocus);
    // private System.Void FixedUpdate()
    // Offset: 0x1169854
    void FixedUpdate();
    // private System.Void OnDrawGizmos()
    // Offset: 0x1169858
    void OnDrawGizmos();
    // private System.Void HandDebugLog(System.String msg)
    // Offset: 0x1167658
    void HandDebugLog(::StringW msg);
    // private System.Void UpdateHandPoses()
    // Offset: 0x1169684
    void UpdateHandPoses();
    // public System.Void HoverLock(Valve.VR.InteractionSystem.Interactable interactable)
    // Offset: 0x1158710
    void HoverLock(::Valve::VR::InteractionSystem::Interactable* interactable);
    // public System.Void HoverUnlock(Valve.VR.InteractionSystem.Interactable interactable)
    // Offset: 0x1158B88
    void HoverUnlock(::Valve::VR::InteractionSystem::Interactable* interactable);
    // public System.Boolean GetStandardInteractionButtonDown()
    // Offset: 0x115C78C
    bool GetStandardInteractionButtonDown();
    // public System.Boolean GetStandardInteractionButtonUp()
    // Offset: 0x115CEF0
    bool GetStandardInteractionButtonUp();
    // public System.Boolean GetStandardInteractionButton()
    // Offset: 0x115C4D0
    bool GetStandardInteractionButton();
    // private System.Void InitController(System.Int32 index)
    // Offset: 0x1169948
    void InitController(int index);
    // public System.Void .ctor()
    // Offset: 0x1169DC0
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static Hand* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::Valve::VR::InteractionSystem::Hand::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<Hand*, creationType>()));
    }
  }; // Valve.VR.InteractionSystem.Hand
  #pragma pack(pop)
  static check_size<sizeof(Hand), 184 + sizeof(::GlobalNamespace::SteamVR_Events::Action*)> __Valve_VR_InteractionSystem_HandSizeCheck;
  static_assert(sizeof(Hand) == 0xC0);
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::Valve::VR::InteractionSystem::Hand::AttachedObject, "Valve.VR.InteractionSystem", "Hand/AttachedObject");
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::Valve::VR::InteractionSystem::Hand::AttachmentFlags, "Valve.VR.InteractionSystem", "Hand/AttachmentFlags");
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::Valve::VR::InteractionSystem::Hand::HandType, "Valve.VR.InteractionSystem", "Hand/HandType");
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Hand::get_AttachedObjects
// Il2CppName: get_AttachedObjects
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Collections::ObjectModel::ReadOnlyCollection_1<::Valve::VR::InteractionSystem::Hand::AttachedObject>* (Valve::VR::InteractionSystem::Hand::*)()>(&Valve::VR::InteractionSystem::Hand::get_AttachedObjects)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Hand*), "get_AttachedObjects", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Hand::get_hoverLocked
// Il2CppName: get_hoverLocked
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Valve::VR::InteractionSystem::Hand::*)()>(&Valve::VR::InteractionSystem::Hand::get_hoverLocked)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Hand*), "get_hoverLocked", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Hand::set_hoverLocked
// Il2CppName: set_hoverLocked
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::Hand::*)(bool)>(&Valve::VR::InteractionSystem::Hand::set_hoverLocked)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Hand*), "set_hoverLocked", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Hand::get_hoveringInteractable
// Il2CppName: get_hoveringInteractable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Valve::VR::InteractionSystem::Interactable* (Valve::VR::InteractionSystem::Hand::*)()>(&Valve::VR::InteractionSystem::Hand::get_hoveringInteractable)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Hand*), "get_hoveringInteractable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Hand::set_hoveringInteractable
// Il2CppName: set_hoveringInteractable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::Hand::*)(::Valve::VR::InteractionSystem::Interactable*)>(&Valve::VR::InteractionSystem::Hand::set_hoveringInteractable)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("Valve.VR.InteractionSystem", "Interactable")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Hand*), "set_hoveringInteractable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Hand::get_currentAttachedObject
// Il2CppName: get_currentAttachedObject
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::GameObject* (Valve::VR::InteractionSystem::Hand::*)()>(&Valve::VR::InteractionSystem::Hand::get_currentAttachedObject)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Hand*), "get_currentAttachedObject", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Hand::GetAttachmentTransform
// Il2CppName: GetAttachmentTransform
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Transform* (Valve::VR::InteractionSystem::Hand::*)(::StringW)>(&Valve::VR::InteractionSystem::Hand::GetAttachmentTransform)> {
  static const MethodInfo* get() {
    static auto* attachmentPoint = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Hand*), "GetAttachmentTransform", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{attachmentPoint});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Hand::GuessCurrentHandType
// Il2CppName: GuessCurrentHandType
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Valve::VR::InteractionSystem::Hand::HandType (Valve::VR::InteractionSystem::Hand::*)()>(&Valve::VR::InteractionSystem::Hand::GuessCurrentHandType)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Hand*), "GuessCurrentHandType", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Hand::AttachObject
// Il2CppName: AttachObject
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::Hand::*)(::UnityEngine::GameObject*, ::Valve::VR::InteractionSystem::Hand::AttachmentFlags, ::StringW)>(&Valve::VR::InteractionSystem::Hand::AttachObject)> {
  static const MethodInfo* get() {
    static auto* objectToAttach = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    static auto* flags = &::il2cpp_utils::GetClassFromName("Valve.VR.InteractionSystem", "Hand/AttachmentFlags")->byval_arg;
    static auto* attachmentPoint = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Hand*), "AttachObject", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{objectToAttach, flags, attachmentPoint});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Hand::DetachObject
// Il2CppName: DetachObject
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::Hand::*)(::UnityEngine::GameObject*, bool)>(&Valve::VR::InteractionSystem::Hand::DetachObject)> {
  static const MethodInfo* get() {
    static auto* objectToDetach = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    static auto* restoreOriginalParent = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Hand*), "DetachObject", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{objectToDetach, restoreOriginalParent});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Hand::GetTrackedObjectVelocity
// Il2CppName: GetTrackedObjectVelocity
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Vector3 (Valve::VR::InteractionSystem::Hand::*)()>(&Valve::VR::InteractionSystem::Hand::GetTrackedObjectVelocity)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Hand*), "GetTrackedObjectVelocity", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Hand::GetTrackedObjectAngularVelocity
// Il2CppName: GetTrackedObjectAngularVelocity
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Vector3 (Valve::VR::InteractionSystem::Hand::*)()>(&Valve::VR::InteractionSystem::Hand::GetTrackedObjectAngularVelocity)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Hand*), "GetTrackedObjectAngularVelocity", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Hand::CleanUpAttachedObjectStack
// Il2CppName: CleanUpAttachedObjectStack
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::Hand::*)()>(&Valve::VR::InteractionSystem::Hand::CleanUpAttachedObjectStack)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Hand*), "CleanUpAttachedObjectStack", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Hand::Awake
// Il2CppName: Awake
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::Hand::*)()>(&Valve::VR::InteractionSystem::Hand::Awake)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Hand*), "Awake", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Hand::Start
// Il2CppName: Start
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Collections::IEnumerator* (Valve::VR::InteractionSystem::Hand::*)()>(&Valve::VR::InteractionSystem::Hand::Start)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Hand*), "Start", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Hand::UpdateHovering
// Il2CppName: UpdateHovering
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::Hand::*)()>(&Valve::VR::InteractionSystem::Hand::UpdateHovering)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Hand*), "UpdateHovering", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Hand::UpdateNoSteamVRFallback
// Il2CppName: UpdateNoSteamVRFallback
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::Hand::*)()>(&Valve::VR::InteractionSystem::Hand::UpdateNoSteamVRFallback)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Hand*), "UpdateNoSteamVRFallback", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Hand::UpdateDebugText
// Il2CppName: UpdateDebugText
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::Hand::*)()>(&Valve::VR::InteractionSystem::Hand::UpdateDebugText)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Hand*), "UpdateDebugText", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Hand::OnEnable
// Il2CppName: OnEnable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::Hand::*)()>(&Valve::VR::InteractionSystem::Hand::OnEnable)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Hand*), "OnEnable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Hand::OnDisable
// Il2CppName: OnDisable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::Hand::*)()>(&Valve::VR::InteractionSystem::Hand::OnDisable)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Hand*), "OnDisable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Hand::Update
// Il2CppName: Update
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::Hand::*)()>(&Valve::VR::InteractionSystem::Hand::Update)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Hand*), "Update", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Hand::LateUpdate
// Il2CppName: LateUpdate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::Hand::*)()>(&Valve::VR::InteractionSystem::Hand::LateUpdate)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Hand*), "LateUpdate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Hand::OnInputFocus
// Il2CppName: OnInputFocus
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::Hand::*)(bool)>(&Valve::VR::InteractionSystem::Hand::OnInputFocus)> {
  static const MethodInfo* get() {
    static auto* hasFocus = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Hand*), "OnInputFocus", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{hasFocus});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Hand::FixedUpdate
// Il2CppName: FixedUpdate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::Hand::*)()>(&Valve::VR::InteractionSystem::Hand::FixedUpdate)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Hand*), "FixedUpdate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Hand::OnDrawGizmos
// Il2CppName: OnDrawGizmos
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::Hand::*)()>(&Valve::VR::InteractionSystem::Hand::OnDrawGizmos)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Hand*), "OnDrawGizmos", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Hand::HandDebugLog
// Il2CppName: HandDebugLog
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::Hand::*)(::StringW)>(&Valve::VR::InteractionSystem::Hand::HandDebugLog)> {
  static const MethodInfo* get() {
    static auto* msg = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Hand*), "HandDebugLog", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{msg});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Hand::UpdateHandPoses
// Il2CppName: UpdateHandPoses
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::Hand::*)()>(&Valve::VR::InteractionSystem::Hand::UpdateHandPoses)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Hand*), "UpdateHandPoses", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Hand::HoverLock
// Il2CppName: HoverLock
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::Hand::*)(::Valve::VR::InteractionSystem::Interactable*)>(&Valve::VR::InteractionSystem::Hand::HoverLock)> {
  static const MethodInfo* get() {
    static auto* interactable = &::il2cpp_utils::GetClassFromName("Valve.VR.InteractionSystem", "Interactable")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Hand*), "HoverLock", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{interactable});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Hand::HoverUnlock
// Il2CppName: HoverUnlock
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::Hand::*)(::Valve::VR::InteractionSystem::Interactable*)>(&Valve::VR::InteractionSystem::Hand::HoverUnlock)> {
  static const MethodInfo* get() {
    static auto* interactable = &::il2cpp_utils::GetClassFromName("Valve.VR.InteractionSystem", "Interactable")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Hand*), "HoverUnlock", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{interactable});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Hand::GetStandardInteractionButtonDown
// Il2CppName: GetStandardInteractionButtonDown
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Valve::VR::InteractionSystem::Hand::*)()>(&Valve::VR::InteractionSystem::Hand::GetStandardInteractionButtonDown)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Hand*), "GetStandardInteractionButtonDown", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Hand::GetStandardInteractionButtonUp
// Il2CppName: GetStandardInteractionButtonUp
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Valve::VR::InteractionSystem::Hand::*)()>(&Valve::VR::InteractionSystem::Hand::GetStandardInteractionButtonUp)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Hand*), "GetStandardInteractionButtonUp", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Hand::GetStandardInteractionButton
// Il2CppName: GetStandardInteractionButton
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Valve::VR::InteractionSystem::Hand::*)()>(&Valve::VR::InteractionSystem::Hand::GetStandardInteractionButton)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Hand*), "GetStandardInteractionButton", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Hand::InitController
// Il2CppName: InitController
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::Hand::*)(int)>(&Valve::VR::InteractionSystem::Hand::InitController)> {
  static const MethodInfo* get() {
    static auto* index = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Hand*), "InitController", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{index});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Hand::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
