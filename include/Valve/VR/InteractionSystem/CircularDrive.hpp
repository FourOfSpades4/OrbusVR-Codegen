// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: UnityEngine.MonoBehaviour
#include "UnityEngine/MonoBehaviour.hpp"
// Including type: UnityEngine.Vector2
#include "UnityEngine/Vector2.hpp"
// Including type: UnityEngine.Color
#include "UnityEngine/Color.hpp"
// Including type: SteamVR_Controller
#include "GlobalNamespace/SteamVR_Controller.hpp"
// Including type: System.Enum
#include "System/Enum.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: Collider
  class Collider;
  // Forward declaring type: TextMesh
  class TextMesh;
  // Forward declaring type: GameObject
  class GameObject;
  // Forward declaring type: Transform
  class Transform;
}
// Forward declaring namespace: Valve::VR::InteractionSystem
namespace Valve::VR::InteractionSystem {
  // Forward declaring type: LinearMapping
  class LinearMapping;
  // Forward declaring type: Hand
  class Hand;
}
// Forward declaring namespace: UnityEngine::Events
namespace UnityEngine::Events {
  // Forward declaring type: UnityEvent
  class UnityEvent;
}
// Forward declaring namespace: System::Collections
namespace System::Collections {
  // Forward declaring type: IEnumerator
  class IEnumerator;
}
// Completed forward declares
// Type namespace: Valve.VR.InteractionSystem
namespace Valve::VR::InteractionSystem {
  // Forward declaring type: CircularDrive
  class CircularDrive;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::Valve::VR::InteractionSystem::CircularDrive);
DEFINE_IL2CPP_ARG_TYPE(::Valve::VR::InteractionSystem::CircularDrive*, "Valve.VR.InteractionSystem", "CircularDrive");
// Type namespace: Valve.VR.InteractionSystem
namespace Valve::VR::InteractionSystem {
  // Size: 0x128
  #pragma pack(push, 1)
  // Autogenerated type: Valve.VR.InteractionSystem.CircularDrive
  // [TokenAttribute] Offset: FFFFFFFF
  // [RequireComponent] Offset: AD0678
  class CircularDrive : public ::UnityEngine::MonoBehaviour {
    public:
    // Nested type: ::Valve::VR::InteractionSystem::CircularDrive::Axis_t
    struct Axis_t;
    // Nested type: ::Valve::VR::InteractionSystem::CircularDrive::$HapticPulses$d__43
    class $HapticPulses$d__43;
    // Size: 0x4
    #pragma pack(push, 1)
    // Autogenerated type: Valve.VR.InteractionSystem.CircularDrive/Axis_t
    // [TokenAttribute] Offset: FFFFFFFF
    struct Axis_t/*, public ::System::Enum*/ {
      public:
      public:
      // public System.Int32 value__
      // Size: 0x4
      // Offset: 0x0
      int value;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      public:
      // Creating value type constructor for type: Axis_t
      constexpr Axis_t(int value_ = {}) noexcept : value{value_} {}
      // Creating interface conversion operator: operator ::System::Enum
      operator ::System::Enum() noexcept {
        return *reinterpret_cast<::System::Enum*>(this);
      }
      // Creating conversion operator: operator int
      constexpr operator int() const noexcept {
        return value;
      }
      // static field const value: static public Valve.VR.InteractionSystem.CircularDrive/Axis_t XAxis
      static constexpr const int XAxis = 0;
      // Get static field: static public Valve.VR.InteractionSystem.CircularDrive/Axis_t XAxis
      static ::Valve::VR::InteractionSystem::CircularDrive::Axis_t _get_XAxis();
      // Set static field: static public Valve.VR.InteractionSystem.CircularDrive/Axis_t XAxis
      static void _set_XAxis(::Valve::VR::InteractionSystem::CircularDrive::Axis_t value);
      // static field const value: static public Valve.VR.InteractionSystem.CircularDrive/Axis_t YAxis
      static constexpr const int YAxis = 1;
      // Get static field: static public Valve.VR.InteractionSystem.CircularDrive/Axis_t YAxis
      static ::Valve::VR::InteractionSystem::CircularDrive::Axis_t _get_YAxis();
      // Set static field: static public Valve.VR.InteractionSystem.CircularDrive/Axis_t YAxis
      static void _set_YAxis(::Valve::VR::InteractionSystem::CircularDrive::Axis_t value);
      // static field const value: static public Valve.VR.InteractionSystem.CircularDrive/Axis_t ZAxis
      static constexpr const int ZAxis = 2;
      // Get static field: static public Valve.VR.InteractionSystem.CircularDrive/Axis_t ZAxis
      static ::Valve::VR::InteractionSystem::CircularDrive::Axis_t _get_ZAxis();
      // Set static field: static public Valve.VR.InteractionSystem.CircularDrive/Axis_t ZAxis
      static void _set_ZAxis(::Valve::VR::InteractionSystem::CircularDrive::Axis_t value);
      // Get instance field reference: public System.Int32 value__
      [[deprecated("Use field access instead!")]] int& dyn_value__();
    }; // Valve.VR.InteractionSystem.CircularDrive/Axis_t
    #pragma pack(pop)
    static check_size<sizeof(CircularDrive::Axis_t), 0 + sizeof(int)> __Valve_VR_InteractionSystem_CircularDrive_Axis_tSizeCheck;
    static_assert(sizeof(CircularDrive::Axis_t) == 0x4);
    public:
    // [TooltipAttribute] Offset: 0xADD838
    // public Valve.VR.InteractionSystem.CircularDrive/Axis_t axisOfRotation
    // Size: 0x4
    // Offset: 0x18
    ::Valve::VR::InteractionSystem::CircularDrive::Axis_t axisOfRotation;
    // Field size check
    static_assert(sizeof(::Valve::VR::InteractionSystem::CircularDrive::Axis_t) == 0x4);
    // Padding between fields: axisOfRotation and: childCollider
    char __padding0[0x4] = {};
    // [TooltipAttribute] Offset: 0xADD870
    // public UnityEngine.Collider childCollider
    // Size: 0x8
    // Offset: 0x20
    ::UnityEngine::Collider* childCollider;
    // Field size check
    static_assert(sizeof(::UnityEngine::Collider*) == 0x8);
    // [TooltipAttribute] Offset: 0xADD8A8
    // public Valve.VR.InteractionSystem.LinearMapping linearMapping
    // Size: 0x8
    // Offset: 0x28
    ::Valve::VR::InteractionSystem::LinearMapping* linearMapping;
    // Field size check
    static_assert(sizeof(::Valve::VR::InteractionSystem::LinearMapping*) == 0x8);
    // [TooltipAttribute] Offset: 0xADD8E0
    // public System.Boolean hoverLock
    // Size: 0x1
    // Offset: 0x30
    bool hoverLock;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // [HeaderAttribute] Offset: 0xADD918
    // [TooltipAttribute] Offset: 0xADD918
    // public System.Boolean limited
    // Size: 0x1
    // Offset: 0x31
    bool limited;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: limited and: frozenDistanceMinMaxThreshold
    char __padding4[0x2] = {};
    // public UnityEngine.Vector2 frozenDistanceMinMaxThreshold
    // Size: 0x8
    // Offset: 0x34
    ::UnityEngine::Vector2 frozenDistanceMinMaxThreshold;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector2) == 0x8);
    // Padding between fields: frozenDistanceMinMaxThreshold and: onFrozenDistanceThreshold
    char __padding5[0x4] = {};
    // public UnityEngine.Events.UnityEvent onFrozenDistanceThreshold
    // Size: 0x8
    // Offset: 0x40
    ::UnityEngine::Events::UnityEvent* onFrozenDistanceThreshold;
    // Field size check
    static_assert(sizeof(::UnityEngine::Events::UnityEvent*) == 0x8);
    // [TooltipAttribute] Offset: 0xADD978
    // [HeaderAttribute] Offset: 0xADD978
    // public System.Single minAngle
    // Size: 0x4
    // Offset: 0x48
    float minAngle;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // [TooltipAttribute] Offset: 0xADD9D8
    // public System.Boolean freezeOnMin
    // Size: 0x1
    // Offset: 0x4C
    bool freezeOnMin;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: freezeOnMin and: onMinAngle
    char __padding8[0x3] = {};
    // [TooltipAttribute] Offset: 0xADDA10
    // public UnityEngine.Events.UnityEvent onMinAngle
    // Size: 0x8
    // Offset: 0x50
    ::UnityEngine::Events::UnityEvent* onMinAngle;
    // Field size check
    static_assert(sizeof(::UnityEngine::Events::UnityEvent*) == 0x8);
    // [TooltipAttribute] Offset: 0xADDA48
    // [HeaderAttribute] Offset: 0xADDA48
    // public System.Single maxAngle
    // Size: 0x4
    // Offset: 0x58
    float maxAngle;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // [TooltipAttribute] Offset: 0xADDAA8
    // public System.Boolean freezeOnMax
    // Size: 0x1
    // Offset: 0x5C
    bool freezeOnMax;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: freezeOnMax and: onMaxAngle
    char __padding11[0x3] = {};
    // [TooltipAttribute] Offset: 0xADDAE0
    // public UnityEngine.Events.UnityEvent onMaxAngle
    // Size: 0x8
    // Offset: 0x60
    ::UnityEngine::Events::UnityEvent* onMaxAngle;
    // Field size check
    static_assert(sizeof(::UnityEngine::Events::UnityEvent*) == 0x8);
    // [TooltipAttribute] Offset: 0xADDB18
    // public System.Boolean forceStart
    // Size: 0x1
    // Offset: 0x68
    bool forceStart;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: forceStart and: startAngle
    char __padding13[0x3] = {};
    // [TooltipAttribute] Offset: 0xADDB50
    // public System.Single startAngle
    // Size: 0x4
    // Offset: 0x6C
    float startAngle;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // [TooltipAttribute] Offset: 0xADDB88
    // public System.Boolean rotateGameObject
    // Size: 0x1
    // Offset: 0x70
    bool rotateGameObject;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // [TooltipAttribute] Offset: 0xADDBC0
    // public System.Boolean debugPath
    // Size: 0x1
    // Offset: 0x71
    bool debugPath;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: debugPath and: dbgPathLimit
    char __padding16[0x2] = {};
    // [TooltipAttribute] Offset: 0xADDBF8
    // public System.Int32 dbgPathLimit
    // Size: 0x4
    // Offset: 0x74
    int dbgPathLimit;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // [TooltipAttribute] Offset: 0xADDC30
    // public UnityEngine.TextMesh debugText
    // Size: 0x8
    // Offset: 0x78
    ::UnityEngine::TextMesh* debugText;
    // Field size check
    static_assert(sizeof(::UnityEngine::TextMesh*) == 0x8);
    // [TooltipAttribute] Offset: 0xADDC68
    // public System.Single outAngle
    // Size: 0x4
    // Offset: 0x80
    float outAngle;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private UnityEngine.Quaternion start
    // Size: 0x10
    // Offset: 0x84
    ::UnityEngine::Quaternion start;
    // Field size check
    static_assert(sizeof(::UnityEngine::Quaternion) == 0x10);
    // private UnityEngine.Vector3 worldPlaneNormal
    // Size: 0xC
    // Offset: 0x94
    ::UnityEngine::Vector3 worldPlaneNormal;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private UnityEngine.Vector3 localPlaneNormal
    // Size: 0xC
    // Offset: 0xA0
    ::UnityEngine::Vector3 localPlaneNormal;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private UnityEngine.Vector3 lastHandProjected
    // Size: 0xC
    // Offset: 0xAC
    ::UnityEngine::Vector3 lastHandProjected;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private UnityEngine.Color red
    // Size: 0x10
    // Offset: 0xB8
    ::UnityEngine::Color red;
    // Field size check
    static_assert(sizeof(::UnityEngine::Color) == 0x10);
    // private UnityEngine.Color green
    // Size: 0x10
    // Offset: 0xC8
    ::UnityEngine::Color green;
    // Field size check
    static_assert(sizeof(::UnityEngine::Color) == 0x10);
    // private UnityEngine.GameObject[] dbgHandObjects
    // Size: 0x8
    // Offset: 0xD8
    ::ArrayW<::UnityEngine::GameObject*> dbgHandObjects;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::GameObject*>) == 0x8);
    // private UnityEngine.GameObject[] dbgProjObjects
    // Size: 0x8
    // Offset: 0xE0
    ::ArrayW<::UnityEngine::GameObject*> dbgProjObjects;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::GameObject*>) == 0x8);
    // private UnityEngine.GameObject dbgObjectsParent
    // Size: 0x8
    // Offset: 0xE8
    ::UnityEngine::GameObject* dbgObjectsParent;
    // Field size check
    static_assert(sizeof(::UnityEngine::GameObject*) == 0x8);
    // private System.Int32 dbgObjectCount
    // Size: 0x4
    // Offset: 0xF0
    int dbgObjectCount;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 dbgObjectIndex
    // Size: 0x4
    // Offset: 0xF4
    int dbgObjectIndex;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Boolean driving
    // Size: 0x1
    // Offset: 0xF8
    bool driving;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: driving and: minMaxAngularThreshold
    char __padding31[0x3] = {};
    // private System.Single minMaxAngularThreshold
    // Size: 0x4
    // Offset: 0xFC
    float minMaxAngularThreshold;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Boolean frozen
    // Size: 0x1
    // Offset: 0x100
    bool frozen;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: frozen and: frozenAngle
    char __padding33[0x3] = {};
    // private System.Single frozenAngle
    // Size: 0x4
    // Offset: 0x104
    float frozenAngle;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private UnityEngine.Vector3 frozenHandWorldPos
    // Size: 0xC
    // Offset: 0x108
    ::UnityEngine::Vector3 frozenHandWorldPos;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private UnityEngine.Vector2 frozenSqDistanceMinMaxThreshold
    // Size: 0x8
    // Offset: 0x114
    ::UnityEngine::Vector2 frozenSqDistanceMinMaxThreshold;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector2) == 0x8);
    // Padding between fields: frozenSqDistanceMinMaxThreshold and: handHoverLocked
    char __padding36[0x4] = {};
    // private Valve.VR.InteractionSystem.Hand handHoverLocked
    // Size: 0x8
    // Offset: 0x120
    ::Valve::VR::InteractionSystem::Hand* handHoverLocked;
    // Field size check
    static_assert(sizeof(::Valve::VR::InteractionSystem::Hand*) == 0x8);
    public:
    // Deleting conversion operator: operator ::System::IntPtr
    constexpr operator ::System::IntPtr() const noexcept = delete;
    // Get instance field reference: public Valve.VR.InteractionSystem.CircularDrive/Axis_t axisOfRotation
    [[deprecated("Use field access instead!")]] ::Valve::VR::InteractionSystem::CircularDrive::Axis_t& dyn_axisOfRotation();
    // Get instance field reference: public UnityEngine.Collider childCollider
    [[deprecated("Use field access instead!")]] ::UnityEngine::Collider*& dyn_childCollider();
    // Get instance field reference: public Valve.VR.InteractionSystem.LinearMapping linearMapping
    [[deprecated("Use field access instead!")]] ::Valve::VR::InteractionSystem::LinearMapping*& dyn_linearMapping();
    // Get instance field reference: public System.Boolean hoverLock
    [[deprecated("Use field access instead!")]] bool& dyn_hoverLock();
    // Get instance field reference: public System.Boolean limited
    [[deprecated("Use field access instead!")]] bool& dyn_limited();
    // Get instance field reference: public UnityEngine.Vector2 frozenDistanceMinMaxThreshold
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector2& dyn_frozenDistanceMinMaxThreshold();
    // Get instance field reference: public UnityEngine.Events.UnityEvent onFrozenDistanceThreshold
    [[deprecated("Use field access instead!")]] ::UnityEngine::Events::UnityEvent*& dyn_onFrozenDistanceThreshold();
    // Get instance field reference: public System.Single minAngle
    [[deprecated("Use field access instead!")]] float& dyn_minAngle();
    // Get instance field reference: public System.Boolean freezeOnMin
    [[deprecated("Use field access instead!")]] bool& dyn_freezeOnMin();
    // Get instance field reference: public UnityEngine.Events.UnityEvent onMinAngle
    [[deprecated("Use field access instead!")]] ::UnityEngine::Events::UnityEvent*& dyn_onMinAngle();
    // Get instance field reference: public System.Single maxAngle
    [[deprecated("Use field access instead!")]] float& dyn_maxAngle();
    // Get instance field reference: public System.Boolean freezeOnMax
    [[deprecated("Use field access instead!")]] bool& dyn_freezeOnMax();
    // Get instance field reference: public UnityEngine.Events.UnityEvent onMaxAngle
    [[deprecated("Use field access instead!")]] ::UnityEngine::Events::UnityEvent*& dyn_onMaxAngle();
    // Get instance field reference: public System.Boolean forceStart
    [[deprecated("Use field access instead!")]] bool& dyn_forceStart();
    // Get instance field reference: public System.Single startAngle
    [[deprecated("Use field access instead!")]] float& dyn_startAngle();
    // Get instance field reference: public System.Boolean rotateGameObject
    [[deprecated("Use field access instead!")]] bool& dyn_rotateGameObject();
    // Get instance field reference: public System.Boolean debugPath
    [[deprecated("Use field access instead!")]] bool& dyn_debugPath();
    // Get instance field reference: public System.Int32 dbgPathLimit
    [[deprecated("Use field access instead!")]] int& dyn_dbgPathLimit();
    // Get instance field reference: public UnityEngine.TextMesh debugText
    [[deprecated("Use field access instead!")]] ::UnityEngine::TextMesh*& dyn_debugText();
    // Get instance field reference: public System.Single outAngle
    [[deprecated("Use field access instead!")]] float& dyn_outAngle();
    // Get instance field reference: private UnityEngine.Quaternion start
    [[deprecated("Use field access instead!")]] ::UnityEngine::Quaternion& dyn_start();
    // Get instance field reference: private UnityEngine.Vector3 worldPlaneNormal
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_worldPlaneNormal();
    // Get instance field reference: private UnityEngine.Vector3 localPlaneNormal
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_localPlaneNormal();
    // Get instance field reference: private UnityEngine.Vector3 lastHandProjected
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_lastHandProjected();
    // Get instance field reference: private UnityEngine.Color red
    [[deprecated("Use field access instead!")]] ::UnityEngine::Color& dyn_red();
    // Get instance field reference: private UnityEngine.Color green
    [[deprecated("Use field access instead!")]] ::UnityEngine::Color& dyn_green();
    // Get instance field reference: private UnityEngine.GameObject[] dbgHandObjects
    [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::GameObject*>& dyn_dbgHandObjects();
    // Get instance field reference: private UnityEngine.GameObject[] dbgProjObjects
    [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::GameObject*>& dyn_dbgProjObjects();
    // Get instance field reference: private UnityEngine.GameObject dbgObjectsParent
    [[deprecated("Use field access instead!")]] ::UnityEngine::GameObject*& dyn_dbgObjectsParent();
    // Get instance field reference: private System.Int32 dbgObjectCount
    [[deprecated("Use field access instead!")]] int& dyn_dbgObjectCount();
    // Get instance field reference: private System.Int32 dbgObjectIndex
    [[deprecated("Use field access instead!")]] int& dyn_dbgObjectIndex();
    // Get instance field reference: private System.Boolean driving
    [[deprecated("Use field access instead!")]] bool& dyn_driving();
    // Get instance field reference: private System.Single minMaxAngularThreshold
    [[deprecated("Use field access instead!")]] float& dyn_minMaxAngularThreshold();
    // Get instance field reference: private System.Boolean frozen
    [[deprecated("Use field access instead!")]] bool& dyn_frozen();
    // Get instance field reference: private System.Single frozenAngle
    [[deprecated("Use field access instead!")]] float& dyn_frozenAngle();
    // Get instance field reference: private UnityEngine.Vector3 frozenHandWorldPos
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_frozenHandWorldPos();
    // Get instance field reference: private UnityEngine.Vector2 frozenSqDistanceMinMaxThreshold
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector2& dyn_frozenSqDistanceMinMaxThreshold();
    // Get instance field reference: private Valve.VR.InteractionSystem.Hand handHoverLocked
    [[deprecated("Use field access instead!")]] ::Valve::VR::InteractionSystem::Hand*& dyn_handHoverLocked();
    // private System.Void Freeze(Valve.VR.InteractionSystem.Hand hand)
    // Offset: 0x115BAE0
    void Freeze(::Valve::VR::InteractionSystem::Hand* hand);
    // private System.Void UnFreeze()
    // Offset: 0x115BB58
    void UnFreeze();
    // private System.Void Start()
    // Offset: 0x115BB78
    void Start();
    // private System.Void OnDisable()
    // Offset: 0x115C00C
    void OnDisable();
    // private System.Collections.IEnumerator HapticPulses(SteamVR_Controller/Device controller, System.Single flMagnitude, System.Int32 nCount)
    // Offset: 0x115C1C4
    ::System::Collections::IEnumerator* HapticPulses(::GlobalNamespace::SteamVR_Controller::Device* controller, float flMagnitude, int nCount);
    // private System.Void OnHandHoverBegin(Valve.VR.InteractionSystem.Hand hand)
    // Offset: 0x115C2A8
    void OnHandHoverBegin(::Valve::VR::InteractionSystem::Hand* hand);
    // private System.Void OnHandHoverEnd(Valve.VR.InteractionSystem.Hand hand)
    // Offset: 0x115C3E4
    void OnHandHoverEnd(::Valve::VR::InteractionSystem::Hand* hand);
    // private System.Void HandHoverUpdate(Valve.VR.InteractionSystem.Hand hand)
    // Offset: 0x115C570
    void HandHoverUpdate(::Valve::VR::InteractionSystem::Hand* hand);
    // private UnityEngine.Vector3 ComputeToTransformProjected(UnityEngine.Transform xForm)
    // Offset: 0x115C82C
    ::UnityEngine::Vector3 ComputeToTransformProjected(::UnityEngine::Transform* xForm);
    // private System.Void DrawDebugPath(UnityEngine.Transform xForm, UnityEngine.Vector3 toTransformProjected)
    // Offset: 0x115CF98
    void DrawDebugPath(::UnityEngine::Transform* xForm, ::UnityEngine::Vector3 toTransformProjected);
    // private System.Void UpdateLinearMapping()
    // Offset: 0x115D8C0
    void UpdateLinearMapping();
    // private System.Void UpdateGameObject()
    // Offset: 0x115DAA0
    void UpdateGameObject();
    // private System.Void UpdateDebugText()
    // Offset: 0x115D994
    void UpdateDebugText();
    // private System.Void UpdateAll()
    // Offset: 0x115BFE0
    void UpdateAll();
    // private System.Void ComputeAngle(Valve.VR.InteractionSystem.Hand hand)
    // Offset: 0x115CAF0
    void ComputeAngle(::Valve::VR::InteractionSystem::Hand* hand);
    // public System.Void .ctor()
    // Offset: 0x115DBE0
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static CircularDrive* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::Valve::VR::InteractionSystem::CircularDrive::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<CircularDrive*, creationType>()));
    }
  }; // Valve.VR.InteractionSystem.CircularDrive
  #pragma pack(pop)
  static check_size<sizeof(CircularDrive), 288 + sizeof(::Valve::VR::InteractionSystem::Hand*)> __Valve_VR_InteractionSystem_CircularDriveSizeCheck;
  static_assert(sizeof(CircularDrive) == 0x128);
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::Valve::VR::InteractionSystem::CircularDrive::Axis_t, "Valve.VR.InteractionSystem", "CircularDrive/Axis_t");
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::CircularDrive::Freeze
// Il2CppName: Freeze
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::CircularDrive::*)(::Valve::VR::InteractionSystem::Hand*)>(&Valve::VR::InteractionSystem::CircularDrive::Freeze)> {
  static const MethodInfo* get() {
    static auto* hand = &::il2cpp_utils::GetClassFromName("Valve.VR.InteractionSystem", "Hand")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::CircularDrive*), "Freeze", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{hand});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::CircularDrive::UnFreeze
// Il2CppName: UnFreeze
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::CircularDrive::*)()>(&Valve::VR::InteractionSystem::CircularDrive::UnFreeze)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::CircularDrive*), "UnFreeze", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::CircularDrive::Start
// Il2CppName: Start
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::CircularDrive::*)()>(&Valve::VR::InteractionSystem::CircularDrive::Start)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::CircularDrive*), "Start", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::CircularDrive::OnDisable
// Il2CppName: OnDisable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::CircularDrive::*)()>(&Valve::VR::InteractionSystem::CircularDrive::OnDisable)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::CircularDrive*), "OnDisable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::CircularDrive::HapticPulses
// Il2CppName: HapticPulses
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Collections::IEnumerator* (Valve::VR::InteractionSystem::CircularDrive::*)(::GlobalNamespace::SteamVR_Controller::Device*, float, int)>(&Valve::VR::InteractionSystem::CircularDrive::HapticPulses)> {
  static const MethodInfo* get() {
    static auto* controller = &::il2cpp_utils::GetClassFromName("", "SteamVR_Controller/Device")->byval_arg;
    static auto* flMagnitude = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* nCount = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::CircularDrive*), "HapticPulses", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{controller, flMagnitude, nCount});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::CircularDrive::OnHandHoverBegin
// Il2CppName: OnHandHoverBegin
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::CircularDrive::*)(::Valve::VR::InteractionSystem::Hand*)>(&Valve::VR::InteractionSystem::CircularDrive::OnHandHoverBegin)> {
  static const MethodInfo* get() {
    static auto* hand = &::il2cpp_utils::GetClassFromName("Valve.VR.InteractionSystem", "Hand")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::CircularDrive*), "OnHandHoverBegin", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{hand});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::CircularDrive::OnHandHoverEnd
// Il2CppName: OnHandHoverEnd
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::CircularDrive::*)(::Valve::VR::InteractionSystem::Hand*)>(&Valve::VR::InteractionSystem::CircularDrive::OnHandHoverEnd)> {
  static const MethodInfo* get() {
    static auto* hand = &::il2cpp_utils::GetClassFromName("Valve.VR.InteractionSystem", "Hand")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::CircularDrive*), "OnHandHoverEnd", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{hand});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::CircularDrive::HandHoverUpdate
// Il2CppName: HandHoverUpdate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::CircularDrive::*)(::Valve::VR::InteractionSystem::Hand*)>(&Valve::VR::InteractionSystem::CircularDrive::HandHoverUpdate)> {
  static const MethodInfo* get() {
    static auto* hand = &::il2cpp_utils::GetClassFromName("Valve.VR.InteractionSystem", "Hand")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::CircularDrive*), "HandHoverUpdate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{hand});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::CircularDrive::ComputeToTransformProjected
// Il2CppName: ComputeToTransformProjected
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Vector3 (Valve::VR::InteractionSystem::CircularDrive::*)(::UnityEngine::Transform*)>(&Valve::VR::InteractionSystem::CircularDrive::ComputeToTransformProjected)> {
  static const MethodInfo* get() {
    static auto* xForm = &::il2cpp_utils::GetClassFromName("UnityEngine", "Transform")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::CircularDrive*), "ComputeToTransformProjected", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{xForm});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::CircularDrive::DrawDebugPath
// Il2CppName: DrawDebugPath
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::CircularDrive::*)(::UnityEngine::Transform*, ::UnityEngine::Vector3)>(&Valve::VR::InteractionSystem::CircularDrive::DrawDebugPath)> {
  static const MethodInfo* get() {
    static auto* xForm = &::il2cpp_utils::GetClassFromName("UnityEngine", "Transform")->byval_arg;
    static auto* toTransformProjected = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::CircularDrive*), "DrawDebugPath", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{xForm, toTransformProjected});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::CircularDrive::UpdateLinearMapping
// Il2CppName: UpdateLinearMapping
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::CircularDrive::*)()>(&Valve::VR::InteractionSystem::CircularDrive::UpdateLinearMapping)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::CircularDrive*), "UpdateLinearMapping", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::CircularDrive::UpdateGameObject
// Il2CppName: UpdateGameObject
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::CircularDrive::*)()>(&Valve::VR::InteractionSystem::CircularDrive::UpdateGameObject)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::CircularDrive*), "UpdateGameObject", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::CircularDrive::UpdateDebugText
// Il2CppName: UpdateDebugText
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::CircularDrive::*)()>(&Valve::VR::InteractionSystem::CircularDrive::UpdateDebugText)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::CircularDrive*), "UpdateDebugText", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::CircularDrive::UpdateAll
// Il2CppName: UpdateAll
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::CircularDrive::*)()>(&Valve::VR::InteractionSystem::CircularDrive::UpdateAll)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::CircularDrive*), "UpdateAll", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::CircularDrive::ComputeAngle
// Il2CppName: ComputeAngle
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::CircularDrive::*)(::Valve::VR::InteractionSystem::Hand*)>(&Valve::VR::InteractionSystem::CircularDrive::ComputeAngle)> {
  static const MethodInfo* get() {
    static auto* hand = &::il2cpp_utils::GetClassFromName("Valve.VR.InteractionSystem", "Hand")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::CircularDrive*), "ComputeAngle", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{hand});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::CircularDrive::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
