// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: UnityEngine.MonoBehaviour
#include "UnityEngine/MonoBehaviour.hpp"
// Including type: SteamVR_Events
#include "GlobalNamespace/SteamVR_Events.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
// Completed includes
// Begin forward declares
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: Transform
  class Transform;
  // Forward declaring type: GameObject
  class GameObject;
}
// Forward declaring namespace: Valve::VR::InteractionSystem
namespace Valve::VR::InteractionSystem {
  // Forward declaring type: Hand
  class Hand;
  // Forward declaring type: ArrowHand
  class ArrowHand;
  // Forward declaring type: ItemPackage
  class ItemPackage;
  // Forward declaring type: LinearMapping
  class LinearMapping;
  // Forward declaring type: SoundBowClick
  class SoundBowClick;
  // Forward declaring type: SoundPlayOneshot
  class SoundPlayOneshot;
}
// Forward declaring namespace: System::Collections
namespace System::Collections {
  // Forward declaring type: IEnumerator
  class IEnumerator;
}
// Completed forward declares
// Type namespace: Valve.VR.InteractionSystem
namespace Valve::VR::InteractionSystem {
  // Forward declaring type: Longbow
  class Longbow;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::Valve::VR::InteractionSystem::Longbow);
DEFINE_IL2CPP_ARG_TYPE(::Valve::VR::InteractionSystem::Longbow*, "Valve.VR.InteractionSystem", "Longbow");
// Type namespace: Valve.VR.InteractionSystem
namespace Valve::VR::InteractionSystem {
  // Size: 0x130
  #pragma pack(push, 1)
  // Autogenerated type: Valve.VR.InteractionSystem.Longbow
  // [TokenAttribute] Offset: FFFFFFFF
  // [RequireComponent] Offset: AD0CEC
  class Longbow : public ::UnityEngine::MonoBehaviour {
    public:
    // Nested type: ::Valve::VR::InteractionSystem::Longbow::Handedness
    struct Handedness;
    // Nested type: ::Valve::VR::InteractionSystem::Longbow::$ResetDrawAnim$d__55
    class $ResetDrawAnim$d__55;
    // Size: 0x4
    #pragma pack(push, 1)
    // Autogenerated type: Valve.VR.InteractionSystem.Longbow/Handedness
    // [TokenAttribute] Offset: FFFFFFFF
    struct Handedness/*, public ::System::Enum*/ {
      public:
      public:
      // public System.Int32 value__
      // Size: 0x4
      // Offset: 0x0
      int value;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      public:
      // Creating value type constructor for type: Handedness
      constexpr Handedness(int value_ = {}) noexcept : value{value_} {}
      // Creating interface conversion operator: operator ::System::Enum
      operator ::System::Enum() noexcept {
        return *reinterpret_cast<::System::Enum*>(this);
      }
      // Creating conversion operator: operator int
      constexpr operator int() const noexcept {
        return value;
      }
      // static field const value: static public Valve.VR.InteractionSystem.Longbow/Handedness Left
      static constexpr const int Left = 0;
      // Get static field: static public Valve.VR.InteractionSystem.Longbow/Handedness Left
      static ::Valve::VR::InteractionSystem::Longbow::Handedness _get_Left();
      // Set static field: static public Valve.VR.InteractionSystem.Longbow/Handedness Left
      static void _set_Left(::Valve::VR::InteractionSystem::Longbow::Handedness value);
      // static field const value: static public Valve.VR.InteractionSystem.Longbow/Handedness Right
      static constexpr const int Right = 1;
      // Get static field: static public Valve.VR.InteractionSystem.Longbow/Handedness Right
      static ::Valve::VR::InteractionSystem::Longbow::Handedness _get_Right();
      // Set static field: static public Valve.VR.InteractionSystem.Longbow/Handedness Right
      static void _set_Right(::Valve::VR::InteractionSystem::Longbow::Handedness value);
      // Get instance field reference: public System.Int32 value__
      [[deprecated("Use field access instead!")]] int& dyn_value__();
    }; // Valve.VR.InteractionSystem.Longbow/Handedness
    #pragma pack(pop)
    static check_size<sizeof(Longbow::Handedness), 0 + sizeof(int)> __Valve_VR_InteractionSystem_Longbow_HandednessSizeCheck;
    static_assert(sizeof(Longbow::Handedness) == 0x4);
    public:
    // public Valve.VR.InteractionSystem.Longbow/Handedness currentHandGuess
    // Size: 0x4
    // Offset: 0x18
    ::Valve::VR::InteractionSystem::Longbow::Handedness currentHandGuess;
    // Field size check
    static_assert(sizeof(::Valve::VR::InteractionSystem::Longbow::Handedness) == 0x4);
    // private System.Single timeOfPossibleHandSwitch
    // Size: 0x4
    // Offset: 0x1C
    float timeOfPossibleHandSwitch;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single timeBeforeConfirmingHandSwitch
    // Size: 0x4
    // Offset: 0x20
    float timeBeforeConfirmingHandSwitch;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Boolean possibleHandSwitch
    // Size: 0x1
    // Offset: 0x24
    bool possibleHandSwitch;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: possibleHandSwitch and: pivotTransform
    char __padding3[0x3] = {};
    // public UnityEngine.Transform pivotTransform
    // Size: 0x8
    // Offset: 0x28
    ::UnityEngine::Transform* pivotTransform;
    // Field size check
    static_assert(sizeof(::UnityEngine::Transform*) == 0x8);
    // public UnityEngine.Transform handleTransform
    // Size: 0x8
    // Offset: 0x30
    ::UnityEngine::Transform* handleTransform;
    // Field size check
    static_assert(sizeof(::UnityEngine::Transform*) == 0x8);
    // private Valve.VR.InteractionSystem.Hand hand
    // Size: 0x8
    // Offset: 0x38
    ::Valve::VR::InteractionSystem::Hand* hand;
    // Field size check
    static_assert(sizeof(::Valve::VR::InteractionSystem::Hand*) == 0x8);
    // private Valve.VR.InteractionSystem.ArrowHand arrowHand
    // Size: 0x8
    // Offset: 0x40
    ::Valve::VR::InteractionSystem::ArrowHand* arrowHand;
    // Field size check
    static_assert(sizeof(::Valve::VR::InteractionSystem::ArrowHand*) == 0x8);
    // public UnityEngine.Transform nockTransform
    // Size: 0x8
    // Offset: 0x48
    ::UnityEngine::Transform* nockTransform;
    // Field size check
    static_assert(sizeof(::UnityEngine::Transform*) == 0x8);
    // public UnityEngine.Transform nockRestTransform
    // Size: 0x8
    // Offset: 0x50
    ::UnityEngine::Transform* nockRestTransform;
    // Field size check
    static_assert(sizeof(::UnityEngine::Transform*) == 0x8);
    // public System.Boolean autoSpawnArrowHand
    // Size: 0x1
    // Offset: 0x58
    bool autoSpawnArrowHand;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: autoSpawnArrowHand and: arrowHandItemPackage
    char __padding10[0x7] = {};
    // public Valve.VR.InteractionSystem.ItemPackage arrowHandItemPackage
    // Size: 0x8
    // Offset: 0x60
    ::Valve::VR::InteractionSystem::ItemPackage* arrowHandItemPackage;
    // Field size check
    static_assert(sizeof(::Valve::VR::InteractionSystem::ItemPackage*) == 0x8);
    // public UnityEngine.GameObject arrowHandPrefab
    // Size: 0x8
    // Offset: 0x68
    ::UnityEngine::GameObject* arrowHandPrefab;
    // Field size check
    static_assert(sizeof(::UnityEngine::GameObject*) == 0x8);
    // public System.Boolean nocked
    // Size: 0x1
    // Offset: 0x70
    bool nocked;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Boolean pulled
    // Size: 0x1
    // Offset: 0x71
    bool pulled;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: pulled and: nockDistanceTravelled
    char __padding14[0x2] = {};
    // private System.Single nockDistanceTravelled
    // Size: 0x4
    // Offset: 0x74
    float nockDistanceTravelled;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single hapticDistanceThreshold
    // Size: 0x4
    // Offset: 0x78
    float hapticDistanceThreshold;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single lastTickDistance
    // Size: 0x4
    // Offset: 0x7C
    float lastTickDistance;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private UnityEngine.Vector3 bowLeftVector
    // Size: 0xC
    // Offset: 0x80
    ::UnityEngine::Vector3 bowLeftVector;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // public System.Single arrowMinVelocity
    // Size: 0x4
    // Offset: 0x8C
    float arrowMinVelocity;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single arrowMaxVelocity
    // Size: 0x4
    // Offset: 0x90
    float arrowMaxVelocity;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single arrowVelocity
    // Size: 0x4
    // Offset: 0x94
    float arrowVelocity;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single minStrainTickTime
    // Size: 0x4
    // Offset: 0x98
    float minStrainTickTime;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single maxStrainTickTime
    // Size: 0x4
    // Offset: 0x9C
    float maxStrainTickTime;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single nextStrainTick
    // Size: 0x4
    // Offset: 0xA0
    float nextStrainTick;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Boolean lerpBackToZeroRotation
    // Size: 0x1
    // Offset: 0xA4
    bool lerpBackToZeroRotation;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: lerpBackToZeroRotation and: lerpStartTime
    char __padding25[0x3] = {};
    // private System.Single lerpStartTime
    // Size: 0x4
    // Offset: 0xA8
    float lerpStartTime;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single lerpDuration
    // Size: 0x4
    // Offset: 0xAC
    float lerpDuration;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private UnityEngine.Quaternion lerpStartRotation
    // Size: 0x10
    // Offset: 0xB0
    ::UnityEngine::Quaternion lerpStartRotation;
    // Field size check
    static_assert(sizeof(::UnityEngine::Quaternion) == 0x10);
    // private System.Single nockLerpStartTime
    // Size: 0x4
    // Offset: 0xC0
    float nockLerpStartTime;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private UnityEngine.Quaternion nockLerpStartRotation
    // Size: 0x10
    // Offset: 0xC4
    ::UnityEngine::Quaternion nockLerpStartRotation;
    // Field size check
    static_assert(sizeof(::UnityEngine::Quaternion) == 0x10);
    // public System.Single drawOffset
    // Size: 0x4
    // Offset: 0xD4
    float drawOffset;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public Valve.VR.InteractionSystem.LinearMapping bowDrawLinearMapping
    // Size: 0x8
    // Offset: 0xD8
    ::Valve::VR::InteractionSystem::LinearMapping* bowDrawLinearMapping;
    // Field size check
    static_assert(sizeof(::Valve::VR::InteractionSystem::LinearMapping*) == 0x8);
    // private System.Boolean deferNewPoses
    // Size: 0x1
    // Offset: 0xE0
    bool deferNewPoses;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: deferNewPoses and: lateUpdatePos
    char __padding33[0x3] = {};
    // private UnityEngine.Vector3 lateUpdatePos
    // Size: 0xC
    // Offset: 0xE4
    ::UnityEngine::Vector3 lateUpdatePos;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private UnityEngine.Quaternion lateUpdateRot
    // Size: 0x10
    // Offset: 0xF0
    ::UnityEngine::Quaternion lateUpdateRot;
    // Field size check
    static_assert(sizeof(::UnityEngine::Quaternion) == 0x10);
    // public Valve.VR.InteractionSystem.SoundBowClick drawSound
    // Size: 0x8
    // Offset: 0x100
    ::Valve::VR::InteractionSystem::SoundBowClick* drawSound;
    // Field size check
    static_assert(sizeof(::Valve::VR::InteractionSystem::SoundBowClick*) == 0x8);
    // private System.Single drawTension
    // Size: 0x4
    // Offset: 0x108
    float drawTension;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // Padding between fields: drawTension and: arrowSlideSound
    char __padding37[0x4] = {};
    // public Valve.VR.InteractionSystem.SoundPlayOneshot arrowSlideSound
    // Size: 0x8
    // Offset: 0x110
    ::Valve::VR::InteractionSystem::SoundPlayOneshot* arrowSlideSound;
    // Field size check
    static_assert(sizeof(::Valve::VR::InteractionSystem::SoundPlayOneshot*) == 0x8);
    // public Valve.VR.InteractionSystem.SoundPlayOneshot releaseSound
    // Size: 0x8
    // Offset: 0x118
    ::Valve::VR::InteractionSystem::SoundPlayOneshot* releaseSound;
    // Field size check
    static_assert(sizeof(::Valve::VR::InteractionSystem::SoundPlayOneshot*) == 0x8);
    // public Valve.VR.InteractionSystem.SoundPlayOneshot nockSound
    // Size: 0x8
    // Offset: 0x120
    ::Valve::VR::InteractionSystem::SoundPlayOneshot* nockSound;
    // Field size check
    static_assert(sizeof(::Valve::VR::InteractionSystem::SoundPlayOneshot*) == 0x8);
    // private SteamVR_Events/Action newPosesAppliedAction
    // Size: 0x8
    // Offset: 0x128
    ::GlobalNamespace::SteamVR_Events::Action* newPosesAppliedAction;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::SteamVR_Events::Action*) == 0x8);
    public:
    // Deleting conversion operator: operator ::System::IntPtr
    constexpr operator ::System::IntPtr() const noexcept = delete;
    // static field const value: static private System.Single minPull
    static constexpr const float minPull = 0.05;
    // Get static field: static private System.Single minPull
    static float _get_minPull();
    // Set static field: static private System.Single minPull
    static void _set_minPull(float value);
    // static field const value: static private System.Single maxPull
    static constexpr const float maxPull = 0.5;
    // Get static field: static private System.Single maxPull
    static float _get_maxPull();
    // Set static field: static private System.Single maxPull
    static void _set_maxPull(float value);
    // static field const value: static private System.Single bowPullPulseStrengthLow
    static constexpr const float bowPullPulseStrengthLow = 100;
    // Get static field: static private System.Single bowPullPulseStrengthLow
    static float _get_bowPullPulseStrengthLow();
    // Set static field: static private System.Single bowPullPulseStrengthLow
    static void _set_bowPullPulseStrengthLow(float value);
    // static field const value: static private System.Single bowPullPulseStrengthHigh
    static constexpr const float bowPullPulseStrengthHigh = 500;
    // Get static field: static private System.Single bowPullPulseStrengthHigh
    static float _get_bowPullPulseStrengthHigh();
    // Set static field: static private System.Single bowPullPulseStrengthHigh
    static void _set_bowPullPulseStrengthHigh(float value);
    // Get instance field reference: public Valve.VR.InteractionSystem.Longbow/Handedness currentHandGuess
    [[deprecated("Use field access instead!")]] ::Valve::VR::InteractionSystem::Longbow::Handedness& dyn_currentHandGuess();
    // Get instance field reference: private System.Single timeOfPossibleHandSwitch
    [[deprecated("Use field access instead!")]] float& dyn_timeOfPossibleHandSwitch();
    // Get instance field reference: private System.Single timeBeforeConfirmingHandSwitch
    [[deprecated("Use field access instead!")]] float& dyn_timeBeforeConfirmingHandSwitch();
    // Get instance field reference: private System.Boolean possibleHandSwitch
    [[deprecated("Use field access instead!")]] bool& dyn_possibleHandSwitch();
    // Get instance field reference: public UnityEngine.Transform pivotTransform
    [[deprecated("Use field access instead!")]] ::UnityEngine::Transform*& dyn_pivotTransform();
    // Get instance field reference: public UnityEngine.Transform handleTransform
    [[deprecated("Use field access instead!")]] ::UnityEngine::Transform*& dyn_handleTransform();
    // Get instance field reference: private Valve.VR.InteractionSystem.Hand hand
    [[deprecated("Use field access instead!")]] ::Valve::VR::InteractionSystem::Hand*& dyn_hand();
    // Get instance field reference: private Valve.VR.InteractionSystem.ArrowHand arrowHand
    [[deprecated("Use field access instead!")]] ::Valve::VR::InteractionSystem::ArrowHand*& dyn_arrowHand();
    // Get instance field reference: public UnityEngine.Transform nockTransform
    [[deprecated("Use field access instead!")]] ::UnityEngine::Transform*& dyn_nockTransform();
    // Get instance field reference: public UnityEngine.Transform nockRestTransform
    [[deprecated("Use field access instead!")]] ::UnityEngine::Transform*& dyn_nockRestTransform();
    // Get instance field reference: public System.Boolean autoSpawnArrowHand
    [[deprecated("Use field access instead!")]] bool& dyn_autoSpawnArrowHand();
    // Get instance field reference: public Valve.VR.InteractionSystem.ItemPackage arrowHandItemPackage
    [[deprecated("Use field access instead!")]] ::Valve::VR::InteractionSystem::ItemPackage*& dyn_arrowHandItemPackage();
    // Get instance field reference: public UnityEngine.GameObject arrowHandPrefab
    [[deprecated("Use field access instead!")]] ::UnityEngine::GameObject*& dyn_arrowHandPrefab();
    // Get instance field reference: public System.Boolean nocked
    [[deprecated("Use field access instead!")]] bool& dyn_nocked();
    // Get instance field reference: public System.Boolean pulled
    [[deprecated("Use field access instead!")]] bool& dyn_pulled();
    // Get instance field reference: private System.Single nockDistanceTravelled
    [[deprecated("Use field access instead!")]] float& dyn_nockDistanceTravelled();
    // Get instance field reference: private System.Single hapticDistanceThreshold
    [[deprecated("Use field access instead!")]] float& dyn_hapticDistanceThreshold();
    // Get instance field reference: private System.Single lastTickDistance
    [[deprecated("Use field access instead!")]] float& dyn_lastTickDistance();
    // Get instance field reference: private UnityEngine.Vector3 bowLeftVector
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_bowLeftVector();
    // Get instance field reference: public System.Single arrowMinVelocity
    [[deprecated("Use field access instead!")]] float& dyn_arrowMinVelocity();
    // Get instance field reference: public System.Single arrowMaxVelocity
    [[deprecated("Use field access instead!")]] float& dyn_arrowMaxVelocity();
    // Get instance field reference: private System.Single arrowVelocity
    [[deprecated("Use field access instead!")]] float& dyn_arrowVelocity();
    // Get instance field reference: private System.Single minStrainTickTime
    [[deprecated("Use field access instead!")]] float& dyn_minStrainTickTime();
    // Get instance field reference: private System.Single maxStrainTickTime
    [[deprecated("Use field access instead!")]] float& dyn_maxStrainTickTime();
    // Get instance field reference: private System.Single nextStrainTick
    [[deprecated("Use field access instead!")]] float& dyn_nextStrainTick();
    // Get instance field reference: private System.Boolean lerpBackToZeroRotation
    [[deprecated("Use field access instead!")]] bool& dyn_lerpBackToZeroRotation();
    // Get instance field reference: private System.Single lerpStartTime
    [[deprecated("Use field access instead!")]] float& dyn_lerpStartTime();
    // Get instance field reference: private System.Single lerpDuration
    [[deprecated("Use field access instead!")]] float& dyn_lerpDuration();
    // Get instance field reference: private UnityEngine.Quaternion lerpStartRotation
    [[deprecated("Use field access instead!")]] ::UnityEngine::Quaternion& dyn_lerpStartRotation();
    // Get instance field reference: private System.Single nockLerpStartTime
    [[deprecated("Use field access instead!")]] float& dyn_nockLerpStartTime();
    // Get instance field reference: private UnityEngine.Quaternion nockLerpStartRotation
    [[deprecated("Use field access instead!")]] ::UnityEngine::Quaternion& dyn_nockLerpStartRotation();
    // Get instance field reference: public System.Single drawOffset
    [[deprecated("Use field access instead!")]] float& dyn_drawOffset();
    // Get instance field reference: public Valve.VR.InteractionSystem.LinearMapping bowDrawLinearMapping
    [[deprecated("Use field access instead!")]] ::Valve::VR::InteractionSystem::LinearMapping*& dyn_bowDrawLinearMapping();
    // Get instance field reference: private System.Boolean deferNewPoses
    [[deprecated("Use field access instead!")]] bool& dyn_deferNewPoses();
    // Get instance field reference: private UnityEngine.Vector3 lateUpdatePos
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_lateUpdatePos();
    // Get instance field reference: private UnityEngine.Quaternion lateUpdateRot
    [[deprecated("Use field access instead!")]] ::UnityEngine::Quaternion& dyn_lateUpdateRot();
    // Get instance field reference: public Valve.VR.InteractionSystem.SoundBowClick drawSound
    [[deprecated("Use field access instead!")]] ::Valve::VR::InteractionSystem::SoundBowClick*& dyn_drawSound();
    // Get instance field reference: private System.Single drawTension
    [[deprecated("Use field access instead!")]] float& dyn_drawTension();
    // Get instance field reference: public Valve.VR.InteractionSystem.SoundPlayOneshot arrowSlideSound
    [[deprecated("Use field access instead!")]] ::Valve::VR::InteractionSystem::SoundPlayOneshot*& dyn_arrowSlideSound();
    // Get instance field reference: public Valve.VR.InteractionSystem.SoundPlayOneshot releaseSound
    [[deprecated("Use field access instead!")]] ::Valve::VR::InteractionSystem::SoundPlayOneshot*& dyn_releaseSound();
    // Get instance field reference: public Valve.VR.InteractionSystem.SoundPlayOneshot nockSound
    [[deprecated("Use field access instead!")]] ::Valve::VR::InteractionSystem::SoundPlayOneshot*& dyn_nockSound();
    // Get instance field reference: private SteamVR_Events/Action newPosesAppliedAction
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::SteamVR_Events::Action*& dyn_newPosesAppliedAction();
    // private System.Void OnAttachedToHand(Valve.VR.InteractionSystem.Hand attachedHand)
    // Offset: 0xDBB06C
    void OnAttachedToHand(::Valve::VR::InteractionSystem::Hand* attachedHand);
    // private System.Void Awake()
    // Offset: 0xDBB074
    void Awake();
    // private System.Void OnEnable()
    // Offset: 0xDBB110
    void OnEnable();
    // private System.Void OnDisable()
    // Offset: 0xDBB144
    void OnDisable();
    // private System.Void LateUpdate()
    // Offset: 0xDBB178
    void LateUpdate();
    // private System.Void OnNewPosesApplied()
    // Offset: 0xDBB1F4
    void OnNewPosesApplied();
    // private System.Void HandAttachedUpdate(Valve.VR.InteractionSystem.Hand hand)
    // Offset: 0xDBB2A0
    void HandAttachedUpdate(::Valve::VR::InteractionSystem::Hand* hand);
    // public System.Void ArrowReleased()
    // Offset: 0xDBC030
    void ArrowReleased();
    // private System.Collections.IEnumerator ResetDrawAnim()
    // Offset: 0xDBC30C
    ::System::Collections::IEnumerator* ResetDrawAnim();
    // public System.Single GetArrowVelocity()
    // Offset: 0xDBC3AC
    float GetArrowVelocity();
    // public System.Void StartRotationLerp()
    // Offset: 0xDBC3B4
    void StartRotationLerp();
    // public System.Void StartNock(Valve.VR.InteractionSystem.ArrowHand currentArrowHand)
    // Offset: 0xDBC570
    void StartNock(::Valve::VR::InteractionSystem::ArrowHand* currentArrowHand);
    // private System.Void EvaluateHandedness()
    // Offset: 0xDBBCC4
    void EvaluateHandedness();
    // private System.Void DoHandednessCheck()
    // Offset: 0xDBC64C
    void DoHandednessCheck();
    // public System.Void ArrowInPosition()
    // Offset: 0xDBC6D0
    void ArrowInPosition();
    // public System.Void ReleaseNock()
    // Offset: 0xDBC770
    void ReleaseNock();
    // private System.Void ShutDown()
    // Offset: 0xDBC808
    void ShutDown();
    // private System.Void OnHandFocusLost(Valve.VR.InteractionSystem.Hand hand)
    // Offset: 0xDBCA60
    void OnHandFocusLost(::Valve::VR::InteractionSystem::Hand* hand);
    // private System.Void OnHandFocusAcquired(Valve.VR.InteractionSystem.Hand hand)
    // Offset: 0xDBCA98
    void OnHandFocusAcquired(::Valve::VR::InteractionSystem::Hand* hand);
    // private System.Void OnDetachedFromHand(Valve.VR.InteractionSystem.Hand hand)
    // Offset: 0xDBCAE8
    void OnDetachedFromHand(::Valve::VR::InteractionSystem::Hand* hand);
    // private System.Void OnDestroy()
    // Offset: 0xDBCB64
    void OnDestroy();
    // public System.Void .ctor()
    // Offset: 0xDBCB68
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static Longbow* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::Valve::VR::InteractionSystem::Longbow::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<Longbow*, creationType>()));
    }
  }; // Valve.VR.InteractionSystem.Longbow
  #pragma pack(pop)
  static check_size<sizeof(Longbow), 296 + sizeof(::GlobalNamespace::SteamVR_Events::Action*)> __Valve_VR_InteractionSystem_LongbowSizeCheck;
  static_assert(sizeof(Longbow) == 0x130);
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::Valve::VR::InteractionSystem::Longbow::Handedness, "Valve.VR.InteractionSystem", "Longbow/Handedness");
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Longbow::OnAttachedToHand
// Il2CppName: OnAttachedToHand
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::Longbow::*)(::Valve::VR::InteractionSystem::Hand*)>(&Valve::VR::InteractionSystem::Longbow::OnAttachedToHand)> {
  static const MethodInfo* get() {
    static auto* attachedHand = &::il2cpp_utils::GetClassFromName("Valve.VR.InteractionSystem", "Hand")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Longbow*), "OnAttachedToHand", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{attachedHand});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Longbow::Awake
// Il2CppName: Awake
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::Longbow::*)()>(&Valve::VR::InteractionSystem::Longbow::Awake)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Longbow*), "Awake", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Longbow::OnEnable
// Il2CppName: OnEnable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::Longbow::*)()>(&Valve::VR::InteractionSystem::Longbow::OnEnable)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Longbow*), "OnEnable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Longbow::OnDisable
// Il2CppName: OnDisable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::Longbow::*)()>(&Valve::VR::InteractionSystem::Longbow::OnDisable)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Longbow*), "OnDisable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Longbow::LateUpdate
// Il2CppName: LateUpdate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::Longbow::*)()>(&Valve::VR::InteractionSystem::Longbow::LateUpdate)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Longbow*), "LateUpdate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Longbow::OnNewPosesApplied
// Il2CppName: OnNewPosesApplied
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::Longbow::*)()>(&Valve::VR::InteractionSystem::Longbow::OnNewPosesApplied)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Longbow*), "OnNewPosesApplied", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Longbow::HandAttachedUpdate
// Il2CppName: HandAttachedUpdate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::Longbow::*)(::Valve::VR::InteractionSystem::Hand*)>(&Valve::VR::InteractionSystem::Longbow::HandAttachedUpdate)> {
  static const MethodInfo* get() {
    static auto* hand = &::il2cpp_utils::GetClassFromName("Valve.VR.InteractionSystem", "Hand")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Longbow*), "HandAttachedUpdate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{hand});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Longbow::ArrowReleased
// Il2CppName: ArrowReleased
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::Longbow::*)()>(&Valve::VR::InteractionSystem::Longbow::ArrowReleased)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Longbow*), "ArrowReleased", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Longbow::ResetDrawAnim
// Il2CppName: ResetDrawAnim
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Collections::IEnumerator* (Valve::VR::InteractionSystem::Longbow::*)()>(&Valve::VR::InteractionSystem::Longbow::ResetDrawAnim)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Longbow*), "ResetDrawAnim", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Longbow::GetArrowVelocity
// Il2CppName: GetArrowVelocity
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<float (Valve::VR::InteractionSystem::Longbow::*)()>(&Valve::VR::InteractionSystem::Longbow::GetArrowVelocity)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Longbow*), "GetArrowVelocity", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Longbow::StartRotationLerp
// Il2CppName: StartRotationLerp
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::Longbow::*)()>(&Valve::VR::InteractionSystem::Longbow::StartRotationLerp)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Longbow*), "StartRotationLerp", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Longbow::StartNock
// Il2CppName: StartNock
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::Longbow::*)(::Valve::VR::InteractionSystem::ArrowHand*)>(&Valve::VR::InteractionSystem::Longbow::StartNock)> {
  static const MethodInfo* get() {
    static auto* currentArrowHand = &::il2cpp_utils::GetClassFromName("Valve.VR.InteractionSystem", "ArrowHand")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Longbow*), "StartNock", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{currentArrowHand});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Longbow::EvaluateHandedness
// Il2CppName: EvaluateHandedness
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::Longbow::*)()>(&Valve::VR::InteractionSystem::Longbow::EvaluateHandedness)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Longbow*), "EvaluateHandedness", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Longbow::DoHandednessCheck
// Il2CppName: DoHandednessCheck
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::Longbow::*)()>(&Valve::VR::InteractionSystem::Longbow::DoHandednessCheck)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Longbow*), "DoHandednessCheck", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Longbow::ArrowInPosition
// Il2CppName: ArrowInPosition
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::Longbow::*)()>(&Valve::VR::InteractionSystem::Longbow::ArrowInPosition)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Longbow*), "ArrowInPosition", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Longbow::ReleaseNock
// Il2CppName: ReleaseNock
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::Longbow::*)()>(&Valve::VR::InteractionSystem::Longbow::ReleaseNock)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Longbow*), "ReleaseNock", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Longbow::ShutDown
// Il2CppName: ShutDown
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::Longbow::*)()>(&Valve::VR::InteractionSystem::Longbow::ShutDown)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Longbow*), "ShutDown", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Longbow::OnHandFocusLost
// Il2CppName: OnHandFocusLost
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::Longbow::*)(::Valve::VR::InteractionSystem::Hand*)>(&Valve::VR::InteractionSystem::Longbow::OnHandFocusLost)> {
  static const MethodInfo* get() {
    static auto* hand = &::il2cpp_utils::GetClassFromName("Valve.VR.InteractionSystem", "Hand")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Longbow*), "OnHandFocusLost", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{hand});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Longbow::OnHandFocusAcquired
// Il2CppName: OnHandFocusAcquired
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::Longbow::*)(::Valve::VR::InteractionSystem::Hand*)>(&Valve::VR::InteractionSystem::Longbow::OnHandFocusAcquired)> {
  static const MethodInfo* get() {
    static auto* hand = &::il2cpp_utils::GetClassFromName("Valve.VR.InteractionSystem", "Hand")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Longbow*), "OnHandFocusAcquired", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{hand});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Longbow::OnDetachedFromHand
// Il2CppName: OnDetachedFromHand
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::Longbow::*)(::Valve::VR::InteractionSystem::Hand*)>(&Valve::VR::InteractionSystem::Longbow::OnDetachedFromHand)> {
  static const MethodInfo* get() {
    static auto* hand = &::il2cpp_utils::GetClassFromName("Valve.VR.InteractionSystem", "Hand")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Longbow*), "OnDetachedFromHand", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{hand});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Longbow::OnDestroy
// Il2CppName: OnDestroy
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Valve::VR::InteractionSystem::Longbow::*)()>(&Valve::VR::InteractionSystem::Longbow::OnDestroy)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Valve::VR::InteractionSystem::Longbow*), "OnDestroy", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Valve::VR::InteractionSystem::Longbow::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
